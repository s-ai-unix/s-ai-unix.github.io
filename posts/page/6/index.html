<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | s-ai-unix's Blog</title><meta name=keywords content><meta name=description content="Posts - s-ai-unix's Blog"><meta name=author content="s-ai-unix"><link rel=canonical href=https://s-ai-unix.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.0833aff7e1cf567ecfb9755701ee95a80535f671e2e1a0a770c9bc20a0a7b5bb.css integrity="sha256-CDOv9+HPVn7PuXVXAe6VqAU19nHi4aCncMm8IKCntbs=" rel="preload stylesheet" as=style><link rel=icon href=https://s-ai-unix.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s-ai-unix.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s-ai-unix.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s-ai-unix.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s-ai-unix.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://s-ai-unix.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://s-ai-unix.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://s-ai-unix.github.io/posts/"><meta property="og:site_name" content="s-ai-unix's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://s-ai-unix.github.io/posts/"}]}</script><link rel=stylesheet href=https://s-ai-unix.github.io/css/classical-quote.css></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://s-ai-unix.github.io/ accesskey=h title="s-ai-unix's Blog (Alt + H)">s-ai-unix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s-ai-unix.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://s-ai-unix.github.io/posts/ title="📚 文章"><span class=active>📚 文章</span></a></li><li><a href=https://s-ai-unix.github.io/archives/ title="📁 归档"><span>📁 归档</span></a></li><li><a href=https://s-ai-unix.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://s-ai-unix.github.io/search/ title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://s-ai-unix.github.io/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://s-ai-unix.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/monte-carlo-method.jpg alt=蒙特卡罗方法的随机性可视化></figure><header class=entry-header><h2 class=entry-hint-parent>蒙特卡罗算法：从原子弹到人工智能的随机之旅</h2></header><div class=entry-content><p>引言：掷骰子解方程 想象一下，有人告诉你：要计算一个复杂的定积分，不需要微积分，只需要掷足够多的骰子。你大概会觉得这个人疯了。然而，这正是二十世纪最伟大的计算方法之一——蒙特卡罗方法（Monte Carlo Method）的核心思想。
当我们面对那些传统方法难以处理的高维积分、复杂系统的模拟或者无法解析求解的概率问题时，蒙特卡罗方法给出了一个看似简单却深刻的答案：用随机性来求解确定性问题。这种方法已经深入到科学的方方面面——从核物理到金融工程，从生物进化到人工智能，无处不见它的身影。
让我们从一个最经典的例子开始：如何用"扔针"来计算 $\pi$ 的值。
第一章：蒙特卡罗的诞生——曼哈顿计划的秘密代号 1.1 摩纳哥的赌场与原子弹的秘密 “蒙特卡罗"这个名字，源自摩纳哥著名的赌城。1940 年代，在洛斯阿拉莫斯实验室，一群顶尖的科学家正在紧锣密鼓地研制世界上第一颗原子弹。在这个属于"曼哈顿计划"的绝密基地里，数学家约翰·冯·诺伊曼（John von Neumann）和斯坦尼斯拉夫·乌拉姆（Stanislaw Ulam）正在研究核裂变中的中子扩散问题。
这个问题极其复杂：中子在原子弹内部的行为是随机的，它们可能被原子核捕获，可能引发新的裂变，也可能逃逸出去。传统的方法根本无法处理这种复杂的随机过程。
乌拉姆后来回忆起他是如何产生这个想法的：
“当时我正因病康复，在玩纸牌接龙。我开始思考：如果把牌随机排列一百次，大概有多少次能成功接龙？相比于把所有可能的情况都计算出来，直接实验似乎更容易…”
这个看似简单的想法，孕育了一个全新的计算方法。由于这种方法涉及随机性，而蒙特卡罗又以赌场闻名，冯·诺伊曼就给它起了"蒙特卡罗"这个代号——既是保密的需要，也恰如其分地描述了方法的本质。
1.2 早期的思想萌芽 虽然蒙特卡罗方法在1940年代才正式命名，但用随机性来解决确定性问题的思想古已有之。
1777年，布丰投针实验
法国数学家乔治-路易·勒克莱尔，布丰伯爵（Georges-Louis Leclerc, Comte de Buffon）提出了第一个著名的随机实验：
在一张画满平行线的纸（线间距为 $d$）上随机投掷一根长度为 $l$ 的针（$l &lt; d$），针与任意一条平行线相交的概率是多少？
布丰证明了，这个概率是：
$$ P = \frac{2l}{\pi d} $$
这给出了一个计算 $\pi$ 的方法：如果我们投掷针 $N$ 次，其中 $n$ 次与线相交，那么：
$$ \frac{n}{N} \approx \frac{2l}{\pi d} \implies \pi \approx \frac{2lN}{nd} $$
这个实验被多次验证：1850年，沃尔夫在苏黎世投掷了5000次，得到 $\pi \approx 3.1596$；1901年，拉泽里尼投掷3408次，甚至得到了精确到小数点后6位的 $\pi$ 值（虽然有人怀疑他可能"选择性记录"了结果）。
19世纪末的统计学革命
随着统计学的发展，卡尔·皮尔逊（Karl Pearson）等人开始使用随机抽样来解决统计问题。但这些方法仍然主要用于验证已知的结果，而不是作为通用的计算工具。
第二章：数学基础——为什么随机性有效？ 要理解蒙特卡罗方法，我们需要先理解它的数学基础。这一切都建立在大数定律和中心极限定理这两大概率论支柱之上。
...</p></div><footer class=entry-footer><span title='2026-01-21 23:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1171 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 蒙特卡罗算法：从原子弹到人工智能的随机之旅" href=https://s-ai-unix.github.io/posts/2026-01-21-monte-carlo-method/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/transformer-architecture.jpg alt="Transformer 架构的艺术化呈现"></figure><header class=entry-header><h2 class=entry-hint-parent>Transformer：重塑AI世界的架构革命</h2></header><div class=entry-content><p>引言 在人工智能的发展历程中，有几个时刻标志着技术范式的根本性转变。2017年10月就是这样一个时刻——Google Research 和多伦多大学的研究者们发表了一篇名为《Attention Is All You Need》的论文，提出了 Transformer 架构。
这篇论文的标题本身就是一种宣言：在这篇论文中，作者们向世界宣告，在处理序列数据时，注意力机制就是你所需要的一切。这篇论文不仅解决了长期困扰自然语言处理领域的难题，更开创了一个全新的 AI 时代。从 BERT 到 GPT 系列，从 PaLM 到 Claude，支撑现代大语言模型的核心架构都是 Transformer。
但 Transformer 到底是什么？它为什么如此重要？它是如何工作的？作为一个 AI 领域的深度从业者，我希望通过这篇文章，用最通俗易懂的方式，为你彻底解读这个重塑 AI 世界的重要架构。
第一章 背景：为什么我们需要 Transformer？ 1.1 序列数据处理的困境 在深入 Transformer 之前，让我们先理解它试图解决的问题。在自然语言处理、语音识别、机器翻译等任务中，我们面对的都是序列数据——句子是一系列词语的序列，语音是一系列声波的序列，DNA 是一系列碱基的序列。
对于序列数据的处理，传统的做法是使用循环神经网络（RNN）及其变体，如长短期记忆网络（LSTM）和门控循环单元（GRU）。这些网络的设计理念是：按顺序处理序列中的每个元素，将信息一步一步地传递下去。
RNN 的工作原理：想象你在读一本书。你的眼睛一次看一个字（或者一个词），然后大脑会记住这个字的意思，并结合之前记住的内容来理解整个句子。RNN 就是这样工作的——它按顺序处理输入序列，将之前的信息"记住"在隐藏状态中，然后用于处理下一个输入。
1.2 RNN 的致命缺陷 然而，RNN 存在几个根本性的问题：
第一个问题是长距离依赖问题。在处理长序列时，RNN 很难捕获序列前端和序列后端之间的关联。想象一个很长的句子：“那个在巴黎出生的，后来搬到纽约生活的，最后在北京去世的老人，年轻时是个著名的科学家。“要让 RNN 理解"老人"和"年轻时"之间的关系，信息需要从句子的一端传递到另一端。在这个过程中，信息会逐渐衰减，最终可能完全丢失。
第二个问题是计算效率问题。RNN 必须按顺序处理序列，这意味着第一步计算完成后才能开始第二步。这种串行计算的方式无法充分利用现代 GPU 的并行计算能力。在处理长序列时，计算变得非常耗时。
第三个问题是梯度消失和梯度爆炸问题。在反向传播过程中，梯度需要通过多个时间步传播。当序列很长时，梯度可能会变得非常小（消失）或非常大（爆炸），导致训练困难。
1.3 注意力机制的兴起 为了解决 RNN 的问题，研究者们提出了注意力机制（Attention Mechanism）。注意力机制的核心思想是：在处理序列中的每个元素时，我们不应该只依赖之前的信息，而应该能够"回顾"序列中的任意位置。
注意力的直观理解：想象你在嘈杂的咖啡馆里听朋友说话。即使周围很吵，你的大脑也能够聚焦于朋友的声音，而忽略背景噪音。注意力机制就是模拟这个过程——它让模型学会在处理每个词时，应该"关注"输入序列的哪些部分。
Bahdanau 等人在 2014 年提出了第一个注意力机制，用于机器翻译。这个注意力机制允许解码器在生成每个目标词时，关注源句子中的相关部分。这大大改善了机器翻译的性能。
但早期的注意力机制仍然是与 RNN 结合使用的。真正的革命性突破来自于 2017 年的那篇论文——作者们意识到，如果只使用注意力机制，我们就可以完全摆脱 RNN 的束缚。
...</p></div><footer class=entry-footer><span title='2026-01-21 10:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>985 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to Transformer：重塑AI世界的架构革命" href=https://s-ai-unix.github.io/posts/2026-01-21-transformer/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/laplace-transform.jpg alt=拉普拉斯变换概念图></figure><header class=entry-header><h2 class=entry-hint-parent>拉普拉斯变换：从概率论到工程数学的百年旅程</h2></header><div class=entry-content><p>引言：一个被遗忘又重新发现的数学工具 如果你学过信号与系统或者控制理论，你一定见过拉普拉斯变换。它像是一把魔法钥匙，能将复杂的微分方程变成简单的代数方程。但你知道吗？这个以拉普拉斯命名的工具，在拉普拉斯生前几乎无人问津，甚至被遗忘了整整一个世纪。
今天，拉普拉斯变换是工程数学中最基础的工具之一。它的故事不仅关于一个数学公式的诞生，更关于纯粹数学与应用数学之间曲折的关系——有时候，最实用的数学发现并不是由应用驱动的，而最深刻的应用也往往来自于那些最初看起来"毫无用处"的理论工作。
让我们回到18世纪末，从一切开始的地方说起。
第一章：前传——微积分时代的挑战 欧拉的先声 在拉普拉斯之前，莱昂哈德·欧拉（Leonhard Euler）就已经在思考类似的问题。1739年，欧拉在研究微分方程时，引入了一种后来被称为"生成函数"的方法。他的想法很巧妙：如果你有一个数列 $a_0, a_1, a_2, \ldots$，你可以把它"包装"成一个幂级数
$$ A(z) = \sum_{n=0}^{\infty} a_n z^n $$
然后，通过对 $A(z)$ 进行运算，你就可以间接地操作整个数列。这就像是把一堆散乱的珍珠串成一条项链，然后通过移动整条项链来调整每颗珍珠的位置。
欧拉用这种方法解决了一些差分方程。差分方程是微分方程的"离散版"，描述的是数列之间的关系，而不是连续函数之间的关系。但欧拉可能没有意识到，这个思想可以推广到连续世界。
拉格朗日的尝试 约瑟夫·路易·拉格朗日（Joseph-Louis Lagrange）在1770年代进一步发展了这个思想。他研究的不是差分方程，而是真正的微分方程。拉格朗日发现，某些类型的微分方程可以通过"变量替换"的方法简化。
想象一下，你有一个复杂的机器，操作起来很困难。但如果你换一个视角——比如把机器拆开，从另一个角度观察——可能会发现原来复杂的操作变得简单了。拉格朗日的变量替换就是这种"换个视角"的方法。
但真正系统化这个想法的人，是皮埃尔-西蒙·拉普拉斯。
第二章：拉普拉斯的登场——从概率论开始 1782年的论文 1782年，年轻的拉普拉斯发表了一篇关于概率论的论文。这篇论文的标题很长，但核心思想很清晰：他想研究如何从有限的观察中推断出背后的规律。
在概率论中，一个核心问题是：如果你知道一个随机变量服从某种分布，但不知道分布的参数，你应该如何从观测数据中推断这些参数？拉普拉斯意识到，这个问题可以转化成一个积分方程的问题。
他考虑这样一个积分：
$$ F(s) = \int_0^{\infty} f(t) e^{-st} , dt $$
这里的 $f(t)$ 是某个概率密度函数，而 $F(s)$ 是它的"像函数"。拉普拉斯发现，通过这个变换，原来关于 $f(t)$ 的复杂运算可以转化成关于 $F(s)$ 的简单运算。
为什么是 $e^{-st}$？ 你可能会问：为什么拉普拉斯选择了 $e^{-st}$ 这个核函数？这不是凭空的选择，而是有深刻的原因。
首先，指数函数 $e^{-st}$ 有一个美妙的性质：它的导数和它自己成比例
$$ \frac{d}{dt} e^{-st} = -s e^{-st} $$
这意味着，如果你对 $e^{-st}$ 乘以 $f(t)$ 然后积分，再对 $s$ 求导，你得到的会是 $t$ 乘以原函数的某种变换。具体来说：
...</p></div><footer class=entry-footer><span title='2026-01-21 10:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>640 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 拉普拉斯变换：从概率论到工程数学的百年旅程" href=https://s-ai-unix.github.io/posts/2026-01-21-laplace-transform-history/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/gaussian-distribution.jpg alt=正态分布钟形曲线></figure><header class=entry-header><h2 class=entry-hint-parent>正态分布：从赌桌到宇宙的完美曲线</h2></header><div class=entry-content><p>引言：钟声隐隐 如果你走进一个 crowded 的教室，测量每个人的身高；或者在同一条件下反复测量一个物理量；又或者在工厂里统计成千上万件产品的尺寸——你会发现，这些数据总是呈现出一种奇特的规律：大部分数值聚集在中间，越往两端越少。
画出分布图，你会看到一条优雅的曲线——中间隆起如钟，两侧缓缓下降，渐近于零却永不触及。这就是正态分布（Normal Distribution），也叫高斯分布（Gaussian Distribution）或钟形曲线（Bell Curve）。
它是概率论中最重要、最自然的分布。从气体分子的运动到股票价格的波动，从人类的身高到测量的误差，正态分布无处不在。
但你是否想过：为什么大自然偏爱这种分布？这条曲线是如何被人类发现的？它背后隐藏着怎样的数学之美？
让我们穿越回17、18世纪，去看看这条曲线是如何在历史的迷雾中逐渐浮现的。
第一章：前史——测量与误差的困惑 伽利略的洞见 早在1632年，伽利略在他的《关于两大世界体系的对话》中就观察到了一个有趣的现象：当你反复测量某个物理量时，误差总是呈现出一种规律——小的误差比大的误差更常见，正误差和负误差出现的频率大致相等。
这是人类对"误差分布"最早的直觉认知之一。伽利略并没有给出数学公式，但他敏锐地察觉到：观测误差并非杂乱无章，而是遵循某种规律。
早期天文学家的困扰 17、18世纪的天文学家面临着一个实际问题：同一颗行星或恒星，不同观测者得到的数据总有微小差异。如何从这些"有误差"的观测值中推断出真实值？
当时流行的方法是取平均值，但没有人能从理论上解释为什么这样做是合理的。一个困扰着那个时代科学家的问题是：是否存在一种"最优"的估计方法？
这些朴素的问题和观察，为正态分布的发现埋下了种子。
第二章：意外发现——棣莫弗与二项分布的极限 正态分布的第一次正式登场，来自一个看似毫不相关的问题：赌博。
亚伯拉罕·棣莫弗 亚伯拉罕·棣莫弗（Abraham de Moivre, 1667-1754）是一位法国-英国数学家。他年轻时因宗教迫害流亡英国，在伦敦靠当家庭教师和赌博顾问维生。
1733年，棣莫弗在研究一个具体问题时做出了一个重大发现：当伯努利试验的次数 $n$ 很大时，二项分布可以用一条光滑的曲线来近似。
这个发现最初只是他一本小册子中的一段内容，后来被收录进1738年出版的《机遇原理》（The Doctrine of Chances）第二版中。
从二项分布到正态曲线 考虑抛硬币的问题：抛 $n$ 次硬币，出现 $k$ 次正面的概率由二项分布给出：
$$P(X = k) = \binom{n}{k}p^k(1-p)^{n-k}$$
当 $n$ 很大时，直接计算这个公式非常困难——阶乘会变得极其巨大。棣莫弗想知道：能否找到一个近似公式？
通过巧妙的数学技巧（斯特林公式的早期版本），棣莫弗发现：当 $n \to \infty$ 时，标准化的二项分布收敛到：
$$f(x) = \frac{1}{\sqrt{2\pi}}e^{-x^2/2}$$
这就是标准正态分布的概率密度函数！
图1：棣莫弗-拉普拉斯极限定理。当二项分布的试验次数 $n$ 增大时，标准化后的分布逐渐逼近标准正态分布（红色曲线）。
历史的遗憾 有趣的是，棣莫弗并不知道自己发现了一个"普适"的分布。他只是把它当作计算二项分布的一个实用技巧。他的工作也没有引起当时学术界的广泛关注。
直到多年后，这条曲线才被拉普拉斯和高斯重新发掘，并赋予其更深刻的意义。
flowchart LR A["1632伽利略观测误差规律"] --> B["1733棣莫弗二项分布极限"] B --> C["1809高斯误差理论"] C --> D["1810拉普拉斯中心极限定理"] D --> E["1860麦克斯韦对称性推导"] style A fill:#FF9500,color:#fff,stroke-width:2px style B fill:#FF9500,color:#fff,stroke-width:2px style C fill:#007AFF,color:#fff,stroke-width:3px style D fill:#34C759,color:#fff,stroke-width:2px style E fill:#34C759,color:#fff,stroke-width:2px 第三章：高斯的革命——误差理论与最小二乘法 正态分布真正成为概率论的核心，要归功于卡尔·弗里德里希·高斯（Carl Friedrich Gauss, 1777-1855）。
...</p></div><footer class=entry-footer><span title='2026-01-21 10:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>520 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 正态分布：从赌桌到宇宙的完美曲线" href=https://s-ai-unix.github.io/posts/2026-01-21-gaussian-distribution-history/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/bayes-theorem.jpg alt=贝叶斯公式可视化></figure><header class=entry-header><h2 class=entry-hint-parent>贝叶斯公式：从牧师遗作到人工智能基石</h2></header><div class=entry-content><p>引言：从"上帝的视角"到"凡人的推断" 想象你是一名医生，患者刚刚做完某种疾病的筛查测试。测试结果是阳性。那么，这位患者真正患病的概率是多少？
如果你回答"既然测试准确率是95%，那么患病的概率就是95%"，那你和大多数人的直觉一样——但也一样错了。
正确答案可能让你吃惊：哪怕测试准确率达到95%，如果这种疾病在人群中发病率只有1%，那么一个阳性结果意味着患者真正患病的概率可能只有16%左右。
这个反直觉的结果，正是贝叶斯公式的核心思想：我们的信念应该随着新证据的到来而更新，但更新的方式不是简单的替换，而是要结合我们已有的知识（先验信息）。
贝叶斯公式不仅是一个数学定理，更是一种思维方式。它告诉我们：在信息不完整的世界里，我们如何从有限的数据中学习，如何科学地调整我们的信念。从18世纪的一位英国牧师兼数学家，到21世纪的人工智能，贝叶斯的思想经历了一段跌宕起伏的旅程。
timeline title 贝叶斯公式发展历程 section 18世纪 1763年 : 贝叶斯遗作发表 1812年 : 拉普拉斯系统阐述 section 19-20世纪 20世纪初 : 频率学派占据主导 20世纪中叶 : 萨瓦奇、杰弗里斯复兴贝叶斯思想 1980年代 : MCMC方法实用化 section 21世纪 21世纪 : 贝叶斯方法成为AI核心 第一章：贝叶斯牧师的那篇遗作 1.1 托马斯·贝叶斯其人 托马斯·贝叶斯（Thomas Bayes，1701-1761）是18世纪英国的一位长老会牧师，同时也是一位业余数学家。他出生于英格兰的一个显赫家庭，父亲是非国教牧师乔舒亚·贝叶斯。托马斯在爱丁堡大学学习神学和逻辑学，后来接任父亲的教职，在坦布里奇韦尔斯（Tunbridge Wells）担任牧师。
尽管贝叶斯在世时并未在数学领域发表太多作品，但他对概率论有着深刻的思考。他最著名的著作《机会问题的求解方法》（An Essay towards solving a Problem in the Doctrine of Chances）在他去世后于1763年发表在《皇家学会哲学汇刊》上。这篇论文由他的朋友理查德·普莱斯（Richard Price）整理并提交。
1.2 问题的提出：从"已知原因求结果"到"已知结果求原因" 贝叶斯关注的是一个根本性的哲学和数学问题：如果我们观察到某个结果，如何推断导致这个结果的原因？
在贝叶斯之前，概率论主要处理"正向概率"问题：如果我们知道某种原因，可以计算它产生特定结果的概率。例如，如果一枚硬币是均匀的，那么抛掷得到正面的概率是50%。
但现实中我们经常面临"逆向概率"问题：我们观察到了结果，想要推断原因。例如，我们观察到病人有某种症状，想推断他患某种疾病的概率；或者我们观察到数据，想推断产生这些数据的参数。
贝叶斯的天才之处在于，他用条件概率建立了因果推断的数学框架。
...</p></div><footer class=entry-footer><span title='2026-01-21 10:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>886 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 贝叶斯公式：从牧师遗作到人工智能基石" href=https://s-ai-unix.github.io/posts/2026-01-21-bayes-theorem/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/shannon-entropy.jpg alt=信息熵与通信理论></figure><header class=entry-header><h2 class=entry-hint-parent>香农信息熵：不确定性的数学刻度</h2></header><div class=entry-content><p>引言：一条电报引发的思考 信息是什么？ 1844年5月24日，萨缪尔·摩斯（Samuel Morse）从华盛顿向巴尔的摩发出了人类历史上第一条电报：
“What hath God wrought!”
这四个单词穿越了64公里的铜线，开启了电信时代。但在庆祝之余，一个问题逐渐浮现：这条消息究竟包含了多少"信息"？
这个问题看似简单，实则深奥。“信息"是一个抽象的概念，如何用数学来量化它？一封情书和一份天气预报，哪一份包含更多"信息”？一条加密后的消息和原始消息，信息量是否相同？
这些问题的答案，隐藏在一位贝尔实验室工程师的伟大发现中。
香农的登场 1948年，克劳德·香农（Claude Shannon）发表了题为《通信的数学理论》的论文。这篇32页的论文，被誉为"数字时代的创世大宪章"。
在论文中，香农给出了"信息"的精确定义，并引入了一个核心概念——信息熵。这个名字借用了热力学中的"熵"，暗示了两者之间深刻的联系。
本文将带你踏上一段历史与数学交织的旅程，从电报时代的实际问题出发，逐步揭示信息熵的诞生、内涵及其深远影响。
第一章：信息时代的黎明——通信效率的困惑 1.1 摩斯电码中的智慧 在香农之前，通信工程师们已经面临着一个实际问题：如何用最少的符号传输最多的信息？
摩斯电码给出了一个直观的答案。观察摩斯电码的设计：
E: . (最常用) T: - (第二常用) A: .- Q: --.- (很少使用) Z: --.. 摩斯天才地意识到：常用的字母应该用较短的编码，不常用的字母可以用较长的编码。这个设计原则在今天看来理所当然，但在当时是革命性的。
但这引发了更深层的思考：如何精确衡量一个字母的"常用程度"？如何计算整个编码系统的效率？这些问题需要数学语言的精确描述。
1.2 电报的经济学问题 19世纪的电报按字收费，一条消息的成本与其长度直接相关。因此，压缩信息不仅是技术问题，更是经济问题。
工程师们开始思考：
如果我们能知道每个字母出现的概率，能否设计出最优的编码？ 通信线路的"容量"有没有理论极限？ 噪声（干扰）对信息传输的影响有多大？ 这些问题的答案，要等到20世纪才逐渐浮现。
flowchart LR subgraph A["19世纪通信挑战"] A1["摩斯电码1837"] A2["电报经济学按长度收费"] end subgraph B["20世纪理论突破"] B1["奈奎斯特1924"] B2["哈特利1928"] B3["香农1948"] end subgraph C["现代信息时代"] C1["数字通信"] C2["数据压缩"] C3["机器学习"] end A1 --> B1 A2 --> B2 B1 --> B3 B2 --> B3 B3 --> C1 B3 --> C2 B3 --> C3 style A1 fill:#34C759,color:#ffffff,stroke-width:2px style A2 fill:#34C759,color:#ffffff,stroke-width:2px style B1 fill:#007AFF,color:#ffffff,stroke-width:2px style B2 fill:#007AFF,color:#ffffff,stroke-width:2px style B3 fill:#007AFF,color:#ffffff,stroke-width:3px style C1 fill:#34C759,color:#ffffff,stroke-width:2px style C2 fill:#34C759,color:#ffffff,stroke-width:2px style C3 fill:#34C759,color:#ffffff,stroke-width:2px 第二章：先驱的脚步——奈奎斯特与哈特利 2.1 奈奎斯特的发现 1924年，贝尔实验室的哈里·奈奎斯特（Harry Nyquist）在研究电报传输时，做出了一个重要发现。
...</p></div><footer class=entry-footer><span title='2026-01-21 10:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>891 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 香农信息熵：不确定性的数学刻度" href=https://s-ai-unix.github.io/posts/2026-01-21-shannon-entropy-comprehensive-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/perceptron-history.jpg alt=感知机发展历程></figure><header class=entry-header><h2 class=entry-hint-parent>感知机的完整发展历程：从线性分类到深度学习的基石</h2></header><div class=entry-content><p>引言：人工智能的原点 在人工智能的发展历程中，感知机（Perceptron）是一个具有里程碑意义的概念。它不仅是最早的机器学习算法之一，也是现代深度学习和神经网络的基础。
感知机的故事开始于 20 世纪中叶，当时计算机科学刚刚萌芽，科学家们开始探索如何让机器具备"学习"的能力。
第一章：感知机的诞生背景 1.1 早期人工智能研究的梦想 20 世纪 40 年代末到 50 年代初，随着计算机的诞生，科学家们开始思考：机器能否像人一样思考和学习？
图灵测试：1950 年，艾伦·图灵提出了著名的图灵测试，为人工智能的发展奠定了理论基础。 神经网络的早期构想：1943 年，麦卡洛克和皮茨提出了第一个人工神经网络模型，称为麦卡洛克-皮茨神经元。 1.2 罗森布拉特的突破 1957 年，美国心理学家弗兰克·罗森布拉特（Frank Rosenblatt）在康奈尔航空实验室提出了感知机模型。他将感知机描述为"能够通过经验自动学习的机器"。
罗森布拉特的工作受到了神经科学的启发，他试图模拟人类大脑中神经元的工作方式。
第二章：感知机的核心原理 2.1 感知机的基本结构 感知机是一个简单的线性分类器，它的结构非常简单：
graph TD A[输入] --> B[权重] C[偏置] --> D[求和] B --> D D --> E[激活函数] E --> F[输出] style A color:#ffffff,fill:#007AFF,stroke:#007AFF,stroke-width:3px style B color:#ffffff,fill:#34C759,stroke:#34C759,stroke-width:2px style C color:#ffffff,fill:#34C759,stroke:#34C759,stroke-width:2px style D color:#ffffff,fill:#007AFF,stroke:#007AFF,stroke-width:3px style E color:#ffffff,fill:#007AFF,stroke:#007AFF,stroke-width:3px style F color:#ffffff,fill:#007AFF,stroke:#007AFF,stroke-width:3px 2.2 感知机的工作原理 感知机的工作原理可以用以下公式表示：
...</p></div><footer class=entry-footer><span title='2026-01-21 08:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>749 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 感知机的完整发展历程：从线性分类到深度学习的基石" href=https://s-ai-unix.github.io/posts/2026-01-21-perceptron-development-history/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/shell-to-agent.jpg alt=命令行终端与AI助手的融合意象></figure><header class=entry-header><h2 class=entry-hint-parent>从 Shell 到 Agent：命令行到自然语言的演进之路</h2></header><div class=entry-content><p>前言：光标闪烁的岁月 曾经在 Linux 终端下敲了多年命令，Shell 脚本、Bash、Markdown 这些东西太熟悉了。所以当看到满屏都在讨论 AI Agent、Skills、Claude Code、OpenCode 时，一种夹杂着怀旧和欣喜，熟悉又陌生的感觉，难以抑制地涌上心头。
那些年，我们在黑底白字的终端里，光标一闪一闪，等待着精确的指令。而如今，同样的屏幕上，AI 正用自然语言和我们聊天。这不仅是工具的更迭，更是一场人机交互方式的根本性变革。
第一章：极客乐园与大众鸿沟 1.1 工具的双重属性 搞技术的人很多都喜欢 Shell 和命令行。管道符一串，几个工具配合起来，什么活都能干。这种体验有点像演奏乐器——当你熟练掌握了 grep、awk、sed 这些"音符"，就能组合出无限的可能。
但问题是，这套东西对普通人来说太劝退了。黑底白字，光标一闪一闪，不知道该输入什么——这种恐惧感，就像让一个从未摸过乐器的人站在舞台中央。
看看对比就明白了：
Bash 命令：
grep -i "error" log.txt | awk '{print $1,$4}' | sort | uniq -c AI Prompt：
帮我在日志文件中找出所有包含"error"的行，统计每个错误的发生次数 前者要记一堆命令和参数，输错一个字母就报错；后者直接说人话，交给 AI 来理解你到底要干嘛。这背后反映的是两种不同的哲学：
命令行范式：精确、可预期、零歧义，但学习曲线陡峭 自然语言范式：模糊、容错、对话式，但需要 AI 理解能力 从信息论的角度看，命令行是低熵高信噪比的交流方式，而自然语言是高熵高冗余的表达。前者追求效率，后者追求易用性。
1.2 大众产品的必经之路 单靠技术本身不够，把所有功能都做成按钮和菜单，点一点就能用。这才叫大众产品——把核心功能藏在优雅的交互界面后面，而不是让用户先上一门 Linux 入门课。
这里有一个有趣的权衡。如果我们用数学语言描述，可以定义一个可用性函数：
$$ U = \alpha \cdot E - \beta \cdot L - \gamma \cdot C $$
其中：
$U$ 是可用性评分 $E$ 是任务完成效率 $L$ 是学习成本 $C$ 是认知负荷 $\alpha, \beta, \gamma$ 是权重系数 命令行工具的 $E$ 很高，但 $L$ 和 $C$ 也高；AI Agent 的 $E$ 可能略低（因为偶尔理解错），但 $L$ 和 $C$ 显著降低。对于普通用户，这个函数的最优解显然偏向后者。
...</p></div><footer class=entry-footer><span title='2026-01-21 00:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>615 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 从 Shell 到 Agent：命令行到自然语言的演进之路" href=https://s-ai-unix.github.io/posts/2026-01-21-from-shell-to-agent/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/iso-8800-ai-safety.jpg alt=AI安全网络示意图></figure><header class=entry-header><h2 class=entry-hint-parent>ISO/PAS 8800:2024 道路车辆人工智能安全工程——从确定性到概率性的范式转移</h2></header><div class=entry-content><p>引言：确定性基石的动摇与重构 本文仅代表本人以及所使用的AI工具的观点， 不代表任何公司或者机构实体的意见！
在汽车工业百年的发展历程中，安全工程的基石始终建立在确定性逻辑之上。传统的 ISO 26262 功能安全标准，其核心哲学是"防错"——通过严格的流程控制和硬件冗余，防止电子电气系统发生非预期的故障。这种思想在数学上对应着清晰的布尔代数：系统要么正常（$x = 1$），要么失效（$x = 0$），边界分明。
然而，随着人工智能（AI），特别是深度学习技术在自动驾驶感知、预测及决策模块中的深度渗透，这一确定性基石遭遇了前所未有的冲击。AI 系统的行为不再完全由代码行数决定，而是由数据分布、模型架构及训练过程中的随机性共同涌现而成。以神经网络为例，其输出可以表示为：
$$ y = f(x; \theta) = \sigma_L(W_L \cdot \sigma_{L-1}(W_{L-1} \cdot \ldots \cdot \sigma_1(W_1 \cdot x + b_1) \ldots) + b_L) $$
其中 $\theta = {W_1, b_1, \ldots, W_L, b_L}$ 是通过训练过程优化的参数。这种"黑盒"特性与概率性输出，使得传统的安全保障体系面临巨大的逻辑真空。
ISO/PAS 8800:2024《道路车辆——安全与人工智能》 的发布，标志着汽车安全工程正式进入了"数据定义安全“的新纪元。这不仅仅是一份新的技术规范，它是对现有安全方法论的一次系统性重构：它不再试图将 AI 强行塞入确定性的框架，而是承认 AI 的不确定性，并提供了一套全新的数学与工程语言来量化、管理和控制这种不确定性。
本文将从数学原理出发，系统性地解读 ISO 8800 的核心概念，并通过实战案例，展示如何在不确定的 AI 世界中构建可信的安全系统。
第一章：标准定位——三大安全支柱的逻辑互补 1.1 安全体系的演进：从单点防御到立体防护 理解 ISO 8800 的首要任务，是厘清其在现有安全标准体系中的生态位。现代汽车安全体系正演变为由 ISO 26262、ISO 21448 和 ISO 8800 共同支撑的三维架构。这三大标准并非简单的并列关系，而是形成了一个严密的逻辑闭环：
...</p></div><footer class=entry-footer><span title='2026-01-20 21:10:00 +0800 CST'>January 20, 2026</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>1710 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to ISO/PAS 8800:2024 道路车辆人工智能安全工程——从确定性到概率性的范式转移" href=https://s-ai-unix.github.io/posts/2026-01-20-iso-8800-comprehensive-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/fourier-series.jpg alt=傅里叶级数的波形叠加></figure><header class=entry-header><h2 class=entry-hint-parent>傅里叶级数：用正弦波重构世界</h2></header><div class=entry-content><p>引言：1822年的一个大胆断言 想象你站在19世纪初的巴黎，一位头发花白的法国数学家约瑟夫·傅里叶（Joseph Fourier）刚刚完成了一部巨著《热的解析理论》。在这本书中，他提出了一个在当时看来近乎荒谬的断言：
任何周期函数，无论多么复杂，都可以表示为简单的正弦和余弦函数的无穷级数。
这个想法在当时激起了巨大的争议。著名的数学家拉格朗日（Lagrange）甚至认为这是不可能的。但傅里叶坚持自己的观点，并用这个方法成功解决了困扰数学家多年的热传导方程。
为什么这个想法如此重要？因为正弦函数 $\sin(x)$ 和余弦函数 $\cos(x)$ 是我们最理解、最容易处理的函数。如果任何复杂函数都能分解成这些简单函数的叠加，那么我们就可以把复杂问题转化为简单问题来解决。
今天，从你的手机音乐播放器到医学影像设备，从JPEG图像压缩到量子力学计算，傅里叶的思想无处不在。让我们从历史的长河出发，逐步理解这个改变世界的数学工具。
第一章：历史演变——从音乐到数学的千年旅程 1.1 古希腊的发现：音乐是数学 公元前6世纪，毕达哥拉斯（Pythagoras）做了一个著名的实验。他拨动不同长度的琴弦，发现：
当弦长比例为 $2:1$ 时，听起来是八度音 当弦长比例为 $3:2$ 时，听起来是五度音 当弦长比例为 $4:3$ 时，听起来是四度音 这让他意识到：音乐的和谐可以用数学比例来描述。这是人类第一次认识到声音的"频率"概念——琴弦振动越快，音调越高。
更神奇的是，古希腊人还发现：任何复杂的声音都可以分解为多个"纯音"（正弦波）的组合。这其实就是傅里叶级数思想的萌芽！
1.2 18世纪的挑战：弦振动的谜题 时间来到18世纪，物理学家们对弦的振动产生了浓厚兴趣。小提琴、钢琴的弦是如何振动的？如何从数学上描述这种振动？
1747年，达朗贝尔（d’Alembert）得到了弦振动方程： $$ \frac{\partial^2 y}{\partial t^2} = c^2 \frac{\partial^2 y}{\partial x^2} $$
但这个方程的解是什么？欧拉（Euler）和伯努利（Bernoulli）分别给出了不同的解答。伯努利提出：弦的任何运动都可以表示为"固有模式"（正弦波）的叠加。
$$ y(x,t) = \sum_{n=1}^{\infty} A_n \sin\left(\frac{n\pi x}{L}\right)\cos\left(\frac{n\pi c t}{L}\right) $$
但拉格朗日质疑：任意函数真的都能这样分解吗？ 这个争论持续了半个多世纪，直到傅里叶给出答案。
1.3 1807年：傅里叶的革命性论文 1807年，傅里叶向法国科学院提交了一篇关于热传导的论文。在研究金属棒中热量如何传播时，他遇到了一个难题：如何表示初始温度分布？
傅里叶提出：初始温度函数 $f(x)$ 可以表示为
$$ f(x) = a_0 + \sum_{n=1}^{\infty} a_n \cos\left(\frac{n\pi x}{L}\right) + b_n \sin\left(\frac{n\pi x}{L}\right) $$
...</p></div><footer class=entry-footer><span title='2026-01-20 21:00:00 +0800 CST'>January 20, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1287 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 傅里叶级数：用正弦波重构世界" href=https://s-ai-unix.github.io/posts/2026-01-20-fourier-series/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://s-ai-unix.github.io/posts/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://s-ai-unix.github.io/posts/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://s-ai-unix.github.io/>s-ai-unix's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script></body></html>