<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | s-ai-unix's Blog</title><meta name=keywords content><meta name=description content="Posts - s-ai-unix's Blog"><meta name=author content="s-ai-unix"><link rel=canonical href=https://s-ai-unix.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.0833aff7e1cf567ecfb9755701ee95a80535f671e2e1a0a770c9bc20a0a7b5bb.css integrity="sha256-CDOv9+HPVn7PuXVXAe6VqAU19nHi4aCncMm8IKCntbs=" rel="preload stylesheet" as=style><link rel=icon href=https://s-ai-unix.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s-ai-unix.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s-ai-unix.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s-ai-unix.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s-ai-unix.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://s-ai-unix.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://s-ai-unix.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://s-ai-unix.github.io/posts/"><meta property="og:site_name" content="s-ai-unix's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://s-ai-unix.github.io/posts/"}]}</script><link rel=stylesheet href=https://s-ai-unix.github.io/css/classical-quote.css></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://s-ai-unix.github.io/ accesskey=h title="s-ai-unix's Blog (Alt + H)">s-ai-unix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s-ai-unix.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://s-ai-unix.github.io/posts/ title="📚 文章"><span class=active>📚 文章</span></a></li><li><a href=https://s-ai-unix.github.io/archives/ title="📁 归档"><span>📁 归档</span></a></li><li><a href=https://s-ai-unix.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://s-ai-unix.github.io/search/ title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://s-ai-unix.github.io/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://s-ai-unix.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/wave-equation.jpg alt=波动的抽象可视化></figure><header class=entry-header><h2 class=entry-hint-parent>波动方程：从弦振动到宇宙的波动</h2></header><div class=entry-content><p>引言：从一根振动的吉他弦开始 想象一下，你拨动吉他的一根弦。弦开始振动，发出优美的声音。如果你用高速摄像机拍摄这个过程，会看到弦的形状随时间不断变化：向上弯曲，向下弯曲，再向上弯曲……这种运动有什么规律？
更具体地说，如果已知某个时刻弦的形状，你能预测下一时刻它的形状吗？这个问题看似简单，但它引领我们走向数学物理中最重要的方程之一——波动方程。
在 18 世纪，几位伟大的数学家——达朗贝尔（d’Alembert）、欧拉（Euler）和伯努利（Bernoulli）——都在思考这个问题。他们的答案不仅解释了弦振动，还为声学、光学、地震学甚至量子力学奠定了基础。
让我们从这根弦开始，一步步揭开波动方程的面纱。
第一章：波动的物理本质 什么是波？ 在开始推导方程之前，我们需要明确：什么是波？
波是振动在空间中的传播。当某个点的物理量（如位移、压力、电场等）随时间振动时，这种振动会影响周围的点，并传播出去。波不需要物质的长距离移动，它传播的是能量和信息。
想象一下水面上的波纹。当你往平静的水面投一块石子，水并没有整体移动，但波纹会一圈圈扩散开来——这就是波的传播。
波的分类 波可以分为两大类：
横波（Transverse Wave）：振动方向与传播方向垂直
例子：吉他弦振动、光波 特点：弦上下的振动，波沿弦的方向传播 纵波（Longitudinal Wave）：振动方向与传播方向平行
例子：声波（空气分子的振动） 特点：空气分子沿声音传播方向前后振动 波的基本性质 描述波的几个关键参数：
频率 $f$：单位时间内振动的次数（单位：赫兹 Hz） 周期 $T = \frac{1}{f}$：完成一次振动所需的时间 波长 $\lambda$：波完成一个周期在空间中传播的距离 波速 $c$：波传播的速度，满足 $c = f\lambda$ 振幅 $A$：波偏离平衡位置的最大值 这些参数不是孤立的，它们通过波动方程联系在一起。
第二章：一维波动方程的诞生 牛顿第二定律与弦的振动 考虑一根均匀的弦，两端固定（比如吉他弦）。设弦的线密度（单位长度的质量）为 $\rho$，张力为 $T_0$。弦在平衡时是一条直线。
当弦发生微小振动时，设弦上位置 $x$、时间 $t$ 的横向位移为 $u(x, t)$。我们的目标是推导 $u(x, t)$ 满足的方程。
取弦上从 $x$ 到 $x + \Delta x$ 的一小段。这一段的长度约为 $\Delta x$，质量为 $\rho \Delta x$。
根据牛顿第二定律（$F = ma$），这一小段的运动方程为：
...</p></div><footer class=entry-footer><span title='2026-01-14 22:04:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1163 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 波动方程：从弦振动到宇宙的波动" href=https://s-ai-unix.github.io/posts/2026-01-14-wave-equation/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1620641788421-7a1c342ea42e.jpg alt=热传导的抽象可视化></figure><header class=entry-header><h2 class=entry-hint-parent>热传导方程：从一杯咖啡到宇宙的演化</h2></header><div class=entry-content><p>引言：从一杯热咖啡开始 想象一下，你刚泡好一杯热咖啡。咖啡的温度大约是 90°C，而周围的室温是 20°C。随着时间的推移，咖啡会慢慢变凉——这是每个人每天都在经历的现象。但你是否想过，这背后隐藏着怎样的数学规律？
如果我用温度计每隔一段时间测量咖啡的温度，会发现温度不是突然跳变的，而是平滑地、连续地下降。这种变化不是线性的——刚开始降得快，后来降得慢。为什么？
答案就隐藏在热传导方程中。这个方程不仅描述了咖啡的冷却，还描述了热量如何在金属棒中传播、如何从太阳内部传到表面，甚至描述了气体分子的扩散、股票价格的波动，以及宇宙中星系的分布。它可能是物理学中应用最广的偏微分方程之一。
让我们从傅里叶的实验开始，一步步揭开这个方程的面纱。
第一章：热传导的物理本质 什么是热量？ 在开始推导方程之前，我们需要明确几个概念。热量不是温度，而是能量的传递。温度是物质内部粒子平均动能的量度——温度越高，粒子运动越剧烈。当两个物体接触时，能量会从高温区域流向低温区域，直到两处温度相同。这就是热传导的物理本质。
早在 19 世纪初，法国数学家让·巴普蒂斯特·约瑟夫·傅里叶（Jean-Baptiste Joseph Fourier） 就开始系统研究这种现象。傅里叶原本是拿破仑时代的数学家，但对热的本质有着浓厚的兴趣。他在 1807 年提出了一个大胆的猜想：
热流与温度梯度成正比。
这句话听起来很简单，但它是整个热传导理论的基石。让我们翻译成数学语言。
傅里叶定律 设 $\mathbf{q}$ 表示热流密度（单位时间内通过单位面积的热量），$T(x, t)$ 表示在位置 $x$、时间 $t$ 时的温度。那么傅里叶定律可以写成：
$$ \mathbf{q} = -k \nabla T $$
其中 $k$ 是热导率（thermal conductivity），负号表示热量从高温流向低温。
在一维情况下，这个公式简化为：
$$ q = -k \frac{\partial T}{\partial x} $$
这里的 $\frac{\partial T}{\partial x}$ 是温度对位置的偏导数，也就是温度梯度。如果温度随位置的变化率越大（梯度越大），热流就越大。
傅里叶定律的一个直观理解是：温度的差异驱动热量的流动，就像电压的差异驱动电流的流动、水位的高低差驱动水的流动一样。这三种现象背后有着深刻的数学相似性。
第二章：从傅里叶定律到热传导方程 傅里叶定律告诉我们热流与温度梯度的关系，但它还不够——我们想知道温度本身随时间如何变化。这需要将傅里叶定律与另一个物理原理结合：能量守恒。
能量守恒定律 考虑一段细长的金属棒，横截面积为 $A$，热导率为 $k$，密度为 $\rho$，比热容为 $c$。我们要分析从位置 $x$ 到 $x + \Delta x$ 这一小段在时间 $\Delta t$ 内的热量变化。
...</p></div><footer class=entry-footer><span title='2026-01-14 21:54:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>878 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 热传导方程：从一杯咖啡到宇宙的演化" href=https://s-ai-unix.github.io/posts/2026-01-14-heat-conduction-equation/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1620641788421-7a1c342ea42e.jpg alt=抽象几何空间></figure><header class=entry-header><h2 class=entry-hint-parent>黎曼张量度量：弯曲空间的距离语言</h2></header><div class=entry-content><p>引言：如何测量弯曲的世界？ 想象一下，你生活在一个球面上。如果你想测量两点之间的距离，或者两条线之间的夹角，你会怎么做？
在平坦的欧几里得平面上，这很简单：距离用勾股定理计算，角度用点积定义。但在球面上，直线变成了大圆弧，勾股定理不再成立，角度的计算也变得更加复杂。
问题的关键在于：我们需要一个通用的方法来定义任意空间中的距离和角度。
这个方法就是黎曼度量（Riemannian Metric），或者更准确地说，度量张量（Metric Tensor）。它是黎曼几何的基础，也是广义相对论中描述时空的核心工具。
第一章：从勾股定理到度量张量 欧几里得距离 在二维欧几里得平面上，两点 $(x_1, y_1)$ 和 $(x_2, y_2)$ 之间的距离是：
$$ d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} $$
这个公式源自勾股定理。更一般地，如果我们考虑一个微小的位移 $(dx, dy)$，那么对应的距离是：
$$ ds^2 = dx^2 + dy^2 $$
这个表达式被称为线元素（line element）。它告诉我们：沿 $x$ 方向移动 $dx$，沿 $y$ 方向移动 $dy$，总距离的平方是 $dx^2 + dy^2$。
三维欧几里得空间 在三维欧几里得空间中，线元素是：
$$ ds^2 = dx^2 + dy^2 + dz^2 $$
我们可以把它写成矩阵形式：
$$ ds^2 = \begin{pmatrix} dx & dy & dz \end{pmatrix} \begin{pmatrix} 1 & 0 & 0 \ 0 & 1 & 0 \ 0 & 0 & 1 \end{pmatrix} \begin{pmatrix} dx \ dy \ dz \end{pmatrix} $$
...</p></div><footer class=entry-footer><span title='2026-01-14 21:35:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1144 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 黎曼张量度量：弯曲空间的距离语言" href=https://s-ai-unix.github.io/posts/2026-01-14-riemann-metric-tensor/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1509228468518-180dd4864904.jpg alt=抽象几何空间></figure><header class=entry-header><h2 class=entry-hint-parent>黎曼曲率张量：弯曲时空的数学语言</h2></header><div class=entry-content><p>引言：从二维到无穷维 在我们之前的文章中，我们探索了高斯曲率（Gaussian Curvature），这个概念描述了二维曲面的弯曲程度。高斯的伟大发现是：曲面的弯曲是"内蕴"的，即只依赖于曲面自身的度量，而与曲面在三维空间中的嵌入方式无关。
但是，如果我们生活在四维时空中呢？或者更高维的空间？我们还能用同样的方式描述弯曲吗？
答案是肯定的，但需要更加强大的数学工具。这个工具就是黎曼曲率张量（Riemann Curvature Tensor），由伟大的数学家伯恩哈德·黎曼（Bernhard Riemann）在19世纪中叶提出。
黎曼曲率张量是黎曼几何的核心概念，它不仅推广了高斯曲率，更成为了广义相对论中描述时空弯曲的数学基础。
第一章：回顾高斯的遗产 在深入黎曼曲率张量之前，让我们简要回顾高斯的工作。
高斯曲率与绝妙定理 对于二维曲面，高斯曲率 $K$ 定义为：
$$ K = \frac{LN - M^2}{EG - F^2} $$
其中 $E, F, G$ 是第一基本形式的系数，$L, M, N$ 是第二基本形式的系数。
高斯的绝妙定理告诉我们：$K$ 可以仅用 $E, F, G$ 及其导数表示，因此是曲面的内蕴性质。
这个定理暗示了一个深刻的观点：空间本身可能有内在的几何结构，这种结构不依赖于任何"外部"空间。
从曲面到更高维度 高斯的工作集中在二维曲面上。但问题是：如何将这个思想推广到更高维度？
答案是：我们需要一种能够描述任意维度空间弯曲的数学对象。这个对象必须满足：
在二维情况下，它应该退化到高斯曲率 它应该包含足够的信息来描述任意方向、任意平面上的弯曲 它应该是内蕴的（即只依赖于度量） 黎曼曲率张量正是满足这些要求的数学对象。
第二章：黎曼的远见——1854年的演讲 伯恩哈德·黎曼（1826-1866） 伯恩哈德·黎曼是高斯的学生，也是数学史上最具原创性的思想家之一。他的工作跨越数论、复分析、微分几何等多个领域。
1854年6月10日，黎曼在哥廷根大学做了题为**《论几何基础的假设》**（Über die Hypothesen, welche der Geometrie zu Grunde liegen）的演讲。这篇演讲被认为是微分几何史上最重要的文献之一，也是黎曼几何的奠基之作。
黎曼几何的基本思想 在这次演讲中，黎曼提出了一个革命性的想法：几何不一定是三维欧几里得空间的子集，它可以是任意维度的"流形"（manifold）。
黎曼定义：
流形（Manifold）：局部看起来像欧几里得空间的几何对象 度量（Metric）：定义流形上两点之间的距离和角度 曲率（Curvature）：描述流形的弯曲程度 黎曼意识到：如果我们有一个度量 $g_{ij}$，我们可以计算各种几何量，包括曲率。但这个曲率在高维情况下应该是什么样的？
黎曼的原始定义 黎曼在演讲中给出了曲率的原始定义（与现代形式略有不同）：
考虑流形上一点 $P$，取两个切向量 $X, Y$。沿着由 $X$ 和 $Y$ 张成的二维平面，我们可以构建一个"测地三角形"。这个三角形在流形上沿着测地线（最短路径）连接三点。
...</p></div><footer class=entry-footer><span title='2026-01-14 21:28:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>858 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 黎曼曲率张量：弯曲时空的数学语言" href=https://s-ai-unix.github.io/posts/2026-01-14-riemann-curvature-tensor/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1635070041078-e363dbe005cb.jpg alt=抽象几何图形></figure><header class=entry-header><h2 class=entry-hint-parent>高斯曲率：弯曲世界的数学语言</h2></header><div class=entry-content><p>引言：弯曲的世界 想象一下，你是一只蚂蚁，生活在一个巨大的球面上。对于这只蚂蚁来说，这个世界看起来是什么样子的？如果你问它：“这个世界是平的还是弯曲的？“它会怎么回答？
这个问题看似简单，却蕴含着深刻的数学思想。古希腊的欧几里得用五条公理构建了完美的平面几何学，但现实世界中的曲面——球面、马鞍面、波浪形的海浪——让数学家们不得不思考：如何描述这些弯曲的几何形状？
答案就是曲率，特别是高斯曲率（Gaussian Curvature）。这个概念不仅改变了我们对几何的理解，更成为了现代物理的基石。
第一章：曲率的直观理解 在深入数学之前，让我们先从直觉出发，理解什么是"弯曲”。
直线的曲率 一条直线没有弯曲，我们说它的曲率为零。这一点很直观——直线上任意一点都朝同一个方向延伸，没有"拐弯”。
圆的曲率呢？如果一个圆的半径是 $R$，那么它的曲率定义为：
$$ \kappa = \frac{1}{R} $$
这个定义很合理：圆越小（半径越小），弯曲得越厉害，曲率越大；圆越大（半径越大），弯曲越不明显，曲率越小；当半径趋于无穷大时，圆就变成了直线，曲率趋于零。
平面曲线的曲率 对于任意一条平面曲线，我们可以这样定义曲率：在某一点处，找一个最接近该曲线的圆（称为"密切圆"），这个圆的曲率就是曲线在该点的曲率。
数学上，如果曲线由参数方程 $(x(t), y(t))$ 给出，曲率的公式是：
$$ \kappa = \frac{|x’(t)y’’(t) - y’(t)x’’(t)|}{(x’(t)^2 + y’(t)^2)^{3/2}} $$
这个公式看起来有点复杂，但本质上就是用曲线的二阶导数（加速度）来描述弯曲程度。
从曲线到曲面 现在我们要迈出关键的一步：从曲线到曲面。球面是弯曲的，马鞍面也是弯曲的，但它们"弯曲"的方式不同。这种差异，正是高斯曲率要捕捉的。
第二章：从平面到曲面——数学家的探索 古希腊的遗产 古希腊几何学以欧几里得的《几何原本》为代表，建立在五条公理之上。其中最著名的是第五公理（平行公理）：“过直线外一点，有且只有一条直线与该直线平行。”
这条公理在平面上成立，但在曲面上却不一定成立。这暗示着，曲面的几何可能与平面有本质区别。
黎曼前的探索 在19世纪初，数学家们开始思考更一般的几何学。Gauss（高斯）之前的一些数学家，如Monge和Euler，已经研究过曲面的某些性质。
莱昂哈德·欧拉（Leonhard Euler）在1760年给出了一个重要发现：对于曲面上的任意一点，存在两个特殊的方向，沿着这两个方向的法曲率分别取得最大值和最小值。这两个值被称为主曲率，记为 $\kappa_1$ 和 $\kappa_2$。
欧拉还发现了一个重要公式：如果两个主方向之间的夹角是 $\theta$，那么沿着与第一个主方向夹角为 $\phi$ 的方向的法曲率是：
$$ \kappa_n(\phi) = \kappa_1 \cos^2 \phi + \kappa_2 \sin^2 \phi $$
这个公式被称为欧拉曲率公式，它告诉我们，如果知道了两个主曲率，就知道了一切方向的法曲率。
但欧拉的研究有一个局限：他只考虑了法曲率，即沿着某个方向在法平面内的曲率。这种曲率依赖于曲面在空间中的"嵌入方式"，被称为"外蕴曲率"（extrinsic curvature）。
卡尔·弗里德里希·高斯的登场 卡尔·弗里德里希·高斯（Carl Friedrich Gauss, 1777-1855）是数学史上最伟大的数学家之一。他在1827年发表了一篇里程碑式的论文：《关于曲面的一般研究》（Disquisitiones Generales Circa Superficies Curvas）。
...</p></div><footer class=entry-footer><span title='2026-01-14 21:16:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1121 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 高斯曲率：弯曲世界的数学语言" href=https://s-ai-unix.github.io/posts/2026-01-14-gaussian-curvature/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/geometry-curves.jpg alt=几何曲线的抽象艺术图></figure><header class=entry-header><h2 class=entry-hint-parent>Frenet标架：微分几何的优雅语言与工程实践</h2></header><div class=entry-content><p>引言：从高速公路的弯道说起 想象一下，你正驾驶着汽车行驶在高速公路上，前方出现一个弯道。作为驾驶员，你会下意识地做几件事：判断弯道的急缓程度（曲率）、调整方向盘的角度（切向量）、控制车速，甚至在复杂的弯道上，你会感受到车身有轻微的侧倾或仰俯（挠率）。
这些看似简单的驾驶行为背后，隐藏着深刻的数学原理：如何在任意一点附近，用最简洁的方式描述一条空间曲线的几何性质？
这就是19世纪数学家们面临的核心问题。而他们的答案——Frenet标架（Frenet Frame），不仅成为了微分几何的基石，更在今天的自动驾驶和机器人工程中扮演着不可或缺的角色。
让我们从这段跨越170年的数学之旅开始，逐步揭开Frenet标架的神秘面纱。
第一章：19世纪的几何革命 在19世纪中叶，微分几何正处于一个激动人心的时期。传统的欧几里得几何关注的是静态的图形性质——三角形的内角和、圆的面积等等。但数学家们开始思考一个更动态的问题：如何研究"弯曲"的对象？
这个问题的种子早在17世纪就由牛顿和莱布尼茨播下——微积分的发明让人们能够描述变化的速率。到了19世纪，数学家们意识到，微积分可以用来研究曲线和曲面的局部性质，而不只是全局性质。
Frenet的突破 1847年，法国数学家Jean Frédéric Frenet在他的博士论文中提出了一个革命性的想法：在空间曲线上的每一点，我们可以建立一个自然的局部坐标系。这个坐标系不是任意选择的，而是由曲线本身的几何性质唯一确定的。
Serret的独立发现 几乎在同一时间，另一位法国数学家Joseph Alfred Serret也独立地发现了同样的结果。这就是为什么这个框架被称为"Frenet-Serret公式"。今天，我们更常称之为"Frenet标架"，以纪念Frenet率先发表的贡献。
这个发现的巧妙之处在于：它用三个相互正交的向量，完整地刻画了曲线在任意点的局部几何。这三个向量——切向量、法向量和副法向量——构成了一个"移动标架"，随着我们在曲线上移动而不断变化。
第二章：构建Frenet标架——从直觉到严谨 让我们从直观到严谨，一步步构建Frenet标架。
第一步：切向量（Tangent Vector） 想象一辆小车沿着一条空间曲线行驶。在任意时刻，小车都有一个瞬时速度向量，指向它运动的方向。这个方向就是曲线在该点的切线方向。
假设曲线由参数方程 $\mathbf{r}(t) = (x(t), y(t), z(t))$ 描述，其中 $t$ 是参数（可以想象成时间）。那么切向量就是速度向量：
$$ \mathbf{v}(t) = \frac{d\mathbf{r}}{dt} = \left(\frac{dx}{dt}, \frac{dy}{dt}, \frac{dz}{dt}\right) $$
这个向量的大小代表了运动的快慢，但作为几何性质，我们更关注方向。因此，我们将切向量标准化为单位向量：
$$ \mathbf{T}(t) = \frac{\mathbf{v}(t)}{|\mathbf{v}(t)|} = \frac{\frac{d\mathbf{r}}{dt}}{\left|\frac{d\mathbf{r}}{dt}\right|} $$
直觉理解：$\mathbf{T}$ 指向曲线"前方"，代表运动的方向。
第二步：主法向量（Principal Normal Vector） 接下来，我们考虑切向量的变化率。$\mathbf{T}$ 的方向会随着曲线弯曲而改变，这种改变的方向如何描述？
对 $\mathbf{T}$ 求导：
$$ \frac{d\mathbf{T}}{ds} $$
这里我们用弧长 $s$ 作为参数（稍后解释为什么）。由于 $\mathbf{T}$ 是单位向量，$\mathbf{T} \cdot \mathbf{T} = 1$，对其求导得到：
...</p></div><footer class=entry-footer><span title='2026-01-14 20:35:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1243 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to Frenet标架：微分几何的优雅语言与工程实践" href=https://s-ai-unix.github.io/posts/2026-01-14-frenet-frame-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/darboux-theory-of-surfaces.jpg alt=经典数学著作></figure><header class=entry-header><h2 class=entry-hint-parent>达布《曲面通论教程》：微分几何的里程碑式巨著</h2></header><div class=entry-content><p>系统介绍法国数学家加斯东·达布（Gaston Darboux）的四卷本《曲面通论教程》，阐述各卷内容与主要贡献</p></div><footer class=entry-footer><span title='2026-01-14 16:00:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>378 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 达布《曲面通论教程》：微分几何的里程碑式巨著" href=https://s-ai-unix.github.io/posts/2026-01-14-darboux-theory-of-surfaces/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/ai-neural-network.jpg alt=抽象的神经网络图案></figure><header class=entry-header><h2 class=entry-hint-parent>大语言模型：为什么AI能这么快、这么聪明地回答问题</h2></header><div class=entry-content><p>引言：对话的奇迹 你有没有试过和ChatGPT、Claude、或者国内的文心一言、通义千问对话？当你问它：“帮我写一首关于春天的诗”，或者"解释一下量子力学是什么"，它几乎在几秒钟内就能给出非常棒的回答。
有时候你甚至会想：它怎么这么快？它是不是有脑子？它是不是真的"理解"我在说什么？
答案可能出乎你的意料：大语言模型其实在做一件非常简单的事情——但它把这件简单的事情做到了极致。
今天，我们就来揭开这个"魔术"的面纱。
核心思想：预测下一个词 大语言模型（Large Language Model，简称LLM）的本质，可以用一句话概括：
它做的事情就是：给定一段话，预测下一个词最可能是什么。
听起来是不是太简单了？别急，让我们看个例子。
一个简单的游戏 假设我给你这句话的前半部分：
"今天天气真____" 你会怎么填空？
你可能会想到：“好”、“糟糕”、“热”、“冷”、“适合出门”……这些词都是有可能的。
再换个句子：
"我要去超市买_____" 你会猜：苹果、牛奶、面包、蔬菜、日用品……
再换个：
"中国位于_____" 这个答案就很明确了：亚洲、东亚。
你看，人类也在不停地做"预测下一个词"这件事。因为我们读过很多书、说过很多话，所以当我们听到半句话时，脑子里会自动出现最可能的后续。
从简单到复杂 大语言模型就是把这个"填空游戏"玩到了极致。
它读过几百万本书、几十亿篇文章、数万亿个句子。所以当你输入一段话，它能极其精准地预测下一个词。
关键点1：它不是在"思考"，而是在"计算概率"
比如你问：“什么是量子力学？”
它会计算：在"什么是量子力学？“这句话后面，最可能出现的词语是什么？
它会依次生成：“量子力学是一个____"（可能填：“理论”、“学科”、“概念”）→“理论，它描述____"（可能填：“粒子”、“微观世界”、“能量”）→……一层一层地，就生成了完整的回答。
关键点2：它不是一个词一个词地"想"出来的，而是一次性计算所有可能性
就像天气预报一样，气象台不会"猜"明天会不会下雨，而是根据大量数据"计算"出下雨的概率。大语言模型也是这样：它不是在"想"下一个词是什么，而是在"计算"所有可能的下一个词的概率。
这就是为什么它能这么快——因为这是数学计算，不是思考。
数据：从海量文本中学习 你可能会问：它凭什么知道"什么是量子力学"该怎么回答？
答案很简单：因为它"读"过关于量子力学的书。
读了多少书？ GPT-3（一个著名的大语言模型）的训练数据包含：
几千本书 几百万篇维基百科文章 几十亿个网页 几百万篇学术论文 大量的代码、对话、论坛帖子 总计大约5000亿个单词。
这是什么概念？假设一个人一生能读5000本书，每本书平均10万字，那就是5000 × 10万 = 5亿个词。GPT-3读的内容是一个人1000辈子才能读完的。
学到了什么？ 从这些海量文本中，它学到了：
语言规律：什么是正确的语法、什么是通顺的表达 世界知识：天为什么是蓝的、苹果是什么、历史事件怎么发生的 逻辑关系：因果关系、时间顺序、对比关系 常识推理：水往下流、太阳从东边升起、人类需要喝水 专业领域：数学、物理、编程、医学、法律…… 类比一下：这就像一个从小读遍图书馆所有书、记性特别好、理解能力超强的人。当你在对话中提到某个话题时，它能瞬间调动相关的知识来回答。
神经网络：像大脑一样的结构 你可能会想：它怎么"记住"这么多东西？
这要归功于神经网络。
什么叫"神经网络”？ 神经网络是一种模仿人脑结构的数学模型。
人脑有约860亿个神经元，这些神经元之间有无数个连接。当我们学习时，神经元之间的连接会"变强"或"变弱”，从而存储信息。
神经网络也是类似的：
它有很多"人工神经元”（叫作"节点"） 这些神经元之间有无数个"连接"（每个连接都有一个"权重"） 当它学习时，这些"权重"会不断调整 参数：知识的存储形式 大语言模型有几千亿个参数（parameters）。
“参数"是什么？你可以把它想象成"记忆单元"或"知识存储点”。
...</p></div><footer class=entry-footer><span title='2026-01-14 08:50:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>284 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 大语言模型：为什么AI能这么快、这么聪明地回答问题" href=https://s-ai-unix.github.io/posts/2026-01-14-llm-principle-for-students/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/wisconsin-geese-4602386.jpg alt=抽象的几何图案></figure><header class=entry-header><h2 class=entry-hint-parent>梯度、梯度下降与反向传播：从最优化到深度学习的数学引擎</h2></header><div class=entry-content><p>引言：从山路说起 想象你是一名登山者，被困在浓雾笼罩的山坡上，四周一片白茫茫。你手里只有一个指南针，它指向的似乎是你所在位置海拔下降最快的方向。这是你最希望知道的：该往哪个方向迈出第一步，才能尽快走出这座山？
这就是梯度下降算法最直观的物理类比。你所在的位置，是一个函数在某点的值；你想要的，是找到函数的最小值（山谷的最低点）；而那个指南针，就是梯度——告诉你哪个方向上升最快的向量。
这个看似简单的思想，却成为了现代人工智能的数学引擎。从AlphaGo击败李世石，到ChatGPT生成流畅的文字，再到自动驾驶汽车的感知系统，背后都依赖着梯度、梯度下降和反向传播这三个核心概念的精密协作。
但在深入这些概念之前，我们需要先理解一个更基础的数学对象：梯度。
梯度：地形的最陡方向 历史背景：从Hamilton到向量微积分 梯度的概念并非一蹴而就。它的起源可以追溯到19世纪中叶，那个数学物理大爆发的时代。
1843年，爱尔兰数学家William Rowan Hamilton（哈密顿）在研究四元数时，引入了一个算子符号$\nabla$，他称之为"nabla"（源自希腊语，意为一种竖琴）。这个倒三角符号后来成为了梯度、散度和旋度的统一表示。
1850年代，苏格兰数学家James Clerk Maxwell（麦克斯韦）进一步发展了向量微积分理论，他将$\nabla$算子应用于不同的运算：$\nabla \phi$表示梯度，$\nabla \cdot \mathbf{F}$表示散度，$\nabla \times \mathbf{F}$表示旋度。这三大运算构成了现代电磁学理论的数学语言。
更早之前，法国数学家Augustin-Louis Cauchy（柯西）在1847年就提出了梯度下降算法的雏形，这是最古老的优化算法之一。
数学定义：偏导数的向量 给定一个多元标量函数 $f: \mathbb{R}^n \rightarrow \mathbb{R}$，它的梯度 $\nabla f$（读作"del f"或"grad f"）定义为：
$$ \nabla f = \left(\frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2}, \ldots, \frac{\partial f}{\partial x_n}\right)^T $$
这是一个向量，每个分量是函数对相应变量的偏导数。
具体计算示例 考虑一个简单的二次函数：$f(x, y) = x^2 + 2y^2 - 4x - 8y + 17$
计算梯度：
$$ \frac{\partial f}{\partial x} = 2x - 4, \quad \frac{\partial f}{\partial y} = 4y - 8 $$
...</p></div><footer class=entry-footer><span title='2026-01-14 08:34:44 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>2040 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 梯度、梯度下降与反向传播：从最优化到深度学习的数学引擎" href=https://s-ai-unix.github.io/posts/2026-01-14-gradient-descent-backpropagation-overview/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1620712943543-bcc4688e7485.jpg alt=神经网络连接></figure><header class=entry-header><h2 class=entry-hint-parent>基于神经网络的深度学习算法：从感知机到Transformer的完整指南</h2></header><div class=entry-content><p>引言：从生物启发到智能革命 1943年，Warren McCulloch和Walter Pitts提出了第一个神经元数学模型。他们用一个简单的数学公式模拟了生物神经元的工作方式：接收输入、加权求和、激活输出。这个看似简单的想法，却孕育了后来改变世界的人工智能技术。
1958年，Frank Rosenblatt发明了感知机（Perceptron），这是第一个可以学习的神经网络。但1969年，Minsky和Papert在《Perceptrons》一书中证明了单层感知机无法解决异或（XOR）问题，这个致命缺陷导致了神经网络研究的第一次寒冬。
1986年，David Rumelhart、Geoffrey Hinton和Ronald Williams重新发现了反向传播算法，解决了多层网络的训练问题。神经网络迎来了短暂的春天。
但在90年代到2000年代初，支持向量机（SVM）等传统机器学习算法统治了学术界。神经网络因为数据量不足、计算能力有限、缺乏有效的训练技巧，再次陷入沉寂。
2012年，ImageNet竞赛上，Hinton的学生Alex Krizhevsky使用深度卷积神经网络AlexNet，以压倒性优势击败了传统方法，分类错误率从26%降低到15.3%。这一年，深度学习时代正式开启。
从此，深度学习以惊人的速度发展：2014年的VGG、GoogLeNet，2015年的ResNet解决深度退化问题，2017年的Transformer彻底改变自然语言处理，2022年的ChatGPT让全世界见识到大模型的力量。
本文将从数学原理出发，系统讲解深度学习的核心算法：从基础神经网络到卷积神经网络（CNN），从循环神经网络（RNN）到Transformer，最后探讨未来发展趋势。
第一章：神经网络的数学基础 1.1 单神经元：感知机的数学模型 1.1.1 前向传播 感知机是最基础的神经网络单元，模拟生物神经元的工作原理。给定输入向量 $x \in \mathbb{R}^d$，权重向量 $w \in \mathbb{R}^d$，偏置 $b \in \mathbb{R}$：
$$z = w^Tx + b = \sum_{i=1}^d w_i x_i + b$$
激活函数 $\sigma(z)$ 决定神经元的输出：
$$a = \sigma(z)$$
1.1.2 常用激活函数 Sigmoid函数： $$\sigma(z) = \frac{1}{1 + e^{-z}}$$
导数： $$\sigma’(z) = \sigma(z)(1 - \sigma(z))$$
性质：
输出范围：$(0, 1)$ S型曲线，可微 缺点：梯度消失（$| \sigma’(z) | \leq 0.25$），输出不以零为中心 Tanh函数： $$\tanh(z) = \frac{e^z - e^{-z}}{e^z + e^{-z}}$$
...</p></div><footer class=entry-footer><span title='2026-01-14 08:30:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>2188 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 基于神经网络的深度学习算法：从感知机到Transformer的完整指南" href=https://s-ai-unix.github.io/posts/2026-01-14-deep-learning-algorithms-comprehensive-guide/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://s-ai-unix.github.io/posts/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://s-ai-unix.github.io/posts/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://s-ai-unix.github.io/>s-ai-unix's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script></body></html>