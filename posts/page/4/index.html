<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | s-ai-unix's Blog</title><meta name=keywords content><meta name=description content="Posts - s-ai-unix's Blog"><meta name=author content="s-ai-unix"><link rel=canonical href=https://s-ai-unix.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.0833aff7e1cf567ecfb9755701ee95a80535f671e2e1a0a770c9bc20a0a7b5bb.css integrity="sha256-CDOv9+HPVn7PuXVXAe6VqAU19nHi4aCncMm8IKCntbs=" rel="preload stylesheet" as=style><link rel=icon href=https://s-ai-unix.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s-ai-unix.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s-ai-unix.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s-ai-unix.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s-ai-unix.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://s-ai-unix.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://s-ai-unix.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://s-ai-unix.github.io/posts/"><meta property="og:site_name" content="s-ai-unix's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://s-ai-unix.github.io/posts/"}]}</script><link rel=stylesheet href=https://s-ai-unix.github.io/css/classical-quote.css></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://s-ai-unix.github.io/ accesskey=h title="s-ai-unix's Blog (Alt + H)">s-ai-unix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s-ai-unix.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://s-ai-unix.github.io/posts/ title="📚 文章"><span class=active>📚 文章</span></a></li><li><a href=https://s-ai-unix.github.io/archives/ title="📁 归档"><span>📁 归档</span></a></li><li><a href=https://s-ai-unix.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://s-ai-unix.github.io/search/ title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://s-ai-unix.github.io/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://s-ai-unix.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/iso-8800-ai-safety.jpg alt=AI安全网络示意图></figure><header class=entry-header><h2 class=entry-hint-parent>ISO/PAS 8800:2024 道路车辆人工智能安全工程——从确定性到概率性的范式转移</h2></header><div class=entry-content><p>引言：确定性基石的动摇与重构 本文仅代表本人以及所使用的AI工具的观点， 不代表任何公司或者机构实体的意见！
在汽车工业百年的发展历程中，安全工程的基石始终建立在确定性逻辑之上。传统的 ISO 26262 功能安全标准，其核心哲学是"防错"——通过严格的流程控制和硬件冗余，防止电子电气系统发生非预期的故障。这种思想在数学上对应着清晰的布尔代数：系统要么正常（$x = 1$），要么失效（$x = 0$），边界分明。
然而，随着人工智能（AI），特别是深度学习技术在自动驾驶感知、预测及决策模块中的深度渗透，这一确定性基石遭遇了前所未有的冲击。AI 系统的行为不再完全由代码行数决定，而是由数据分布、模型架构及训练过程中的随机性共同涌现而成。以神经网络为例，其输出可以表示为：
$$ y = f(x; \theta) = \sigma_L(W_L \cdot \sigma_{L-1}(W_{L-1} \cdot \ldots \cdot \sigma_1(W_1 \cdot x + b_1) \ldots) + b_L) $$
其中 $\theta = {W_1, b_1, \ldots, W_L, b_L}$ 是通过训练过程优化的参数。这种"黑盒"特性与概率性输出，使得传统的安全保障体系面临巨大的逻辑真空。
ISO/PAS 8800:2024《道路车辆——安全与人工智能》 的发布，标志着汽车安全工程正式进入了"数据定义安全“的新纪元。这不仅仅是一份新的技术规范，它是对现有安全方法论的一次系统性重构：它不再试图将 AI 强行塞入确定性的框架，而是承认 AI 的不确定性，并提供了一套全新的数学与工程语言来量化、管理和控制这种不确定性。
本文将从数学原理出发，系统性地解读 ISO 8800 的核心概念，并通过实战案例，展示如何在不确定的 AI 世界中构建可信的安全系统。
第一章：标准定位——三大安全支柱的逻辑互补 1.1 安全体系的演进：从单点防御到立体防护 理解 ISO 8800 的首要任务，是厘清其在现有安全标准体系中的生态位。现代汽车安全体系正演变为由 ISO 26262、ISO 21448 和 ISO 8800 共同支撑的三维架构。这三大标准并非简单的并列关系，而是形成了一个严密的逻辑闭环：
...</p></div><footer class=entry-footer><span title='2026-01-20 21:10:00 +0800 CST'>January 20, 2026</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>1710 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to ISO/PAS 8800:2024 道路车辆人工智能安全工程——从确定性到概率性的范式转移" href=https://s-ai-unix.github.io/posts/2026-01-20-iso-8800-comprehensive-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/fourier-series.jpg alt=傅里叶级数的波形叠加></figure><header class=entry-header><h2 class=entry-hint-parent>傅里叶级数：用正弦波重构世界</h2></header><div class=entry-content><p>引言：1822年的一个大胆断言 想象你站在19世纪初的巴黎，一位头发花白的法国数学家约瑟夫·傅里叶（Joseph Fourier）刚刚完成了一部巨著《热的解析理论》。在这本书中，他提出了一个在当时看来近乎荒谬的断言：
任何周期函数，无论多么复杂，都可以表示为简单的正弦和余弦函数的无穷级数。
这个想法在当时激起了巨大的争议。著名的数学家拉格朗日（Lagrange）甚至认为这是不可能的。但傅里叶坚持自己的观点，并用这个方法成功解决了困扰数学家多年的热传导方程。
为什么这个想法如此重要？因为正弦函数 $\sin(x)$ 和余弦函数 $\cos(x)$ 是我们最理解、最容易处理的函数。如果任何复杂函数都能分解成这些简单函数的叠加，那么我们就可以把复杂问题转化为简单问题来解决。
今天，从你的手机音乐播放器到医学影像设备，从JPEG图像压缩到量子力学计算，傅里叶的思想无处不在。让我们从历史的长河出发，逐步理解这个改变世界的数学工具。
第一章：历史演变——从音乐到数学的千年旅程 1.1 古希腊的发现：音乐是数学 公元前6世纪，毕达哥拉斯（Pythagoras）做了一个著名的实验。他拨动不同长度的琴弦，发现：
当弦长比例为 $2:1$ 时，听起来是八度音 当弦长比例为 $3:2$ 时，听起来是五度音 当弦长比例为 $4:3$ 时，听起来是四度音 这让他意识到：音乐的和谐可以用数学比例来描述。这是人类第一次认识到声音的"频率"概念——琴弦振动越快，音调越高。
更神奇的是，古希腊人还发现：任何复杂的声音都可以分解为多个"纯音"（正弦波）的组合。这其实就是傅里叶级数思想的萌芽！
1.2 18世纪的挑战：弦振动的谜题 时间来到18世纪，物理学家们对弦的振动产生了浓厚兴趣。小提琴、钢琴的弦是如何振动的？如何从数学上描述这种振动？
1747年，达朗贝尔（d’Alembert）得到了弦振动方程： $$ \frac{\partial^2 y}{\partial t^2} = c^2 \frac{\partial^2 y}{\partial x^2} $$
但这个方程的解是什么？欧拉（Euler）和伯努利（Bernoulli）分别给出了不同的解答。伯努利提出：弦的任何运动都可以表示为"固有模式"（正弦波）的叠加。
$$ y(x,t) = \sum_{n=1}^{\infty} A_n \sin\left(\frac{n\pi x}{L}\right)\cos\left(\frac{n\pi c t}{L}\right) $$
但拉格朗日质疑：任意函数真的都能这样分解吗？ 这个争论持续了半个多世纪，直到傅里叶给出答案。
1.3 1807年：傅里叶的革命性论文 1807年，傅里叶向法国科学院提交了一篇关于热传导的论文。在研究金属棒中热量如何传播时，他遇到了一个难题：如何表示初始温度分布？
傅里叶提出：初始温度函数 $f(x)$ 可以表示为
$$ f(x) = a_0 + \sum_{n=1}^{\infty} a_n \cos\left(\frac{n\pi x}{L}\right) + b_n \sin\left(\frac{n\pi x}{L}\right) $$
...</p></div><footer class=entry-footer><span title='2026-01-20 21:00:00 +0800 CST'>January 20, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1285 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 傅里叶级数：用正弦波重构世界" href=https://s-ai-unix.github.io/posts/2026-01-20-fourier-series/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/dirac-equation-cover.jpg alt=狄拉克方程的数学之美></figure><header class=entry-header><h2 class=entry-hint-parent>狄拉克方程：当量子遇见相对论</h2></header><div class=entry-content><p>引言：1928年的秋天 1928年的剑桥，一位沉默寡言的年轻人正在办公室里来回踱步。26岁的保罗·狄拉克（Paul Dirac）面临着一个困扰整个物理学界的问题：如何将量子力学与狭义相对论统一起来？
当时的物理学界就像一个分裂的家庭。一边是薛定谔方程（Schrödinger equation），它成功地描述了原子中的电子行为，但只在低速情况下有效；另一边是爱因斯坦的狭义相对论，它告诉我们当速度接近光速时会发生什么。问题是——这两者似乎水火不容。
让我们从这个困境出发，一步步理解狄拉克是如何找到答案的。
第一部分：问题的本质 1.1 薛定谔方程的成功与局限 1926年，奥地利物理学家埃尔温·薛定谔提出了著名的波动方程：
$$ i\hbar\frac{\partial}{\partial t}\psi(\mathbf{r},t) = \hat{H}\psi(\mathbf{r},t) $$
对于自由粒子（没有外力作用），哈密顿量是：
$$ \hat{H} = \frac{\hat{\mathbf{p}}^2}{2m} = -\frac{\hbar^2}{2m}\nabla^2 $$
这个方程在描述原子中的电子时非常成功，它精确地预言了氢原子的能级。但仔细观察这个方程，你会发现一个根本性的问题：
时间导数是一阶的（$\frac{\partial}{\partial t}$），但空间导数是二阶的（$\nabla^2 = \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2} + \frac{\partial^2}{\partial z^2}$）。
这种不对称性意味着什么呢？意味着这个方程在洛伦兹变换下不会保持不变——换句话说，它不符合狭义相对论。
1.2 能量-动量关系的启发 在狭义相对论中，自由粒子的能量和动量满足：
$$ E^2 = p^2c^2 + m^2c^4 $$
这就是著名的质能方程。在低速情况下（$p \ll mc$），我们可以展开：
$$ E = mc^2\sqrt{1 + \frac{p^2}{m^2c^2}} \approx mc^2 + \frac{p^2}{2m} $$
减去静止能量 $mc^2$，我们就得到经典的动能表达式 $\frac{p^2}{2m}$——这正是薛定谔方程中的哈密顿量！
所以薛定谔方程实际上只是相对论能量公式在低速情况下的近似。那么，我们能否直接使用完整的相对论能量-动量关系来构造波动方程呢？
1.3 克莱因-戈尔登方程的尝试 最直接的尝试是将量子力学中的能量和动量算符代入相对论能量-动量关系：
$$ E \rightarrow i\hbar\frac{\partial}{\partial t}, \quad \mathbf{p} \rightarrow -i\hbar\nabla $$
...</p></div><footer class=entry-footer><span title='2026-01-20 20:00:00 +0800 CST'>January 20, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>831 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 狄拉克方程：当量子遇见相对论" href=https://s-ai-unix.github.io/posts/2026-01-20-dirac-equation-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/ai-risk-management.jpg alt=AI驱动的行业风险管理对比></figure><header class=entry-header><h2 class=entry-hint-parent>AI驱动行业风险管理：汽车、航空、医疗行业的深度对比研究</h2></header><div class=entry-content><p>引言 人工智能技术正在深刻改变汽车、航空和医疗三大高风险行业的运作模式。这三个行业有一个共同特点：系统失效可能导致人员伤亡、重大财产损失或严重社会后果。随着AI技术在感知、决策和控制领域的广泛应用，如何有效识别、评估和管理AI带来的新型风险，已成为行业监管机构、制造商和医疗机构共同面临的重大课题。
本文将从风险分类框架、标准体系、实践案例、管理方法和进展挑战五个维度，对汽车、航空、医疗三个行业的AI风险分析与风险管理进行系统性对比研究，旨在为读者提供全面的方法论解读和丰富的实践参考。
第一章 三大行业AI风险分类框架对比 graph TB subgraph 汽车行业风险分类 Auto[汽车AI风险] --> Auto1[功能安全
ISO 26262
系统性故障] Auto --> Auto2[SOTIF
ISO 21448
功能不足] Auto --> Auto3[网络安全
ISO/SAE 21434
恶意攻击] end subgraph 航空工业风险分类 Aero[航空AI风险] --> Aero1[DAL A
灾难级] Aero --> Aero2[DAL B
危险级] Aero --> Aero3[DAL C
重大级] Aero --> Aero4[DAL D
轻微级] Aero --> Aero5[DAL E
无影响] end subgraph 医疗行业风险分类 Medi[医疗AI风险] --> Medi1[患者安全
诊断错误] Medi --> Medi2[诊断准确性
模型性能] Medi --> Medi3[数据隐私
HIPAA合规] end style Auto fill:#007AFF,stroke:#007AFF,stroke-width:3px,color:#ffffff style Aero fill:#FF9500,stroke:#FF9500,stroke-width:3px,color:#ffffff style Medi fill:#AF52DE,stroke:#AF52DE,stroke-width:3px,color:#ffffff 1.1 汽车行业风险分类体系 汽车行业的AI风险分类建立在功能安全（Functional Safety）、预期功能安全（SOTIF）和网络安全（Cybersecurity）三大支柱之上，形成了独特的"三层防护"体系。
...</p></div><footer class=entry-footer><span title='2026-01-16 10:00:00 +0800 CST'>January 16, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>781 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to AI驱动行业风险管理：汽车、航空、医疗行业的深度对比研究" href=https://s-ai-unix.github.io/posts/2026-01-16-ai-risk-management-comparison/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/automotive-risk-analysis.jpg alt=汽车网络安全威胁分析概念图></figure><header class=entry-header><h2 class=entry-hint-parent>汽车行业 TARA 分析综述：方法论与实践深度解析</h2></header><div class=entry-content><p>引言：网络安全威胁下的汽车安全新范式 随着汽车产业向智能化、网联化、电动化快速演进，车辆已从单纯的机械交通工具转变为高度复杂的移动计算平台。车载电子电气架构的深度融合、远程OTA升级功能的普及、V2X车路协同技术的应用，使得汽车面临着前所未有的网络安全威胁。传统的汽车安全设计理念已无法有效应对现代网络攻击手段的威胁，在此背景下，威胁分析与风险评估（Threat Analysis and Risk Assessment，简称TARA）方法论应运而生，成为汽车网络安全工程领域的核心方法论框架。
TARA分析不仅是ISO/SAE 21434《道路车辆网络安全工程》标准规定的强制性要求，更是汽车制造商和供应商识别、评估、缓解网络安全风险的系统化工程方法。通过科学的TARA分析流程，组织能够全面识别车辆系统面临的威胁场景，定量评估潜在风险等级，并据此制定针对性的安全控制措施，从而在产品全生命周期中有效管理网络安全风险。本文将深入解析TARA分析的方法论体系，结合丰富的行业实践案例，为读者呈现汽车网络安全风险评估的完整知识图谱。
第一章 TARA分析的理论基础与标准框架 1.1 汽车网络安全威胁的演进脉络 汽车网络安全威胁的发展历程与车辆电子化程度密切相关。在分布式电子电气架构时代，车辆主要通过CAN总线进行车内网络通信，攻击面相对有限，主要威胁来源于物理接触式攻击，如通过OBD-II诊断接口进行的攻击。随着域控制器架构的引入和车载以太网的应用，车辆具备了远程联网能力，攻击者可从云端服务器、手机APP、充电基础设施等多维度发起攻击，威胁态势呈现指数级恶化态势。
当前汽车行业面临的主要威胁类型包括：针对车载信息娱乐系统（IVI）的恶意软件注入与远程控制攻击；针对高级驾驶辅助系统（ADAS）的传感器欺骗与感知系统干扰；针对车联网云平台的API滥用与数据泄露；针对电动汽车充电基础设施的中间人攻击；针对V2X通信的虚假信息注入与拒绝服务攻击。这些威胁一旦被恶意利用，可能导致车辆被远程控制、用户隐私泄露、交通事故发生，甚至危害公共安全。
1.2 国际标准体系对TARA的规范化要求 ISO/SAE 21434标准是汽车网络安全领域的里程碑式文件，该标准于2021年正式发布，规定了道路车辆网络安全工程的全生命周期要求。在标准框架下，TARA分析被定位为网络安全风险管理的核心活动，贯穿于概念阶段、产品开发阶段及后开发阶段的全过程。标准明确要求组织应建立系统化的威胁分析方法，识别相关资产可能面临的威胁，并基于威胁可能性和影响严重性进行风险等级评定。
联合国世界车辆法规协调论坛（WP.29）发布的R155法规是另一个重要的法规框架，该法规规定了车辆制造商必须建立网络安全管理体系（CSMS），并对特定车型进行网络安全风险评估。R155法规明确要求制造商应识别并评估与车辆类型相关的网络安全风险，实施相应的风险缓解措施，并通过持续监控机制保持安全态势。值得注意的是，R155法规不仅适用于M类（乘用车）、N类（货车）车辆，还扩展至L类（摩托车）及其他特殊车辆类型。
1.3 TARA分析的核心价值定位 TARA分析的核心价值在于将模糊的"网络安全问题"转化为可量化、可管理、可追踪的工程问题。通过系统化的分析流程，组织能够获得以下关键产出：资产清单及其安全属性定义；威胁场景清单及攻击路径分析；风险等级评定结果及排序；安全需求规格及控制措施建议。这些产出直接指导后续的安全设计、验证确认活动，确保安全投入的精准性和有效性。
从系统工程角度而言，TARA分析体现了"安全左移"的先进理念。在产品概念阶段早期开展TARA分析，能够在架构设计阶段就嵌入安全考量，避免后期返工带来的巨大成本。同时，TARA分析也为安全测试提供了明确的测试目标和验收标准，形成了从风险识别到安全验证的完整闭环。
第二章 TARA分析方法论体系详解 flowchart TD Start([TARA分析开始]) --> P1[阶段一: 分析准备资产识别与边界定义] P1 --> P2[阶段二: 威胁建模攻击路径与攻击树分析] P2 --> P3[阶段三: 风险评估可能性与影响性评级] P3 --> P4[阶段四: 风险处置策略选择与控制措施设计] P4 --> End([输出网络安全需求]) style Start fill:#007AFF,stroke:#007AFF,stroke-width:3px,color:#ffffff style P1 fill:#5AC8FA,stroke:#007AFF,stroke-width:2px,color:#ffffff style P2 fill:#FF9500,stroke:#FF9500,stroke-width:2px,color:#ffffff style P3 fill:#AF52DE,stroke:#AF52DE,stroke-width:2px,color:#ffffff style P4 fill:#34C759,stroke:#34C759,stroke-width:2px,color:#ffffff style End fill:#30D158,stroke:#34C759,stroke-width:3px,color:#ffffff 2.1 分析准备阶段：资产识别与边界定义 TARA分析的第一步是明确分析范围和识别保护对象，这一阶段的工作质量直接决定后续分析的完整性和有效性。资产识别需要建立系统化的资产清单，该清单不仅包括物理资产（如ECU、传感器、执行器），还包括逻辑资产（如功能、服务、数据）以及抽象资产（如用户隐私、车辆安全功能完整性）。
...</p></div><footer class=entry-footer><span title='2026-01-16 09:09:00 +0800 CST'>January 16, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>408 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 汽车行业 TARA 分析综述：方法论与实践深度解析" href=https://s-ai-unix.github.io/posts/2026-01-16-tara-analysis/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/automotive-risk-analysis.jpg alt=汽车风险分析概念图></figure><header class=entry-header><h2 class=entry-hint-parent>汽车领域风险分析综述：从传统方法到AI时代的演进与标准体系</h2></header><div class=entry-content><p>汽车领域风险分析综述：从传统方法到AI时代的演进与标准体系 一、引言 1.1 汽车行业风险分析的重要性 当我们回顾汽车工业的百年发展历程，一个不可忽视的事实是：汽车已经从单纯的机械交通工具演变为高度复杂的电子电气与软件系统集成的智能终端。这一深刻变革不仅重塑了汽车的驾驶体验，更从根本上改变了我们思考汽车安全的方式。
现代汽车的电子电气系统代码量已经突破亿行大关，一辆高端车型的ECU数量可达百余个，涵盖发动机控制、制动系统、转向系统、ADAS高级驾驶辅助系统、车联网通信等关键功能域。这种前所未有的系统复杂度，使得传统的机械可靠性设计方法论面临严峻挑战。据行业统计，电子电气系统故障已成为现代汽车召回的首要原因，其比例在过去十年间持续攀升。
汽车安全从被动安全（碰撞后的生存保护）发展到主动安全（预防事故发生），再到今天的功能安全与预期功能安全，要求我们在车辆设计阶段就必须系统性地识别、评估和控制潜在风险。这不再是"发现问题、解决问题"的迭代思维，而是"预见问题、预防问题"的系统工程思维。
从法规层面看，全球主要汽车市场正在经历从推荐性标准到强制性法规的转变。欧盟UNECE R155法规要求车辆制造商必须建立网络安全管理系统并获得CSMS认证才能进入市场；R156法规则针对软件更新提出了SUMS认证要求。在中国，工信部发布的《关于加强智能网联汽车生产企业及产品准入管理的意见》同样将功能安全和数据安全作为产品准入的必要条件。这种监管趋势意味着，风险分析不再仅仅是工程实践的优化，更是市场准入的门槛。
与此同时，人工智能技术正以前所未有的速度渗透汽车领域。从基于深度学习的感知算法，到端到端的自动驾驶大模型，再到大语言赋能的智能座舱，AI正在重新定义汽车的"大脑"。然而，AI系统的风险特征与传统电子电气系统存在本质差异：模型的不可解释性、数据的依赖性、对抗样本的脆弱性、环境分布偏移的不确定性，这些新风险载体需要全新的分析方法论。
本文旨在系统梳理汽车领域风险分析的方法论体系，从传统的FMEA、FTA到现代的STPA，从功能安全的HARA到网络安全的TARA，从定性分析到定量评估，从单机系统到车云协同。我们将深入剖析每种方法的原理、步骤与案例，对比传统与AI风险分析的差异，并详细解读国际与欧盟主流标准体系，为读者构建完整的汽车风险分析知识图谱。
1.2 文章结构概览 本文采用"方法论-对比-标准-展望"的四段式结构，系统性地介绍汽车领域风险分析的完整体系。
在方法论部分，我们将深入探讨五种核心风险分析方法：FMEA失效模式与影响分析作为预防性质量工具的典型代表；FTA故障树分析作为演绎推理的经典方法；STPA系统理论过程分析作为复杂系统安全的新范式；HARA危害分析与风险评估作为ISO 26262功能安全的核心步骤；TARA威胁分析与风险评估作为ISO/SAE 21434网络安全工程的基础。每种方法都将从背景历史、核心原理、操作步骤、案例实践四个维度进行详尽阐述。
在对比分析部分，我们将从风险载体、评估方法、风险特点、可控性、防御策略五个维度，系统对比传统风险分析与AI风险分析的异同，揭示AI时代风险分析面临的独特挑战与应对策略。
在标准解读部分，我们将梳理IEC 61508、ISO 26262、ISO 21448、ASPICE、ISO/SAE 21434、UNECE R155/R156等主流标准的技术要点、等效关系与实施路径，帮助读者在复杂的标准丛林中找到清晰的主线。
在总结展望部分，我们将回顾方法论的演进脉络，分析未来发展趋势，并为不同应用场景提供方法选择建议。
二、传统风险分析方法论 2.1 FMEA——失效模式与影响分析 2.1.1 背景与历史 FMEA的故事始于20世纪60年代美国国家航空航天局（NASA）的阿波罗登月计划。在那个航天技术尚处于萌芽阶段的年代，太空探索的高风险性使得传统的"测试-发现问题-修改设计"的迭代模式代价过于高昂。工程师们需要一种能够在设计阶段就系统识别潜在失效模式的方法，这就是FMEA诞生的背景。
从NASA的军事航天领域起步，FMEA迅速扩展到核工业、化工、航空等高安全行业。1970年代，随着日本汽车工业的崛起，FMEA迎来了第二次发展高峰。丰田、日产等企业将FMEA与精益生产、质量圈等管理方法深度融合，形成了具有东方特色的持续改进文化。1980年代，FMEA被引入汽车行业，并在福特、通用、克莱斯勒等美国车企中得到广泛应用。
为了规范FMEA的实施方法，美国汽车工业行动小组（AIAG）与德国汽车工业协会（VDA）于2019年联合发布了AIAG-VDA FMEA标准，这是FMEA发展史上最重要的里程碑之一。该标准统一了美系与德系FMEA的术语、表格格式和评分方法，消除了跨国供应链中的沟通障碍。2024年，AIAG-VDA FMEA标准进行了新一轮更新，进一步强化了七步法结构、更强调了鲁棒性设计思想，并完善了对于自动驾驶等新兴技术的应用指南。
2.1.2 核心原理 FMEA本质上是一种预防性的可靠性分析工具，其核心思想是：在产品或系统投入生产使用之前，系统性地识别所有可能的失效模式，分析每种失效模式对系统功能的影响，并按照风险优先级排序，指导改进措施的制定与实施。
FMEA的三维评估模型是其技术核心。这一模型通过三个维度的量化评分，计算出风险优先序数（Risk Priority Number，RPN），作为失效模式优先级排序的依据：
严重度（Severity，S） 评估失效模式一旦发生，对系统功能、用户安全或法规符合性的影响程度。评分范围通常为1-10分，其中1分表示无影响，10分表示可能导致严重伤害或死亡的致命影响。在汽车行业，S值大于等于8的失效模式通常需要重点关注。
发生频率（Occurrence，O） 评估失效模式实际发生的可能性。评分范围同样为1-10分，其中1分表示失效几乎不可能发生，10分表示失效几乎必然发生。O值的评估需要结合历史数据、类似系统经验以及设计特性分析。
探测度（Detection，D） 评估在产品出厂前或失效发生前，通过测试、检查等手段发现失效模式的能力。评分范围为1-10分，其中1分表示失效肯定能被检测到，10分表示失效无法被检测到。D值越高，说明现有的检测手段越不充分。
RPN计算公式：$RPN = S \times O \times D$
graph LR subgraph RPN计算模型 S[严重度 S1-10分] --> RPN[RPN = S × O × D风险优先序数] O[发生频率 O1-10分] --> RPN D[探测度 D1-10分] --> RPN end RPN -->|1-1000分| RISK[风险等级评估] style S fill:#FF3B30,stroke:#FF3B30,stroke-width:2px,color:#ffffff style O fill:#FF9500,stroke:#FF9500,stroke-width:2px,color:#ffffff style D fill:#AF52DE,stroke:#AF52DE,stroke-width:2px,color:#ffffff style RPN fill:#007AFF,stroke:#007AFF,stroke-width:3px,color:#ffffff style RISK fill:#34C759,stroke:#34C759,stroke-width:2px,color:#ffffff RPN的取值范围为1-1000分。RPN越高，表示该失效模式的风险越大，需要优先采取措施降低风险。需要特别强调的是，RPN仅用于优先级排序，三个维度的权重并非总是相等，在特定行业或应用场景下，组织可能需要根据自身经验调整评估标准。
...</p></div><footer class=entry-footer><span title='2026-01-16 09:08:00 +0800 CST'>January 16, 2026</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>2072 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 汽车领域风险分析综述：从传统方法到AI时代的演进与标准体系" href=https://s-ai-unix.github.io/posts/2026-01-16-automotive-risk-analysis-overview/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/hara-automotive.jpg alt=汽车安全分析概念图></figure><header class=entry-header><h2 class=entry-hint-parent>汽车行业 HARA 分析综述：从理论到实践</h2></header><div class=entry-content><p>引言 想象一下这样的场景：一辆电动汽车正在高速公路上以 $100\text{ km/h}$ 的速度行驶，突然，电子节气门控制系统发生故障，导致车辆意外加速。驾驶员试图踩下刹车，但车辆却继续加速，最终酿成悲剧。这不是虚构的假设，而是真实发生过的汽车安全事故——2009 年丰田意外加速事件。
这个悲剧促使整个汽车行业重新思考安全工程的方法论。在这个过程中，危害分析与风险评估（Hazard Analysis and Risk Assessment，简称 HARA） 逐渐成为汽车功能安全的基石。HARA 不仅仅是一个技术流程，更是一种系统化的思维框架，帮助工程师在复杂的汽车系统中识别潜在风险，并制定相应的防护措施。
今天，我们就来深入探讨 HARA 的理论基础、发展历程以及在汽车行业的实际应用。
HARA 的理论基础 什么是 HARA？ HARA 是 ISO 26262 汽车功能安全标准中定义的核心流程，旨在系统性地识别由系统故障导致的危害事件，评估相关风险，并制定安全目标以避免不合理风险的发生。简单来说，HARA 回答了三个关键问题：
什么可能出错？（危害识别） 如果出错了，后果有多严重？（风险评估） 如何防止或缓解风险？（安全措施） HARA 是在整个汽车产品生命周期中实施的第一个主要任务，也是 ISO 26262 合规流程中的关键环节。它发生在概念设计阶段，为后续的系统架构设计、测试和验证奠定了基础。
ISO 26262 标准的诞生 要理解 HARA，我们必须先了解 ISO 26262 标准的诞生背景。
在汽车电子系统日益复杂的背景下，国际电工委员会（IEC）制定的 IEC 61508 标准为功能安全提供了通用的方法论。然而，汽车行业有其特殊性：大规模生产、成本敏感、高度分布式系统架构等。因此，在 IEC 61508 的基础上，汽车行业专门制定了 ISO 26262 标准，即 “道路车辆功能安全” 标准（Road vehicles – Functional safety）。
ISO 26262 首次于 2011 年 发布，涵盖了汽车电气/电子系统的整个安全生命周期，从概念阶段、系统设计、硬件设计、软件设计，到生产、运行、服务，直到退役。HARA 在 ISO 26262 第 3 部分（概念阶段）中被正式定义，是功能安全工程活动的起点。
...</p></div><footer class=entry-footer><span title='2026-01-16 09:06:00 +0800 CST'>January 16, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>942 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 汽车行业 HARA 分析综述：从理论到实践" href=https://s-ai-unix.github.io/posts/2026-01-16-hara-automotive-analysis/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/neural-network-evolution.jpg alt=抽象神经网络连接图></figure><header class=entry-header><h2 class=entry-hint-parent>神经网络算法演进：从感知机到 Transformer 的七十年征程</h2></header><div class=entry-content><p>引言：智慧的萌芽 想象一下 1957 年的夏天，康奈尔大学的弗兰克·罗森布拉特（Frank Rosenblatt）在实验室里调试着一台早期的电子计算机。他正在实现一个大胆的想法——能否用数学模型模拟人类的大脑神经元？
这个想法在当时看起来近乎荒谬。人类大脑由数百亿个神经元组成，神经元之间通过突触连接，形成了一个令人眩晕的复杂网络。但罗森布拉特相信，如果我们能理解单个神经元的基本工作原理，就能一步步构建出能够学习的智能系统。
那时的学术界对机器学习充满怀疑。“机器怎么可能思考？"——这是当时的主流声音。但罗森布拉特和他的同道们坚持了下来，用数学公式编织着最初的神经之梦。
今天，当我们面对能够写出论文、创作艺术、驾驶汽车的深度学习系统时，很容易忘记这一切都始于一个简单的线性分类器。让我们放慢脚步，回顾这七十年的征程，感受数学的力量与思想的演进。
一、感知机：神经网络的起点（1957） 时间：1957 年 - 弗兰克·罗森布拉特 (Frank Rosenblatt)
历史的起点 1957 年，弗兰克·罗森布拉特在康奈尔航空实验室发明了感知机（Perceptron）。这是第一个能够学习的神经网络模型，被誉为"机器学习的开端”。
1962 年的《纽约客》杂志甚至专门报道了这个发明，称它为"会思考的机器"。那时的媒体兴奋中充满了对人工智能未来的无限遐想。
数学形式 单个神经元的工作原理 一个感知机神经元接收 $d$ 维输入 $\mathbf{x} = (x_1, x_2, \ldots, x_d)^T$，每个输入对应一个权重 $w_i$，还有一个偏置 $b$。
神经元的输出是输入的加权和，然后通过激活函数：
$$ y = f(z) = f\left(\sum_{i=1}^{d} w_i x_i + b\right) = f(w^T x + b) $$
其中 $z = \mathbf{w}^T \mathbf{x} + b$ 是净输入（net input）。
激活函数 在最初的感知机中，激活函数是符号函数（sign function）：
$$ f(z) = \begin{cases} 1 & \text{if } z \geq 0 \ -1 & \text{if } z &lt; 0 \end{cases} $$
...</p></div><footer class=entry-footer><span title='2026-01-15 23:55:00 +0800 CST'>January 15, 2026</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>1578 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 神经网络算法演进：从感知机到 Transformer 的七十年征程" href=https://s-ai-unix.github.io/posts/2026-01-15-neural-network-evolution/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/ml-algorithms-legacy.jpg alt=抽象几何图案></figure><header class=entry-header><h2 class=entry-hint-parent>深度学习前夜：十大传统机器学习算法的历史与数学之美</h2></header><div class=entry-content><p>引言：黄金时代 想象一下 2006 年的秋天，深度学习尚未兴起。那时的机器学习领域正经历着一场静悄悄的革命。统计学习方法、核方法、集成学习层出不穷，数学家们用优雅的公式编织着智能的梦想。
那时，人们相信：只要数据足够、特征工程足够细致，我们就能教机器做任何事。这种信念催生了一批经典算法——它们或许不如今天的深度神经网络那样炫目，但每一款都凝聚着数学家的智慧，每一步推导都闪耀着逻辑的光辉。
今天，我们回顾这段黄金时代，讲述十个改变了世界的传统机器学习算法的故事。但这次，让我们放慢脚步，亲手推导每一步，感受数学的力量。
一、线性回归：回归分析的鼻祖 时间：1795 年 - 阿德里安-马里·勒让德 (Adrien-Marie Legendre)
历史的偶然 1795 年，法国天文学家勒让德正在为一个问题头疼：如何用最简单的方法拟合行星轨道数据？他需要找到一条直线，让所有数据点到这条直线的距离平方和最小。
这就是最小二乘法的诞生。
推导过程 让我们从最简单的情况开始。假设我们有 $n$ 个数据点 $(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)$，想要找到一条直线 $y = w_0 + w_1 x$ 来拟合这些数据。
第一步：定义误差
对于每个数据点 $(x_i, y_i)$，我们的预测值是 $\hat{y}_i = w_0 + w_1 x_i$，误差就是观测值和预测值的差：
$$ e_i = y_i - \hat{y}_i = y_i - (w_0 + w_1 x_i) $$
第二步：定义损失函数
为什么是平方误差？勒让德选择平方误差有几个好处：
非负：平方后总是非负 可导：处处光滑，便于优化 凸函数：只有一个最小值 损失函数定义为：
$$ L(w_0, w_1) = \sum_{i=1}^{n} e_i^2 = \sum_{i=1}^{n} [y_i - (w_0 + w_1 x_i)]^2 $$
...</p></div><footer class=entry-footer><span title='2026-01-15 22:30:00 +0800 CST'>January 15, 2026</span>&nbsp;·&nbsp;<span>17 min</span>&nbsp;·&nbsp;<span>3481 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 深度学习前夜：十大传统机器学习算法的历史与数学之美" href=https://s-ai-unix.github.io/posts/2026-01-15-traditional-ml-algorithms/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/vector-calculus-geometry.jpg alt=向量场的几何直觉></figure><header class=entry-header><h2 class=entry-hint-parent>微积分的三大公式：格林、高斯与斯托克斯定理的统一视角</h2></header><div class=entry-content><p>想象这样一个场景：你站在河边，看着水流在河道中蜿蜒前行。河水的流速在不同的位置和方向上都不同——有的地方湍急，有的地方平缓。如果你想知道流过一个闭合河岸的净水量，你会怎么做？
直觉告诉你：可以沿着河岸计算流进和流出的差异。但数学告诉你，这等价于计算河岸所包围区域内水源的"产生"或"消失"。这就是格林公式的物理直观。
从二维的河流到三维的空气流动，从平面上的旋转到空间中的曲面，微积分的三大公式——格林公式、高斯公式、斯托克斯公式——都在讲述同一个深刻的思想：边界上的积分与内部的积分可以通过某种微分运算相互转化。
一、预备知识：向量微积分的语言 在深入三大公式之前，让我们先回顾一些必要的基础概念。
1.1 向量场 向量场 $\mathbf{F} : \mathbb{R}^n \to \mathbb{R}^n$ 是一个函数，它给空间中的每个点赋予一个向量。在二维情况下，我们通常写成：
$$ \mathbf{F}(x, y) = P(x, y)\mathbf{i} + Q(x, y)\mathbf{j} $$
物理中常见的向量场包括：
流体的速度场 电磁场的电场或磁场 引力场 1.2 梯度、散度与旋度 假设 $f(x, y, z)$ 是一个标量函数，$\mathbf{F} = (P, Q, R)$ 是一个向量场，我们有三个关键的微分算子：
梯度：标量场的梯度是一个向量，指向函数增长最快的方向。
$$ \nabla f = \left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z}\right) $$
散度：向量场的散度是一个标量，衡量向量场在某点的"发散"程度。
$$ \nabla \cdot \mathbf{F} = \frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z} $$
...</p></div><footer class=entry-footer><span title='2026-01-14 22:14:36 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1167 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 微积分的三大公式：格林、高斯与斯托克斯定理的统一视角" href=https://s-ai-unix.github.io/posts/2026-01-14-greens-gauss-stokes-formulas-guide/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://s-ai-unix.github.io/posts/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://s-ai-unix.github.io/posts/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://s-ai-unix.github.io/>s-ai-unix's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var n,t=e.innerHTML,s=!1;for(t.indexOf("<em>")!==-1&&(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("</em>")!==-1&&(n=t.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),n=n.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("<em>$")!==-1&&(n=t.replace(/<em>\$/g,"$"),n!==t&&(t=n,s=!0)),t.indexOf("</em>$")!==-1&&(n=t.replace(/<\/em>\$/g,"$"),n!==t&&(t=n,s=!0));t.indexOf("<em>")!==-1&&t.indexOf("</em>")!==-1;){if(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n===t)break;t=n,s=!0}t.indexOf("_{")!==-1&&(n=t.replace(/_{/g,"_{"),n!==t&&(t=n,s=!0)),t.indexOf("}_")!==-1&&(n=t.replace(/}_/g,"}"),n!==t&&(t=n,s=!0)),t.indexOf("\\\\")!==-1&&(n=t.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),n!==t&&(t=n,s=!0)),s&&(e.innerHTML=t)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var n,t=e.innerHTML,s=!1;for(t.indexOf("<em>")!==-1&&(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("</em>")!==-1&&(n=t.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),n=n.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("<em>$")!==-1&&(n=t.replace(/<em>\$/g,"$"),n!==t&&(t=n,s=!0)),t.indexOf("</em>$")!==-1&&(n=t.replace(/<\/em>\$/g,"$"),n!==t&&(t=n,s=!0));t.indexOf("<em>")!==-1&&t.indexOf("</em>")!==-1;){if(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n===t)break;t=n,s=!0}t.indexOf("_{")!==-1&&(n=t.replace(/_{/g,"_{"),n!==t&&(t=n,s=!0)),t.indexOf("}_")!==-1&&(n=t.replace(/}_/g,"}"),n!==t&&(t=n,s=!0)),t.indexOf("\\\\")!==-1&&(n=t.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),n!==t&&(t=n,s=!0)),s&&(e.innerHTML=t)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script></body></html>