<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | s-ai-unix's Blog</title><meta name=keywords content><meta name=description content="Posts - s-ai-unix's Blog"><meta name=author content="s-ai-unix"><link rel=canonical href=https://s-ai-unix.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.0833aff7e1cf567ecfb9755701ee95a80535f671e2e1a0a770c9bc20a0a7b5bb.css integrity="sha256-CDOv9+HPVn7PuXVXAe6VqAU19nHi4aCncMm8IKCntbs=" rel="preload stylesheet" as=style><link rel=icon href=https://s-ai-unix.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s-ai-unix.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s-ai-unix.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s-ai-unix.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s-ai-unix.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://s-ai-unix.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://s-ai-unix.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://s-ai-unix.github.io/posts/"><meta property="og:site_name" content="s-ai-unix's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://s-ai-unix.github.io/posts/"}]}</script><link rel=stylesheet href=https://s-ai-unix.github.io/css/classical-quote.css></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://s-ai-unix.github.io/ accesskey=h title="s-ai-unix's Blog (Alt + H)">s-ai-unix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s-ai-unix.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://s-ai-unix.github.io/posts/ title="📚 文章"><span class=active>📚 文章</span></a></li><li><a href=https://s-ai-unix.github.io/archives/ title="📁 归档"><span>📁 归档</span></a></li><li><a href=https://s-ai-unix.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://s-ai-unix.github.io/search/ title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://s-ai-unix.github.io/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://s-ai-unix.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/dirac-equation-cover.jpg alt=狄拉克方程的数学之美></figure><header class=entry-header><h2 class=entry-hint-parent>狄拉克方程：相对论量子力学的诞生</h2></header><div class=entry-content><p>引言:1928年的物理学困境 1928年的秋天,剑桥大学。一位26岁的年轻物理学家保罗·狄拉克(Paul Dirac)正面临着物理学界最根本的问题之一:如何将量子力学与狭义相对论统一起来?
当时的物理学界似乎被分裂成两个不相容的世界。一边是薛定谔方程,它在描述原子中的电子行为时取得了巨大成功,但只在低速情况下有效;另一边是爱因斯坦的狭义相对论,它精确地描述了高速运动物体的行为。问题是——这两个理论在数学结构上似乎根本无法协调。
让我们从这个困境出发,一步步理解狄拉克是如何通过数学的纯粹美感,找到了连接这两个世界的桥梁。
第一章:薛定谔方程的困境 1.1 非相对论量子力学的成功 1926年,奥地利物理学家埃尔温·薛定谔提出了著名的波动方程:
$$ i\hbar\frac{\partial}{\partial t}\psi(\mathbf{r},t) = \hat{H}\psi(\mathbf{r},t) $$
对于自由粒子(没有外力作用),哈密顿量是:
$$ \hat{H} = \frac{\hat{\mathbf{p}}^2}{2m} = -\frac{\hbar^2}{2m}\nabla^2 $$
这个方程在描述氢原子等低速系统时非常成功。它精确地预言了氢原子的能级,解释了原子光谱的规律。但是,如果你仔细观察这个方程的数学结构,会发现一个根本性的不对称性:
时间导数是一阶的: $\frac{\partial}{\partial t}$ 空间导数是二阶的: $\nabla^2 = \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2} + \frac{\partial^2}{\partial z^2}$ 这种不对称性意味着这个方程在洛伦兹变换下不会保持不变——换句话说,它不符合狭义相对论。
graph LR A[薛定谔方程非相对论量子力学] --> B[时间导数: 一阶空间导数: 二阶] B --> C[洛伦兹协变性破缺不符合狭义相对论] style A fill:#FF9500,stroke:#FF9500,stroke-width:2px,color:#ffffff style B fill:#AF52DE,stroke:#AF52DE,stroke-width:2px,color:#ffffff style C fill:#FF3B30,stroke:#FF3B30,stroke-width:3px,color:#ffffff 1.2 相对论的能量-动量关系 在狭义相对论中,自由粒子的能量和动量满足一个简单而优雅的关系:
...</p></div><footer class=entry-footer><span title='2026-01-20 20:00:00 +0800 CST'>January 20, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1485 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 狄拉克方程：相对论量子力学的诞生" href=https://s-ai-unix.github.io/posts/2026-01-20-dirac-equation-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/ai-risk-management.jpg alt=AI驱动的行业风险管理对比></figure><header class=entry-header><h2 class=entry-hint-parent>AI驱动行业风险管理：汽车、航空、医疗行业的深度对比研究</h2></header><div class=entry-content><p>引言 人工智能技术正在深刻改变汽车、航空和医疗三大高风险行业的运作模式。这三个行业有一个共同特点：系统失效可能导致人员伤亡、重大财产损失或严重社会后果。随着AI技术在感知、决策和控制领域的广泛应用，如何有效识别、评估和管理AI带来的新型风险，已成为行业监管机构、制造商和医疗机构共同面临的重大课题。
本文将从风险分类框架、标准体系、实践案例、管理方法和进展挑战五个维度，对汽车、航空、医疗三个行业的AI风险分析与风险管理进行系统性对比研究，旨在为读者提供全面的方法论解读和丰富的实践参考。
第一章 三大行业AI风险分类框架对比 graph TB subgraph 汽车行业风险分类 Auto[汽车AI风险] --> Auto1[功能安全
ISO 26262
系统性故障] Auto --> Auto2[SOTIF
ISO 21448
功能不足] Auto --> Auto3[网络安全
ISO/SAE 21434
恶意攻击] end subgraph 航空工业风险分类 Aero[航空AI风险] --> Aero1[DAL A
灾难级] Aero --> Aero2[DAL B
危险级] Aero --> Aero3[DAL C
重大级] Aero --> Aero4[DAL D
轻微级] Aero --> Aero5[DAL E
无影响] end subgraph 医疗行业风险分类 Medi[医疗AI风险] --> Medi1[患者安全
诊断错误] Medi --> Medi2[诊断准确性
模型性能] Medi --> Medi3[数据隐私
HIPAA合规] end style Auto fill:#007AFF,stroke:#007AFF,stroke-width:3px,color:#ffffff style Aero fill:#FF9500,stroke:#FF9500,stroke-width:3px,color:#ffffff style Medi fill:#AF52DE,stroke:#AF52DE,stroke-width:3px,color:#ffffff 1.1 汽车行业风险分类体系 汽车行业的AI风险分类建立在功能安全（Functional Safety）、预期功能安全（SOTIF）和网络安全（Cybersecurity）三大支柱之上，形成了独特的"三层防护"体系。
...</p></div><footer class=entry-footer><span title='2026-01-16 10:00:00 +0800 CST'>January 16, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>781 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to AI驱动行业风险管理：汽车、航空、医疗行业的深度对比研究" href=https://s-ai-unix.github.io/posts/2026-01-16-ai-risk-management-comparison/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/automotive-risk-analysis.jpg alt=汽车网络安全威胁分析概念图></figure><header class=entry-header><h2 class=entry-hint-parent>汽车行业 TARA 分析综述：方法论与实践深度解析</h2></header><div class=entry-content><p>引言：网络安全威胁下的汽车安全新范式 随着汽车产业向智能化、网联化、电动化快速演进，车辆已从单纯的机械交通工具转变为高度复杂的移动计算平台。车载电子电气架构的深度融合、远程OTA升级功能的普及、V2X车路协同技术的应用，使得汽车面临着前所未有的网络安全威胁。传统的汽车安全设计理念已无法有效应对现代网络攻击手段的威胁，在此背景下，威胁分析与风险评估（Threat Analysis and Risk Assessment，简称TARA）方法论应运而生，成为汽车网络安全工程领域的核心方法论框架。
TARA分析不仅是ISO/SAE 21434《道路车辆网络安全工程》标准规定的强制性要求，更是汽车制造商和供应商识别、评估、缓解网络安全风险的系统化工程方法。通过科学的TARA分析流程，组织能够全面识别车辆系统面临的威胁场景，定量评估潜在风险等级，并据此制定针对性的安全控制措施，从而在产品全生命周期中有效管理网络安全风险。本文将深入解析TARA分析的方法论体系，结合丰富的行业实践案例，为读者呈现汽车网络安全风险评估的完整知识图谱。
第一章 TARA分析的理论基础与标准框架 1.1 汽车网络安全威胁的演进脉络 汽车网络安全威胁的发展历程与车辆电子化程度密切相关。在分布式电子电气架构时代，车辆主要通过CAN总线进行车内网络通信，攻击面相对有限，主要威胁来源于物理接触式攻击，如通过OBD-II诊断接口进行的攻击。随着域控制器架构的引入和车载以太网的应用，车辆具备了远程联网能力，攻击者可从云端服务器、手机APP、充电基础设施等多维度发起攻击，威胁态势呈现指数级恶化态势。
当前汽车行业面临的主要威胁类型包括：针对车载信息娱乐系统（IVI）的恶意软件注入与远程控制攻击；针对高级驾驶辅助系统（ADAS）的传感器欺骗与感知系统干扰；针对车联网云平台的API滥用与数据泄露；针对电动汽车充电基础设施的中间人攻击；针对V2X通信的虚假信息注入与拒绝服务攻击。这些威胁一旦被恶意利用，可能导致车辆被远程控制、用户隐私泄露、交通事故发生，甚至危害公共安全。
1.2 国际标准体系对TARA的规范化要求 ISO/SAE 21434标准是汽车网络安全领域的里程碑式文件，该标准于2021年正式发布，规定了道路车辆网络安全工程的全生命周期要求。在标准框架下，TARA分析被定位为网络安全风险管理的核心活动，贯穿于概念阶段、产品开发阶段及后开发阶段的全过程。标准明确要求组织应建立系统化的威胁分析方法，识别相关资产可能面临的威胁，并基于威胁可能性和影响严重性进行风险等级评定。
联合国世界车辆法规协调论坛（WP.29）发布的R155法规是另一个重要的法规框架，该法规规定了车辆制造商必须建立网络安全管理体系（CSMS），并对特定车型进行网络安全风险评估。R155法规明确要求制造商应识别并评估与车辆类型相关的网络安全风险，实施相应的风险缓解措施，并通过持续监控机制保持安全态势。值得注意的是，R155法规不仅适用于M类（乘用车）、N类（货车）车辆，还扩展至L类（摩托车）及其他特殊车辆类型。
1.3 TARA分析的核心价值定位 TARA分析的核心价值在于将模糊的"网络安全问题"转化为可量化、可管理、可追踪的工程问题。通过系统化的分析流程，组织能够获得以下关键产出：资产清单及其安全属性定义；威胁场景清单及攻击路径分析；风险等级评定结果及排序；安全需求规格及控制措施建议。这些产出直接指导后续的安全设计、验证确认活动，确保安全投入的精准性和有效性。
从系统工程角度而言，TARA分析体现了"安全左移"的先进理念。在产品概念阶段早期开展TARA分析，能够在架构设计阶段就嵌入安全考量，避免后期返工带来的巨大成本。同时，TARA分析也为安全测试提供了明确的测试目标和验收标准，形成了从风险识别到安全验证的完整闭环。
第二章 TARA分析方法论体系详解 flowchart TD Start([TARA分析开始]) --> P1[阶段一: 分析准备资产识别与边界定义] P1 --> P2[阶段二: 威胁建模攻击路径与攻击树分析] P2 --> P3[阶段三: 风险评估可能性与影响性评级] P3 --> P4[阶段四: 风险处置策略选择与控制措施设计] P4 --> End([输出网络安全需求]) style Start fill:#007AFF,stroke:#007AFF,stroke-width:3px,color:#ffffff style P1 fill:#5AC8FA,stroke:#007AFF,stroke-width:2px,color:#ffffff style P2 fill:#FF9500,stroke:#FF9500,stroke-width:2px,color:#ffffff style P3 fill:#AF52DE,stroke:#AF52DE,stroke-width:2px,color:#ffffff style P4 fill:#34C759,stroke:#34C759,stroke-width:2px,color:#ffffff style End fill:#30D158,stroke:#34C759,stroke-width:3px,color:#ffffff 2.1 分析准备阶段：资产识别与边界定义 TARA分析的第一步是明确分析范围和识别保护对象，这一阶段的工作质量直接决定后续分析的完整性和有效性。资产识别需要建立系统化的资产清单，该清单不仅包括物理资产（如ECU、传感器、执行器），还包括逻辑资产（如功能、服务、数据）以及抽象资产（如用户隐私、车辆安全功能完整性）。
...</p></div><footer class=entry-footer><span title='2026-01-16 09:09:00 +0800 CST'>January 16, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>408 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 汽车行业 TARA 分析综述：方法论与实践深度解析" href=https://s-ai-unix.github.io/posts/2026-01-16-tara-analysis/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/automotive-risk-analysis.jpg alt=汽车风险分析概念图></figure><header class=entry-header><h2 class=entry-hint-parent>汽车领域风险分析综述：从传统方法到AI时代的演进与标准体系</h2></header><div class=entry-content><p>汽车领域风险分析综述：从传统方法到AI时代的演进与标准体系 一、引言 1.1 汽车行业风险分析的重要性 当我们回顾汽车工业的百年发展历程，一个不可忽视的事实是：汽车已经从单纯的机械交通工具演变为高度复杂的电子电气与软件系统集成的智能终端。这一深刻变革不仅重塑了汽车的驾驶体验，更从根本上改变了我们思考汽车安全的方式。
现代汽车的电子电气系统代码量已经突破亿行大关，一辆高端车型的ECU数量可达百余个，涵盖发动机控制、制动系统、转向系统、ADAS高级驾驶辅助系统、车联网通信等关键功能域。这种前所未有的系统复杂度，使得传统的机械可靠性设计方法论面临严峻挑战。据行业统计，电子电气系统故障已成为现代汽车召回的首要原因，其比例在过去十年间持续攀升。
汽车安全从被动安全（碰撞后的生存保护）发展到主动安全（预防事故发生），再到今天的功能安全与预期功能安全，要求我们在车辆设计阶段就必须系统性地识别、评估和控制潜在风险。这不再是"发现问题、解决问题"的迭代思维，而是"预见问题、预防问题"的系统工程思维。
从法规层面看，全球主要汽车市场正在经历从推荐性标准到强制性法规的转变。欧盟UNECE R155法规要求车辆制造商必须建立网络安全管理系统并获得CSMS认证才能进入市场；R156法规则针对软件更新提出了SUMS认证要求。在中国，工信部发布的《关于加强智能网联汽车生产企业及产品准入管理的意见》同样将功能安全和数据安全作为产品准入的必要条件。这种监管趋势意味着，风险分析不再仅仅是工程实践的优化，更是市场准入的门槛。
与此同时，人工智能技术正以前所未有的速度渗透汽车领域。从基于深度学习的感知算法，到端到端的自动驾驶大模型，再到大语言赋能的智能座舱，AI正在重新定义汽车的"大脑"。然而，AI系统的风险特征与传统电子电气系统存在本质差异：模型的不可解释性、数据的依赖性、对抗样本的脆弱性、环境分布偏移的不确定性，这些新风险载体需要全新的分析方法论。
本文旨在系统梳理汽车领域风险分析的方法论体系，从传统的FMEA、FTA到现代的STPA，从功能安全的HARA到网络安全的TARA，从定性分析到定量评估，从单机系统到车云协同。我们将深入剖析每种方法的原理、步骤与案例，对比传统与AI风险分析的差异，并详细解读国际与欧盟主流标准体系，为读者构建完整的汽车风险分析知识图谱。
1.2 文章结构概览 本文采用"方法论-对比-标准-展望"的四段式结构，系统性地介绍汽车领域风险分析的完整体系。
在方法论部分，我们将深入探讨五种核心风险分析方法：FMEA失效模式与影响分析作为预防性质量工具的典型代表；FTA故障树分析作为演绎推理的经典方法；STPA系统理论过程分析作为复杂系统安全的新范式；HARA危害分析与风险评估作为ISO 26262功能安全的核心步骤；TARA威胁分析与风险评估作为ISO/SAE 21434网络安全工程的基础。每种方法都将从背景历史、核心原理、操作步骤、案例实践四个维度进行详尽阐述。
在对比分析部分，我们将从风险载体、评估方法、风险特点、可控性、防御策略五个维度，系统对比传统风险分析与AI风险分析的异同，揭示AI时代风险分析面临的独特挑战与应对策略。
在标准解读部分，我们将梳理IEC 61508、ISO 26262、ISO 21448、ASPICE、ISO/SAE 21434、UNECE R155/R156等主流标准的技术要点、等效关系与实施路径，帮助读者在复杂的标准丛林中找到清晰的主线。
在总结展望部分，我们将回顾方法论的演进脉络，分析未来发展趋势，并为不同应用场景提供方法选择建议。
二、传统风险分析方法论 2.1 FMEA——失效模式与影响分析 2.1.1 背景与历史 FMEA的故事始于20世纪60年代美国国家航空航天局（NASA）的阿波罗登月计划。在那个航天技术尚处于萌芽阶段的年代，太空探索的高风险性使得传统的"测试-发现问题-修改设计"的迭代模式代价过于高昂。工程师们需要一种能够在设计阶段就系统识别潜在失效模式的方法，这就是FMEA诞生的背景。
从NASA的军事航天领域起步，FMEA迅速扩展到核工业、化工、航空等高安全行业。1970年代，随着日本汽车工业的崛起，FMEA迎来了第二次发展高峰。丰田、日产等企业将FMEA与精益生产、质量圈等管理方法深度融合，形成了具有东方特色的持续改进文化。1980年代，FMEA被引入汽车行业，并在福特、通用、克莱斯勒等美国车企中得到广泛应用。
为了规范FMEA的实施方法，美国汽车工业行动小组（AIAG）与德国汽车工业协会（VDA）于2019年联合发布了AIAG-VDA FMEA标准，这是FMEA发展史上最重要的里程碑之一。该标准统一了美系与德系FMEA的术语、表格格式和评分方法，消除了跨国供应链中的沟通障碍。2024年，AIAG-VDA FMEA标准进行了新一轮更新，进一步强化了七步法结构、更强调了鲁棒性设计思想，并完善了对于自动驾驶等新兴技术的应用指南。
2.1.2 核心原理 FMEA本质上是一种预防性的可靠性分析工具，其核心思想是：在产品或系统投入生产使用之前，系统性地识别所有可能的失效模式，分析每种失效模式对系统功能的影响，并按照风险优先级排序，指导改进措施的制定与实施。
FMEA的三维评估模型是其技术核心。这一模型通过三个维度的量化评分，计算出风险优先序数（Risk Priority Number，RPN），作为失效模式优先级排序的依据：
严重度（Severity，S） 评估失效模式一旦发生，对系统功能、用户安全或法规符合性的影响程度。评分范围通常为1-10分，其中1分表示无影响，10分表示可能导致严重伤害或死亡的致命影响。在汽车行业，S值大于等于8的失效模式通常需要重点关注。
发生频率（Occurrence，O） 评估失效模式实际发生的可能性。评分范围同样为1-10分，其中1分表示失效几乎不可能发生，10分表示失效几乎必然发生。O值的评估需要结合历史数据、类似系统经验以及设计特性分析。
探测度（Detection，D） 评估在产品出厂前或失效发生前，通过测试、检查等手段发现失效模式的能力。评分范围为1-10分，其中1分表示失效肯定能被检测到，10分表示失效无法被检测到。D值越高，说明现有的检测手段越不充分。
RPN计算公式：$RPN = S \times O \times D$
graph LR subgraph RPN计算模型 S[严重度 S1-10分] --> RPN[RPN = S × O × D风险优先序数] O[发生频率 O1-10分] --> RPN D[探测度 D1-10分] --> RPN end RPN -->|1-1000分| RISK[风险等级评估] style S fill:#FF3B30,stroke:#FF3B30,stroke-width:2px,color:#ffffff style O fill:#FF9500,stroke:#FF9500,stroke-width:2px,color:#ffffff style D fill:#AF52DE,stroke:#AF52DE,stroke-width:2px,color:#ffffff style RPN fill:#007AFF,stroke:#007AFF,stroke-width:3px,color:#ffffff style RISK fill:#34C759,stroke:#34C759,stroke-width:2px,color:#ffffff RPN的取值范围为1-1000分。RPN越高，表示该失效模式的风险越大，需要优先采取措施降低风险。需要特别强调的是，RPN仅用于优先级排序，三个维度的权重并非总是相等，在特定行业或应用场景下，组织可能需要根据自身经验调整评估标准。
...</p></div><footer class=entry-footer><span title='2026-01-16 09:08:00 +0800 CST'>January 16, 2026</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>2072 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 汽车领域风险分析综述：从传统方法到AI时代的演进与标准体系" href=https://s-ai-unix.github.io/posts/2026-01-16-automotive-risk-analysis-overview/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/hara-automotive.jpg alt=汽车安全分析概念图></figure><header class=entry-header><h2 class=entry-hint-parent>汽车行业 HARA 分析综述：从理论到实践</h2></header><div class=entry-content><p>引言 想象一下这样的场景：一辆电动汽车正在高速公路上以 $100\text{ km/h}$ 的速度行驶，突然，电子节气门控制系统发生故障，导致车辆意外加速。驾驶员试图踩下刹车，但车辆却继续加速，最终酿成悲剧。这不是虚构的假设，而是真实发生过的汽车安全事故——2009 年丰田意外加速事件。
这个悲剧促使整个汽车行业重新思考安全工程的方法论。在这个过程中，危害分析与风险评估（Hazard Analysis and Risk Assessment，简称 HARA） 逐渐成为汽车功能安全的基石。HARA 不仅仅是一个技术流程，更是一种系统化的思维框架，帮助工程师在复杂的汽车系统中识别潜在风险，并制定相应的防护措施。
今天，我们就来深入探讨 HARA 的理论基础、发展历程以及在汽车行业的实际应用。
HARA 的理论基础 什么是 HARA？ HARA 是 ISO 26262 汽车功能安全标准中定义的核心流程，旨在系统性地识别由系统故障导致的危害事件，评估相关风险，并制定安全目标以避免不合理风险的发生。简单来说，HARA 回答了三个关键问题：
什么可能出错？（危害识别） 如果出错了，后果有多严重？（风险评估） 如何防止或缓解风险？（安全措施） HARA 是在整个汽车产品生命周期中实施的第一个主要任务，也是 ISO 26262 合规流程中的关键环节。它发生在概念设计阶段，为后续的系统架构设计、测试和验证奠定了基础。
ISO 26262 标准的诞生 要理解 HARA，我们必须先了解 ISO 26262 标准的诞生背景。
在汽车电子系统日益复杂的背景下，国际电工委员会（IEC）制定的 IEC 61508 标准为功能安全提供了通用的方法论。然而，汽车行业有其特殊性：大规模生产、成本敏感、高度分布式系统架构等。因此，在 IEC 61508 的基础上，汽车行业专门制定了 ISO 26262 标准，即 “道路车辆功能安全” 标准（Road vehicles – Functional safety）。
ISO 26262 首次于 2011 年 发布，涵盖了汽车电气/电子系统的整个安全生命周期，从概念阶段、系统设计、硬件设计、软件设计，到生产、运行、服务，直到退役。HARA 在 ISO 26262 第 3 部分（概念阶段）中被正式定义，是功能安全工程活动的起点。
...</p></div><footer class=entry-footer><span title='2026-01-16 09:06:00 +0800 CST'>January 16, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>942 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 汽车行业 HARA 分析综述：从理论到实践" href=https://s-ai-unix.github.io/posts/2026-01-16-hara-automotive-analysis/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/neural-network-evolution.jpg alt=抽象神经网络连接图></figure><header class=entry-header><h2 class=entry-hint-parent>神经网络算法演进：从感知机到 Transformer 的七十年征程</h2></header><div class=entry-content><p>引言：智慧的萌芽 想象一下 1957 年的夏天，康奈尔大学的弗兰克·罗森布拉特（Frank Rosenblatt）在实验室里调试着一台早期的电子计算机。他正在实现一个大胆的想法——能否用数学模型模拟人类的大脑神经元？
这个想法在当时看起来近乎荒谬。人类大脑由数百亿个神经元组成，神经元之间通过突触连接，形成了一个令人眩晕的复杂网络。但罗森布拉特相信，如果我们能理解单个神经元的基本工作原理，就能一步步构建出能够学习的智能系统。
那时的学术界对机器学习充满怀疑。“机器怎么可能思考？"——这是当时的主流声音。但罗森布拉特和他的同道们坚持了下来，用数学公式编织着最初的神经之梦。
今天，当我们面对能够写出论文、创作艺术、驾驶汽车的深度学习系统时，很容易忘记这一切都始于一个简单的线性分类器。让我们放慢脚步，回顾这七十年的征程，感受数学的力量与思想的演进。
一、感知机：神经网络的起点（1957） 时间：1957 年 - 弗兰克·罗森布拉特 (Frank Rosenblatt)
历史的起点 1957 年，弗兰克·罗森布拉特在康奈尔航空实验室发明了感知机（Perceptron）。这是第一个能够学习的神经网络模型，被誉为"机器学习的开端”。
1962 年的《纽约客》杂志甚至专门报道了这个发明，称它为"会思考的机器"。那时的媒体兴奋中充满了对人工智能未来的无限遐想。
数学形式 单个神经元的工作原理 一个感知机神经元接收 $d$ 维输入 $\mathbf{x} = (x_1, x_2, \ldots, x_d)^T$，每个输入对应一个权重 $w_i$，还有一个偏置 $b$。
神经元的输出是输入的加权和，然后通过激活函数：
$$ y = f(z) = f\left(\sum_{i=1}^{d} w_i x_i + b\right) = f(w^T x + b) $$
其中 $z = \mathbf{w}^T \mathbf{x} + b$ 是净输入（net input）。
激活函数 在最初的感知机中，激活函数是符号函数（sign function）：
$$ f(z) = \begin{cases} 1 & \text{if } z \geq 0 \ -1 & \text{if } z &lt; 0 \end{cases} $$
...</p></div><footer class=entry-footer><span title='2026-01-15 23:55:00 +0800 CST'>January 15, 2026</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>1578 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 神经网络算法演进：从感知机到 Transformer 的七十年征程" href=https://s-ai-unix.github.io/posts/2026-01-15-neural-network-evolution/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/ml-algorithms-legacy.jpg alt=抽象几何图案></figure><header class=entry-header><h2 class=entry-hint-parent>深度学习前夜：十大传统机器学习算法的历史与数学之美</h2></header><div class=entry-content><p>引言：黄金时代 想象一下 2006 年的秋天，深度学习尚未兴起。那时的机器学习领域正经历着一场静悄悄的革命。统计学习方法、核方法、集成学习层出不穷，数学家们用优雅的公式编织着智能的梦想。
那时，人们相信：只要数据足够、特征工程足够细致，我们就能教机器做任何事。这种信念催生了一批经典算法——它们或许不如今天的深度神经网络那样炫目，但每一款都凝聚着数学家的智慧，每一步推导都闪耀着逻辑的光辉。
今天，我们回顾这段黄金时代，讲述十个改变了世界的传统机器学习算法的故事。但这次，让我们放慢脚步，亲手推导每一步，感受数学的力量。
一、线性回归：回归分析的鼻祖 时间：1795 年 - 阿德里安-马里·勒让德 (Adrien-Marie Legendre)
历史的偶然 1795 年，法国天文学家勒让德正在为一个问题头疼：如何用最简单的方法拟合行星轨道数据？他需要找到一条直线，让所有数据点到这条直线的距离平方和最小。
这就是最小二乘法的诞生。
推导过程 让我们从最简单的情况开始。假设我们有 $n$ 个数据点 $(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)$，想要找到一条直线 $y = w_0 + w_1 x$ 来拟合这些数据。
第一步：定义误差
对于每个数据点 $(x_i, y_i)$，我们的预测值是 $\hat{y}_i = w_0 + w_1 x_i$，误差就是观测值和预测值的差：
$$ e_i = y_i - \hat{y}_i = y_i - (w_0 + w_1 x_i) $$
第二步：定义损失函数
为什么是平方误差？勒让德选择平方误差有几个好处：
非负：平方后总是非负 可导：处处光滑，便于优化 凸函数：只有一个最小值 损失函数定义为：
$$ L(w_0, w_1) = \sum_{i=1}^{n} e_i^2 = \sum_{i=1}^{n} [y_i - (w_0 + w_1 x_i)]^2 $$
...</p></div><footer class=entry-footer><span title='2026-01-15 22:30:00 +0800 CST'>January 15, 2026</span>&nbsp;·&nbsp;<span>17 min</span>&nbsp;·&nbsp;<span>3481 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 深度学习前夜：十大传统机器学习算法的历史与数学之美" href=https://s-ai-unix.github.io/posts/2026-01-15-traditional-ml-algorithms/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/vector-calculus-geometry.jpg alt=向量场的几何直觉></figure><header class=entry-header><h2 class=entry-hint-parent>微积分的三大公式：格林、高斯与斯托克斯定理的统一视角</h2></header><div class=entry-content><p>想象这样一个场景：你站在河边，看着水流在河道中蜿蜒前行。河水的流速在不同的位置和方向上都不同——有的地方湍急，有的地方平缓。如果你想知道流过一个闭合河岸的净水量，你会怎么做？
直觉告诉你：可以沿着河岸计算流进和流出的差异。但数学告诉你，这等价于计算河岸所包围区域内水源的"产生"或"消失"。这就是格林公式的物理直观。
从二维的河流到三维的空气流动，从平面上的旋转到空间中的曲面，微积分的三大公式——格林公式、高斯公式、斯托克斯公式——都在讲述同一个深刻的思想：边界上的积分与内部的积分可以通过某种微分运算相互转化。
一、预备知识：向量微积分的语言 在深入三大公式之前，让我们先回顾一些必要的基础概念。
1.1 向量场 向量场 $\mathbf{F} : \mathbb{R}^n \to \mathbb{R}^n$ 是一个函数，它给空间中的每个点赋予一个向量。在二维情况下，我们通常写成：
$$ \mathbf{F}(x, y) = P(x, y)\mathbf{i} + Q(x, y)\mathbf{j} $$
物理中常见的向量场包括：
流体的速度场 电磁场的电场或磁场 引力场 图 1：向量场 F = (-y, x) 的可视化。这是一个旋转场，向量围绕原点旋转，形成同心圆的流线。
1.2 梯度、散度与旋度 假设 $f(x, y, z)$ 是一个标量函数，$\mathbf{F} = (P, Q, R)$ 是一个向量场，我们有三个关键的微分算子：
梯度：标量场的梯度是一个向量，指向函数增长最快的方向。
$$ \nabla f = \left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z}\right) $$
散度：向量场的散度是一个标量，衡量向量场在某点的"发散"程度。
$$ \nabla \cdot \mathbf{F} = \frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z} $$
...</p></div><footer class=entry-footer><span title='2026-01-14 22:14:36 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1191 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 微积分的三大公式：格林、高斯与斯托克斯定理的统一视角" href=https://s-ai-unix.github.io/posts/2026-01-14-greens-gauss-stokes-formulas-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/unsplash-taylor.jpg alt=抽象几何曲线></figure><header class=entry-header><h2 class=entry-hint-parent>泰勒公式：用简单近似复杂的艺术</h2></header><div class=entry-content><p>引言：从曲线到直线 想象你站在一座山上，想知道脚下的山坡有多陡。你不需要知道整个山脉的形状，只需要知道你所在位置的局部斜率。这是微积分最基本的思想——用局部信息推断全局行为。
更进一步，如果山坡弯曲了怎么办？这时不仅需要知道斜率，还需要知道弯曲的程度。这就是泰勒公式的核心思想：用最简单的函数（多项式）来近似复杂的函数，而近似的质量取决于我们使用多少局部信息（导数）。
泰勒公式被誉为"数学家最有力的工具之一"。它不仅连接了离散与连续、局部与整体，更在数值计算、物理建模和现代人工智能中扮演着不可替代的角色。今天，让我们深入探索这个既古老又常新的数学宝藏。
一、历史回顾：从牛顿到泰勒 泰勒公式的思想可以追溯到牛顿和莱布尼茨创立微积分的时期。牛顿在他的《流数术》中已经隐含了将函数展开为无穷级数的想法。
布鲁克·泰勒（Brook Taylor，1685-1731）在1715年发表了他的开创性论文《增量法及其逆运算》，首次系统地阐述了用多项式级数逼近函数的方法。有趣的是，泰勒本人并没有意识到他发现的公式的全部潜力，余项的研究（拉格朗日余项、柯西余项等）是后来由拉格朗日等数学家完善的。
麦克劳林（Colin Maclaurin）发现了泰勒公式在零点展开的特例，即麦克劳林级数。这个形式在实际计算中更为常用，因为计算起来更加方便。
二、一元函数的泰勒公式 基本形式 假设函数 $f(x)$ 在点 $a$ 处足够光滑（即具有各阶导数），那么我们可以构造一个多项式 $P_n(x)$ 来近似 $f(x)$：
$$ P_n(x) = f(a) + f’(a)(x-a) + \frac{f’’(a)}{2!}(x-a)^2 + \cdots + \frac{f^{(n)}(a)}{n!}(x-a)^n $$
泰勒公式告诉我们：
$$ f(x) = P_n(x) + R_n(x) $$
其中 $R_n(x)$ 是余项，表示近似误差。
余项的几种形式 理解余项对于掌握泰勒公式至关重要，因为它告诉我们近似在什么范围内可靠。
拉格朗日余项：
$$ R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-a)^{n+1} $$
其中 $\xi$ 是 $a$ 和 $x$ 之间的某个值。
积分余项：
$$ R_n(x) = \frac{1}{n!} \int_a^x f^{(n+1)}(t)(x-t)^n , dt $$
直观理解 让我们通过一个简单的例子来理解泰勒公式。考虑 $f(x) = e^x$ 在 $a = 0$ 处的泰勒展开（即麦克劳林级数）：
...</p></div><footer class=entry-footer><span title='2026-01-14 22:10:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>947 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 泰勒公式：用简单近似复杂的艺术" href=https://s-ai-unix.github.io/posts/2026-01-14-taylor-series/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/unsplash-laplacian.jpg alt=抽象几何图形></figure><header class=entry-header><h2 class=entry-hint-parent>拉普拉斯方程：数学物理中的优雅平衡</h2></header><div class=entry-content><p>引言：一片平静的水面 想象一个平静的水面，没有风，没有涟漪。如果我们在水面上轻轻滴一滴墨水，墨水会如何扩散？这背后隐藏着一个深刻的数学原理。
再想象一个均匀导热的金属板，边缘保持恒定温度。时间足够长后，板内部的温度分布会达到一种稳定状态。有趣的是，这种稳定状态有一个共同的数学描述。
这就是拉普拉斯方程的魔法所在。它描述的是一种完美的"平衡"状态——系统中每一点的数值都与其周围邻居的平均值相等。这个简单的条件，却蕴含着自然界中无数现象的精髓。
一、历史的足迹 皮埃尔-西蒙·拉普拉斯（Pierre-Simon Laplace，1749-1827）是法国数学家、天文学家和物理学家。他在研究天体力学和引力问题时，首次系统地研究了这个以他名字命名的方程。
但拉普拉斯方程的发现并非孤立的。在此之前，欧拉（Euler）和达朗贝尔（d’Alembert）已经在流体力学和波动方程的研究中涉及了类似的思想。拉普拉斯的贡献在于他系统性地研究了这个方程，并将其推广到多个变量，使其成为研究各种物理现象的统一框架。
二、从一维开始：最简单的平衡 让我们从最简单的一维情况开始理解拉普拉斯方程。
一维拉普拉斯方程 在一维情况下，拉普拉斯方程的形式异常简洁：
$$ \frac{d^2 u}{dx^2} = 0 $$
其中 $u(x)$ 是我们要找的函数。
这个方程说的是什么呢？它的意思是函数的二阶导数为零。在微积分中我们知道，如果二阶导数为零，那么一阶导数必须是常数：
$$ \frac{du}{dx} = C_1 $$
再积分一次，我们得到：
$$ u(x) = C_1 x + C_2 $$
这告诉我们，在一维情况下，满足拉普拉斯方程的函数只能是线性函数（直线）。
物理意义 想象一根均匀的导热棒，两端分别保持不同的温度。当热传导达到稳定状态时，温度分布会是怎样的？
如果棒长为 $L$，左端温度为 $T_1$，右端温度为 $T_2$，那么温度分布 $u(x)$ 满足：
$$ \frac{d^2 u}{dx^2} = 0, \quad u(0) = T_1, \quad u(L) = T_2 $$
解这个方程，我们得到：
$$ u(x) = T_1 + \frac{T_2 - T_1}{L} x $$
...</p></div><footer class=entry-footer><span title='2026-01-14 22:04:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>669 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 拉普拉斯方程：数学物理中的优雅平衡" href=https://s-ai-unix.github.io/posts/2026-01-14-laplace-equation/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://s-ai-unix.github.io/posts/page/6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://s-ai-unix.github.io/posts/page/8/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://s-ai-unix.github.io/>s-ai-unix's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script></body></html>