<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions | s-ai-unix's Blog</title><meta name=keywords content="深度学习,神经网络,机器学习,综述"><meta name=description content="深入解读 Google 的 Inception-v4 论文，从 Inception 系列的演进历程出发，剖析 Inception-v4 的架构设计思想、多尺度特征提取原理，以及 Inception-ResNet 如何将残差连接与 Inception 模块融合，创造当时最强图像分类网络。"><meta name=author content="s-ai-unix"><link rel=canonical href=https://s-ai-unix.github.io/posts/2026-01-30-ai-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97-inception-v4-going-deeper-with-convolutions/><link crossorigin=anonymous href=/assets/css/stylesheet.0833aff7e1cf567ecfb9755701ee95a80535f671e2e1a0a770c9bc20a0a7b5bb.css integrity="sha256-CDOv9+HPVn7PuXVXAe6VqAU19nHi4aCncMm8IKCntbs=" rel="preload stylesheet" as=style><link rel=icon href=https://s-ai-unix.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s-ai-unix.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s-ai-unix.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s-ai-unix.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s-ai-unix.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://s-ai-unix.github.io/posts/2026-01-30-ai-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97-inception-v4-going-deeper-with-convolutions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://s-ai-unix.github.io/posts/2026-01-30-ai-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97-inception-v4-going-deeper-with-convolutions/"><meta property="og:site_name" content="s-ai-unix's Blog"><meta property="og:title" content="AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions"><meta property="og:description" content="深入解读 Google 的 Inception-v4 论文，从 Inception 系列的演进历程出发，剖析 Inception-v4 的架构设计思想、多尺度特征提取原理，以及 Inception-ResNet 如何将残差连接与 Inception 模块融合，创造当时最强图像分类网络。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-30T12:30:00+08:00"><meta property="article:modified_time" content="2026-01-30T12:30:00+08:00"><meta property="article:tag" content="深度学习"><meta property="article:tag" content="神经网络"><meta property="article:tag" content="机器学习"><meta property="article:tag" content="综述"><meta property="og:image" content="https://s-ai-unix.github.io/images/covers/inception-v4-cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://s-ai-unix.github.io/images/covers/inception-v4-cover.jpg"><meta name=twitter:title content="AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions"><meta name=twitter:description content="深入解读 Google 的 Inception-v4 论文，从 Inception 系列的演进历程出发，剖析 Inception-v4 的架构设计思想、多尺度特征提取原理，以及 Inception-ResNet 如何将残差连接与 Inception 模块融合，创造当时最强图像分类网络。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://s-ai-unix.github.io/posts/"},{"@type":"ListItem","position":2,"name":"AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions","item":"https://s-ai-unix.github.io/posts/2026-01-30-ai-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97-inception-v4-going-deeper-with-convolutions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions","name":"AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions","description":"深入解读 Google 的 Inception-v4 论文，从 Inception 系列的演进历程出发，剖析 Inception-v4 的架构设计思想、多尺度特征提取原理，以及 Inception-ResNet 如何将残差连接与 Inception 模块融合，创造当时最强图像分类网络。","keywords":["深度学习","神经网络","机器学习","综述"],"articleBody":"AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions 引言 2016年2月，Google 的 Christian Szegedy 等人在 arXiv 上发表了一篇名为《Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning》的论文。这篇论文不仅是 Inception 系列发展的重要里程碑，更提出了一种革命性的思路：将 Inception 的多尺度特征提取能力与 ResNet 的残差连接相结合。\n让我们先回顾一下当时的背景。2015年，ResNet 横空出世，用简单的跳跃连接解决了深层网络的退化问题，将网络深度推向了一百层甚至上千层。与此同时，Inception-v3 以其独特的多分支结构，在计算效率和准确率之间取得了优异的平衡。一个自然的问题浮现出来：**这两种看似迥异的设计哲学能否融合？**如果能将 Inception 的高效特征提取与残差连接的优化优势结合起来，会发生什么？\n本文将系统性地解读这篇经典论文，从 Inception 系列的演进脉络出发，深入剖析 Inception-v4 的架构设计原理，探讨 Inception-ResNet 的创新之处，以及残差缩放这一关键技术的数学本质。\n图：Inception 系列演进历程与 ImageNet 竞赛 Top-5 错误率变化趋势\n第一章：Inception 的演进之路 1.1 Inception-v1：多尺度特征提取的开创 要理解 Inception-v4，我们需要先回到2014年的 Inception-v1（GoogLeNet）。当时，深度学习领域的主流思路是\"越深越好\"——AlexNet 有8层，VGGNet 堆到了19层。但 Google 的研究者们提出了一个不同的观点：与其简单地堆叠相同的层，不如让网络自己选择如何组合不同尺度的特征。\nInception 模块的核心思想可以用一个简单的问题来概括：当我们观察一张图像时，我们究竟需要多大的感受野？\n识别一只猫的脸，可能只需要一个 $3 \\times 3$ 的区域就能看清它的眼睛和鼻子 但要判断这是一只完整卧着的猫，可能需要一个 $5 \\times 5$ 的区域来捕捉整体轮廓 而对于更宏观的场景理解，甚至需要更大的视野 Inception 模块的解决方案是并行使用不同大小的卷积核，让网络自己学习每种尺度的权重。一个典型的 Inception 模块包含四个分支：\n$1 \\times 1$ 卷积：捕捉局部特征，同时降维 $1 \\times 1$ 卷积后接 $3 \\times 3$ 卷积：中等尺度的特征 $1 \\times 1$ 卷积后接 $5 \\times 5$ 卷积：大尺度的特征 $3 \\times 3$ 最大池化后接 $1 \\times 1$ 卷积：保留显著特征 这四个分支的输出在通道维度上拼接（concatenate），形成下一层的输入。这种设计让网络能够自适应地选择最优的特征尺度。\n1.2 Inception-v2/v3：卷积分解的艺术 2015年，Szegedy 等人发表了《Rethinking the Inception Architecture for Computer Vision》，提出了 Inception-v2 和 Inception-v3。这篇论文的核心贡献是卷积核的因式分解（Factorization）。\n研究发现，大卷积核可以用一系列小卷积核来替代，而不会损失表达能力。具体来说：\n空间分解：一个 $5 \\times 5$ 的卷积核可以用两个 $3 \\times 3$ 的卷积核串联来替代。\n从数学上看，设输入特征图为 $\\mathbf{X}$，$5 \\times 5$ 卷积的输出为：\n$$ \\mathbf{Y} = W_{5 \\times 5} \\ast \\mathbf{X} $$\n其中 $W_{5 \\times 5}$ 有 $5 \\times 5 \\times C_{in} \\times C_{out}$ 个参数。\n而两个 $3 \\times 3$ 卷积的级联为：\n$$ \\mathbf{Y}’ = W_{3 \\times 3}^{(2)} \\ast \\sigma(W_{3 \\times 3}^{(1)} \\ast \\mathbf{X}) $$\n参数数量为 $2 \\times 3 \\times 3 \\times C_{in} \\times C_{out}$（假设中间通道数相同）。\n参数比为：\n$$ \\frac{2 \\times 3^2}{5^2} = \\frac{18}{25} = 0.72 $$\n这意味着在保持相似表达能力的同时，参数量减少了28%。\n非对称分解：更进一步，$n \\times n$ 的卷积可以分解为 $n \\times 1$ 后跟 $1 \\times n$。\n图：卷积核非对称分解示意图，$5 \\times 5$ 卷积可分解为 $5 \\times 1$ 和 $1 \\times 5$ 两个卷积，参数从25减少到10\n这种分解在计算上的优势非常明显。对于 $5 \\times 5$ 的卷积核：\n直接计算：每个输出位置需要 $5 \\times 5 = 25$ 次乘法 分解后：先 $5 \\times 1$ 需要 $5$ 次，再 $1 \\times 5$ 需要 $5$ 次，共 $10$ 次 计算量减少了60%，这是一个非常可观的效率提升。\n1.3 训练框架的变革与 Inception-v4 的契机 在 Inception-v3 的开发过程中，Google 的研究团队受限于当时的训练框架（DistBelief）。Szegedy 在论文中坦言，这种限制使得他们在实验中对模型架构的修改变得保守，导致 Inception-v3 的结构显得有些复杂和不规则。\n2015年底，Google 推出了 TensorFlow。新的框架消除了之前的许多限制，使得研究者能够更自由地探索网络架构。这为 Inception-v4 的诞生创造了条件：使用更统一、更模块化的方式来设计网络。\n第二章：Inception-v4 架构详解 2.1 整体架构概览 Inception-v4 的设计理念是清晰的分阶段处理。整个网络可以看作是一条从输入到输出的流水线，每个阶段负责特定粒度的特征提取。\n图：Inception-v4 整体架构流程，展示了从输入到输出的各阶段特征图尺寸变化\n如上图所示，Inception-v4 包含以下主要组件：\nStem：初始特征提取，将 $299 \\times 299 \\times 3$ 的输入转换为 $35 \\times 35 \\times 384$ Inception-A 模块（4个）：处理 $35 \\times 35$ 的特征图 Reduction-A：将特征图从 $35 \\times 35$ 下采样到 $17 \\times 17$ Inception-B 模块（7个）：处理 $17 \\times 17$ 的特征图 Reduction-B：将特征图从 $17 \\times 17$ 下采样到 $8 \\times 8$ Inception-C 模块（3个）：处理 $8 \\times 8$ 的特征图 全局平均池化、Dropout、全连接层：分类输出 这种分阶段设计的一个重要特点是：不同阶段的 Inception 模块针对不同的特征图尺寸进行了专门优化。\n2.2 Stem 模块：高效的初始处理 Stem 模块是 Inception-v4 的第一个创新点。它的任务是在进入核心 Inception 模块之前，快速降低空间维度并提取初始特征。\nInception-v4 的 Stem 包含以下步骤：\n$3 \\times 3$ 卷积，步长2（valid padding），输出 $149 \\times 149 \\times 32$ $3 \\times 3$ 卷积，输出 $147 \\times 147 \\times 32$ $3 \\times 3$ 卷积，输出 $147 \\times 147 \\times 64$ 池化分支：$3 \\times 3$ 最大池化，步长2，输出 $73 \\times 73 \\times 64$ 卷积分支：$3 \\times 3$ 卷积，步长2，输出 $73 \\times 73 \\times 96$ 拼接两个分支，输出 $73 \\times 73 \\times 160$ 这种设计的一个关键技巧是并行使用池化和卷积进行下采样。传统的做法是先卷积再池化，或者反过来。而 Inception-v4 让两者同时进行，然后将结果拼接。这样做的优势在于：\n卷积分支保留了更多语义信息 池化分支保留了最显著的特征响应 两者的组合提供了更丰富的特征表示 2.3 Inception-A/B/C 模块：分而治之的特征提取 Inception-v4 使用了三种不同的 Inception 模块，分别针对不同尺寸的特征图进行优化。\n图：Inception-A、Inception-B、Inception-C 三种模块的多分支结构对比\nInception-A 模块（用于 $35 \\times 35$ 的特征图）：\n这个阶段的特征图尺寸较大，空间信息丰富。Inception-A 包含四个分支：\n分支1：$1 \\times 1$ 卷积 分支2：$1 \\times 1$ 卷积后接 $3 \\times 3$ 卷积 分支3：$1 \\times 1$ 卷积后接两个 $3 \\times 3$ 卷积（等效于 $5 \\times 5$） 分支4：$3 \\times 3$ 平均池化后接 $1 \\times 1$ 卷积 Inception-B 模块（用于 $17 \\times 17$ 的特征图）：\n当特征图缩小到 $17 \\times 17$ 时，需要更大的感受野来捕捉上下文。Inception-B 引入了非对称卷积：\n分支1：$1 \\times 1$ 卷积 分支2：$1 \\times 1$ 卷积后接 $1 \\times 7$ 再接 $7 \\times 1$ 卷积 分支3：$1 \\times 1$ 卷积后接 $7 \\times 1$、$1 \\times 7$、$7 \\times 1$、$1 \\times 7$ 四层卷积 分支4：$3 \\times 3$ 平均池化后接 $1 \\times 1$ 卷积 这里的 $7 \\times 1$ 和 $1 \\times 7$ 就是前面提到的非对称分解。对于 $17 \\times 17$ 的特征图，$7 \\times 7$ 的感受野已经相当大，使用非对称分解可以大幅减少计算量。\nInception-C 模块（用于 $8 \\times 8$ 的特征图）：\n在最后阶段，特征图已经很小（$8 \\times 8$），但通道数很多（1536）。此时更关注细粒度的特征组合：\n分支1：$1 \\times 1$ 卷积 分支2：$1 \\times 1$ 卷积后接 $1 \\times 3$ 和 $3 \\times 1$ 卷积（并联） 分支3：$1 \\times 1$ 卷积后接 $1 \\times 3$ 再接 $3 \\times 1$ 卷积，然后再次分解为 $1 \\times 3$ 和 $3 \\times 1$ 分支4：$3 \\times 3$ 平均池化后接 $1 \\times 1$ 卷积 这种嵌套的非对称分解可以捕捉更复杂的特征模式。\n2.4 Reduction 模块：优雅的下采样 Inception-v4 的另一个创新是明确区分了特征提取模块（Inception-A/B/C）和下采样模块（Reduction-A/B）。\n在早期的 Inception 版本中，下采样是通过在 Inception 模块中使用步长大于1的卷积来隐式实现的。而 Inception-v4 将下采样逻辑抽取出来，形成了专门的 Reduction 模块。\nReduction-A（从 $35 \\times 35$ 到 $17 \\times 17$）：\n分支1：$3 \\times 3$ 卷积，步长2 分支2：$1 \\times 1$ 卷积后接 $3 \\times 3$ 卷积，再接 $3 \\times 3$ 卷积步长2 分支3：$3 \\times 3$ 最大池化，步长2 三个分支的输出拼接，通道数从 $k + l + m + n$（具体数值见论文表1）变为 $384$（Inception-v4）或 $384$（Inception-ResNet-v2）。\n这种设计的好处是：\n模块职责更清晰，易于理解和修改 可以针对不同阶段的特性优化下采样策略 便于在实验中快速调整下采样位置 第三章：Inception-ResNet：当 Inception 遇见残差 3.1 动机：融合两种设计哲学 2015年底，深度学习领域有两个最耀眼的明星：\nResNet：通过残差连接解决了深层网络的训练问题，将深度推向100+层 Inception-v3：通过多尺度特征提取，在计算效率和准确率之间取得了优异平衡 一个自然的问题是：**能否将两者的优势结合起来？**残差连接能否帮助 Inception 网络训练得更快、更深？\nInception-ResNet 的核心思想是用残差连接替代 Inception 模块中的特征拼接。在传统 Inception 中，多个分支的输出在通道维度上拼接：\n$$ \\mathbf{Y} = \\text{concat}([\\mathbf{Y}_1, \\mathbf{Y}_2, \\mathbf{Y}_3, \\mathbf{Y}_4]) $$\n而在 Inception-ResNet 中，多个分支的输出相加（逐元素相加）：\n$$ \\mathbf{Y} = \\mathbf{X} + \\sum_{i} \\mathcal{F}_i(\\mathbf{X}) $$\n其中 $\\mathcal{F}_i$ 表示第 $i$ 个分支的变换。\n3.2 Inception-ResNet-v1 与 v2 论文提出了两个 Inception-ResNet 变体：\n模型 参数量 计算复杂度 对应无残差版本 Inception-ResNet-v1 约10M 与 Inception-v3 相当 Inception-v3 Inception-ResNet-v2 约55M 与 Inception-v4 相当 Inception-v4 这种对应关系使得我们可以进行公平的对比实验：如果 Inception-ResNet-v1 比 Inception-v3 训练得更快，那就可以归因于残差连接的作用，而非网络容量差异。\n架构差异：\nInception-ResNet-v1 使用简化的 Inception 模块 Inception-ResNet-v2 的 Stem 和 Inception-v4 相同，但 Inception 模块使用残差连接 维度匹配的关键设计：\n由于 Inception 模块会压缩维度（通过 $1 \\times 1$ 卷积），而残差连接要求输出与输入维度相同，因此 Inception-ResNet 在每个模块的最后添加了一个无激活函数的 $1 \\times 1$ 卷积来扩展通道数：\n$$ \\mathbf{Y} = \\mathbf{X} + W_{1 \\times 1} \\cdot \\text{InceptionBranches}(\\mathbf{X}) $$\n3.3 残差缩放：训练极深网络的关键 当尝试训练非常深的 Inception-ResNet 时，研究者发现了一个有趣的现象：当滤波器数量超过1000时，训练变得不稳定。具体表现为：在训练进行几万次迭代后，最后一层平均池化前的输出会突然变成零，网络停止学习。\n令人惊讶的是，降低学习率或增加额外的批归一化都无法解决这个问题。这表明问题的根源不是梯度消失或爆炸，而是残差幅度的累积。\n论文提出的解决方案是残差缩放（Residual Scaling）：在对残差进行相加之前，先将其缩小一个系数。\n数学上，标准的残差块为：\n$$ \\mathbf{Y} = \\mathbf{X} + \\mathcal{F}(\\mathbf{X}) $$\n而带缩放的残差块为：\n$$ \\mathbf{Y} = \\mathbf{X} + \\alpha \\cdot \\mathcal{F}(\\mathbf{X}) $$\n其中 $\\alpha$ 是缩放系数，论文中使用的范围在 $0.1$ 到 $0.3$ 之间。\n图：残差缩放对训练稳定性的影响对比，展示了缩放如何防止训练过程中的震荡发散\n这种缩放的直觉解释是：当网络很深时，多个残差块的输出可能会累积成一个很大的值。通过缩小每个残差的贡献，可以防止这种累积效应导致的数值不稳定。\n值得注意的是，残差缩放并不会降低最终的准确率，只是让训练过程更加稳定。这与 ResNet 中使用的\"预热训练\"（warm-up）策略相比，是一种更直接、更可靠的解决方案。\n第四章：实验结果与分析 4.1 ImageNet 分类性能 论文在 ImageNet 2012 分类数据集上进行了全面的实验评估。以下是各模型的 Top-5 错误率对比：\n模型 Top-5 错误率 (单模型) Top-5 错误率 (多模型集成) Inception-v3 5.6% 3.5% Inception-v4 3.7% 3.08% Inception-ResNet-v1 4.3% - Inception-ResNet-v2 3.7% 3.08% 从结果可以看出几个重要趋势：\nInception-v4 相比 Inception-v3 有显著提升，Top-5 错误率从 5.6% 降至 3.7% Inception-ResNet-v2 与 Inception-v4 性能相当，但训练速度更快 残差连接的训练加速效果明显：Inception-ResNet-v1 与 Inception-v3 参数量相当，但收敛更快 4.2 训练速度对比 图：不同 Inception 变体的训练过程对比，展示了残差连接对收敛速度的加速作用\n从训练曲线可以看出：\n残差连接显著加速训练：Inception-ResNet 系列比对应的非残差版本收敛更快 深层网络的优势：Inception-v4 和 Inception-ResNet-v2 虽然参数更多，但最终性能更好 收敛稳定性：所有模型都能稳定收敛，说明架构设计是合理的 论文中给出的具体数据是：Inception-ResNet-v1 达到 Inception-v3 最终准确率所需的时间，大约只有后者的 一半。这意味着在相同的计算预算下，使用残差连接可以训练更多轮次，或者使用更大的模型。\n4.3 模型集成效果 当使用模型集成（model ensemble）时，Inception-v4 和 Inception-ResNet-v2 的组合取得了当时最好的结果：\n3 个 Inception-ResNet-v2 + 1 个 Inception-v4 的集成 Top-5 错误率：3.08% Top-1 错误率：17.5% 这个结果在 2016 年初是非常出色的，展示了 Inception 架构的强大潜力。\n第五章：深入理解 Inception 设计 5.1 多尺度特征提取的数学本质 Inception 模块的核心是多尺度特征提取。从数学角度看，这相当于在多个尺度上应用卷积操作，然后组合结果。\n设输入特征图为 $\\mathbf{X} \\in \\mathbb{R}^{H \\times W \\times C}$，一个 Inception 模块可以表示为：\n$$ \\mathbf{Y} = \\text{concat}\\left(\\mathbf{Y}^{(1)}, \\mathbf{Y}^{(2)}, \\mathbf{Y}^{(3)}, \\mathbf{Y}^{(4)}\\right) $$\n其中：\n$$ \\begin{aligned} \\mathbf{Y}^{(1)} \u0026= W^{(1)} \\ast \\mathbf{X} \\ \\mathbf{Y}^{(2)} \u0026= W^{(3 \\times 3)} \\ast \\sigma(W^{(1 \\times 1)}{(2)} \\ast \\mathbf{X}) \\ \\mathbf{Y}^{(3)} \u0026= W^{(5 \\times 5)} \\ast \\sigma(W^{(1 \\times 1)}{(3)} \\ast \\mathbf{X}) \\ \\mathbf{Y}^{(4)} \u0026= W^{(1 \\times 1)}_{(4)} \\ast \\text{Pool}(\\mathbf{X}) \\end{aligned} $$\n这种设计的优势在于：\n多尺度表示：不同分支捕获不同尺度的特征 计算效率：通过 $1 \\times 1$ 卷积降维，控制计算量 表达能力：网络可以学习每种尺度的最优权重 5.2 通道拼接 vs 逐元素相加 Inception（通道拼接）和 ResNet（逐元素相加）代表了两种不同的特征融合策略。\n通道拼接（Concatenation）：\n保留所有分支的完整信息 输出通道数随分支数增加 计算量随通道数线性增长 逐元素相加（Element-wise Addition）：\n融合信息，可能损失部分细节 输出通道数不变 更紧凑的表示 Inception-ResNet 的尝试表明，对于 Inception 模块，逐元素相加是一种可行的替代方案。两者的主要区别在于：\nInception-v4：更丰富的特征表示，适合提取多尺度信息 Inception-ResNet：更高效的特征复用，适合深层网络训练 5.3 残差连接的梯度流动分析 让我们从数学上分析残差连接如何改善梯度流动。考虑一个简单的 $L$ 层残差网络：\n$$ \\mathbf{x}_{l+1} = \\mathbf{x}_l + \\mathcal{F}(\\mathbf{x}_l, W_l) $$\n通过递归展开，第 $L$ 层的输出可以表示为：\n$$ \\mathbf{x}_L = \\mathbf{x}l + \\sum{i=l}^{L-1} \\mathcal{F}(\\mathbf{x}_i, W_i) $$\n现在考虑反向传播。损失函数 $\\mathcal{L}$ 对第 $l$ 层输入的梯度为：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{x}_l} = \\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{x}_L} \\cdot \\frac{\\partial \\mathbf{x}_L}{\\partial \\mathbf{x}_l} $$\n由于 $\\mathbf{x}_L = \\mathbf{x}l + \\sum{i=l}^{L-1} \\mathcal{F}(\\mathbf{x}_i, W_i)$，我们有：\n$$ \\frac{\\partial \\mathbf{x}_L}{\\partial \\mathbf{x}_l} = I + \\frac{\\partial}{\\partial \\mathbf{x}l} \\sum{i=l}^{L-1} \\mathcal{F}(\\mathbf{x}_i, W_i) $$\n因此：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{x}_l} = \\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{x}_L} + \\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{x}_L} \\cdot \\frac{\\partial}{\\partial \\mathbf{x}l} \\sum{i=l}^{L-1} \\mathcal{F}(\\mathbf{x}_i, W_i) $$\n这个分解揭示了残差连接的关键作用：梯度可以直接从深层流向浅层（第一项），而不需要经过中间层的复杂变换。这创建了一条梯度传播的\"高速公路\"，有效缓解了梯度消失问题。\n5.4 Inception-ResNet 的集成学习视角 2016年，Veit 等人的一篇论文《Residual Networks Behave Like Ensembles of Relatively Shallow Networks》提出了一个有趣的视角：残差网络实际上是一个指数级大小的隐式集成模型。\n考虑一个3层的 Inception-ResNet，其展开形式为：\n$$ \\mathbf{x}_3 = \\mathbf{x}_0 + \\mathcal{F}_1(\\mathbf{x}_0) + \\mathcal{F}_2(\\mathbf{x}_1) + \\mathcal{F}_3(\\mathbf{x}_2) $$\n如果每个残差块可以选择\"使用\"或\"不使用\"，那么 $n$ 个残差块可以产生 $2^n$ 条不同的路径。这解释了为什么删除 ResNet 中的某些层对性能影响很小——网络有其他路径可以补偿。\n对于 Inception-ResNet，这种效应更加明显，因为每个 Inception 模块内部还有多个分支。这意味着 Inception-ResNet 不仅是一个深层的网络，还是一个多路径的集成系统。\n第六章：架构设计的启示 6.1 模块化的力量 Inception-v4 的一个重要启示是模块化设计的力量。通过将网络分解为清晰的模块（Stem、Inception-A/B/C、Reduction），研究者可以：\n独立优化每个模块：针对不同阶段的特征图尺寸优化计算效率 快速实验：可以替换或修改单个模块而不影响整体架构 更好的可解释性：每个模块的职责清晰，便于理解网络行为 这种模块化思想在后续的神经网络设计中被广泛采用，如 EfficientNet 的复合缩放策略、RegNet 的设计空间探索等。\n6.2 计算效率与准确率的权衡 Inception 系列的核心设计目标之一是计算效率。通过以下技巧，Inception-v4 在保持高准确率的同时控制了计算量：\n$1 \\times 1$ 卷积降维：在进入大卷积核之前减少通道数 非对称分解：用 $n \\times 1$ 和 $1 \\times n$ 替代 $n \\times n$ 卷积 并行下采样：池化和卷积同时进行，充分利用计算 这些技巧背后有一个共同的数学原理：卷积操作的计算复杂度与卷积核大小的平方成正比，但通过合理的分解和降维，可以在保持表达能力的同时大幅降低计算量。\n6.3 残差连接的正则化效应 残差缩放技术的发现揭示了一个重要现象：深层网络的训练不仅受梯度流动影响，还受残差幅度的数值稳定性制约。\n残差缩放的数学本质是引入了一个可调节的超参数 $\\alpha$，控制残差对最终输出的贡献程度。这实际上是一种软正则化：\n$$ \\mathbf{Y} = \\mathbf{X} + \\alpha \\cdot \\mathcal{F}(\\mathbf{X}) $$\n当 $\\alpha$ 较小时，网络更倾向于使用恒等映射，相当于对残差函数的复杂度进行了惩罚。这种正则化帮助网络在深度和稳定性之间找到平衡。\n第七章：Inception 的后续影响 7.1 在目标检测中的应用 Inception-v4 和 Inception-ResNet 不仅在图像分类中表现出色，还被广泛应用于目标检测任务。\nFaster R-CNN with Inception-ResNet：将 Inception-ResNet 作为骨干网络（backbone）替换 VGG-16，在 MS COCO 数据集上取得了显著的性能提升。\nSSD（Single Shot MultiBox Detector）：使用 Inception 模块作为特征提取层，实现了高效的多尺度目标检测。\n这些应用证明了 Inception 架构提取的多尺度特征对于定位不同大小的目标非常有效。\n7.2 对后续架构的启发 Inception-v4 和 Inception-ResNet 的设计理念影响了后续的许多网络架构：\nXception：将 Inception 的思想推向极致，使用深度可分离卷积（depthwise separable convolution）替代标准卷积。这可以看作是 Inception 模块的极端形式：每个通道独立进行空间卷积，然后用 $1 \\times 1$ 卷积组合。\nMobileNet：为了在移动设备上高效运行，MobileNet 采用了类似的分解策略，将标准卷积分解为 depthwise 卷积和 pointwise 卷积。\nEfficientNet：结合 Inception 的多尺度思想和复合缩放策略，通过统一缩放网络的深度、宽度和分辨率，在计算效率和准确率之间取得了新的平衡。\n7.3 从手工设计到自动搜索 Inception 系列代表了深度学习的一个重要阶段：手工设计的网络架构。研究者基于对卷积神经网络的深入理解，精心设计了 Inception 模块的各种变体。\n然而，2017年后，自动架构搜索（NAS）开始兴起。Google 的 NASNet 使用强化学习自动搜索最优的网络结构，发现了许多与手工设计相似的架构单元（如类似于 Inception 的多分支结构）。\n这引出了一个有趣的思考：人类设计者的直觉与自动搜索算法找到的解决方案之间存在怎样的关系？\n事实上，NAS 发现的许多最优单元与 Inception 模块有着惊人的相似之处——多分支、不同尺度的卷积、降维策略等。这验证了 Inception 设计者的直觉是正确的，同时也展示了自动搜索在探索更大设计空间方面的优势。\n结语 Inception-v4 和 Inception-ResNet 的论文是深度学习发展史上的一个重要里程碑。它不仅是 Inception 系列的集大成之作，更开创性地将两种不同的设计哲学——Inception 的多尺度特征提取和 ResNet 的残差学习——融合在了一起。\n回顾这篇论文的核心贡献：\n更简洁统一的架构：通过模块化的 Stem、Inception、Reduction 设计，创造了更清晰、更易于扩展的网络结构 残差连接与 Inception 的融合：证明了残差连接不仅适用于简单的堆叠架构，也能与复杂的 Inception 模块有效结合 残差缩放技术：发现了训练极深网络时的数值稳定性问题，并提出了有效的解决方案 计算效率的持续优化：通过非对称分解等技巧，在保持准确率的同时控制了计算量 Inception-v4 的成功告诉我们：好的架构设计需要深入理解数据的本质和计算的特性。图像数据具有多尺度的特点，因此需要多尺度的特征提取；深度网络的训练需要稳定的梯度流动，因此需要残差连接；实际应用需要高效的计算，因此需要精心的卷积分解。\n从 2014 年的 Inception-v1 到 2016 年的 Inception-v4，再到后来的 Xception、MobileNet、EfficientNet，我们可以看到一条清晰的发展脉络：对卷积运算本质的不断深入理解，推动着网络架构的持续演进。\n今天，虽然 Transformer 架构在计算机视觉领域（如 ViT、Swin Transformer）取得了显著进展，但 Inception 的设计理念——多尺度特征提取、计算效率优化、模块化设计——仍然具有重要的参考价值。理解 Inception-v4，不仅是对一篇经典论文的回顾，更是对深度学习架构设计思想的一次深入探索。\n参考文献 Szegedy, C., Ioffe, S., Vanhoucke, V., \u0026 Alemi, A. (2016). “Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning.” AAAI Conference on Artificial Intelligence, 31(1).\nSzegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S., Anguelov, D., … \u0026 Rabinovich, A. (2015). “Going Deeper with Convolutions.” Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 1-9.\nSzegedy, C., Vanhoucke, V., Ioffe, S., Shlens, J., \u0026 Wojna, Z. (2016). “Rethinking the Inception Architecture for Computer Vision.” Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2818-2826.\nHe, K., Zhang, X., Ren, S., \u0026 Sun, J. (2016). “Deep Residual Learning for Image Recognition.” Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 770-778.\nChollet, F. (2017). “Xception: Deep Learning with Depthwise Separable Convolutions.” Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 1251-1258.\nHoward, A. G., Zhu, M., Chen, B., Kalenichenko, D., Wang, W., Weyand, T., … \u0026 Adam, H. (2017). “MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications.” arXiv preprint arXiv:1704.04861.\nTan, M., \u0026 Le, Q. (2019). “EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks.” International Conference on Machine Learning (ICML), 6105-6114.\nVeit, A., Wilber, M. J., \u0026 Belongie, S. (2016). “Residual Networks Behave Like Ensembles of Relatively Shallow Networks.” Advances in Neural Information Processing Systems (NeurIPS), 29.\n","wordCount":"1455","inLanguage":"en","image":"https://s-ai-unix.github.io/images/covers/inception-v4-cover.jpg","datePublished":"2026-01-30T12:30:00+08:00","dateModified":"2026-01-30T12:30:00+08:00","author":{"@type":"Person","name":"s-ai-unix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://s-ai-unix.github.io/posts/2026-01-30-ai-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97-inception-v4-going-deeper-with-convolutions/"},"publisher":{"@type":"Organization","name":"s-ai-unix's Blog","logo":{"@type":"ImageObject","url":"https://s-ai-unix.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://s-ai-unix.github.io/css/classical-quote.css></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://s-ai-unix.github.io/ accesskey=h title="s-ai-unix's Blog (Alt + H)">s-ai-unix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s-ai-unix.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://s-ai-unix.github.io/posts/ title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://s-ai-unix.github.io/archives/ title="📁 归档"><span>📁 归档</span></a></li><li><a href=https://s-ai-unix.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://s-ai-unix.github.io/search/ title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://s-ai-unix.github.io/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://s-ai-unix.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://s-ai-unix.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions</h1><div class=post-description>深入解读 Google 的 Inception-v4 论文，从 Inception 系列的演进历程出发，剖析 Inception-v4 的架构设计思想、多尺度特征提取原理，以及 Inception-ResNet 如何将残差连接与 Inception 模块融合，创造当时最强图像分类网络。</div><div class=post-meta><span title='2026-01-30 12:30:00 +0800 CST'>January 30, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1455 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></div></header><figure class=entry-cover><a href=https://s-ai-unix.github.io/images/covers/inception-v4-cover.jpg target=_blank rel="noopener noreferrer"><img loading=eager src=https://s-ai-unix.github.io/images/covers/inception-v4-cover.jpg alt="AI 论文解读系列 Inception-v4 Going Deeper with Convolutions"></a><figcaption>AI 论文解读系列 Inception-v4 - Cover Image</figcaption></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#ai-%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb%e7%b3%bb%e5%88%97inception-v4---going-deeper-with-convolutions aria-label="AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions">AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions</a><ul><li><a href=#%e5%bc%95%e8%a8%80 aria-label=引言>引言</a></li><li><a href=#%e7%ac%ac%e4%b8%80%e7%ab%a0inception-%e7%9a%84%e6%bc%94%e8%bf%9b%e4%b9%8b%e8%b7%af aria-label="第一章：Inception 的演进之路">第一章：Inception 的演进之路</a><ul><li><a href=#11-inception-v1%e5%a4%9a%e5%b0%ba%e5%ba%a6%e7%89%b9%e5%be%81%e6%8f%90%e5%8f%96%e7%9a%84%e5%bc%80%e5%88%9b aria-label="1.1 Inception-v1：多尺度特征提取的开创">1.1 Inception-v1：多尺度特征提取的开创</a></li><li><a href=#12-inception-v2v3%e5%8d%b7%e7%a7%af%e5%88%86%e8%a7%a3%e7%9a%84%e8%89%ba%e6%9c%af aria-label="1.2 Inception-v2/v3：卷积分解的艺术">1.2 Inception-v2/v3：卷积分解的艺术</a></li><li><a href=#13-%e8%ae%ad%e7%bb%83%e6%a1%86%e6%9e%b6%e7%9a%84%e5%8f%98%e9%9d%a9%e4%b8%8e-inception-v4-%e7%9a%84%e5%a5%91%e6%9c%ba aria-label="1.3 训练框架的变革与 Inception-v4 的契机">1.3 训练框架的变革与 Inception-v4 的契机</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e7%ab%a0inception-v4-%e6%9e%b6%e6%9e%84%e8%af%a6%e8%a7%a3 aria-label="第二章：Inception-v4 架构详解">第二章：Inception-v4 架构详解</a><ul><li><a href=#21-%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84%e6%a6%82%e8%a7%88 aria-label="2.1 整体架构概览">2.1 整体架构概览</a></li><li><a href=#22-stem-%e6%a8%a1%e5%9d%97%e9%ab%98%e6%95%88%e7%9a%84%e5%88%9d%e5%a7%8b%e5%a4%84%e7%90%86 aria-label="2.2 Stem 模块：高效的初始处理">2.2 Stem 模块：高效的初始处理</a></li><li><a href=#23-inception-abc-%e6%a8%a1%e5%9d%97%e5%88%86%e8%80%8c%e6%b2%bb%e4%b9%8b%e7%9a%84%e7%89%b9%e5%be%81%e6%8f%90%e5%8f%96 aria-label="2.3 Inception-A/B/C 模块：分而治之的特征提取">2.3 Inception-A/B/C 模块：分而治之的特征提取</a></li><li><a href=#24-reduction-%e6%a8%a1%e5%9d%97%e4%bc%98%e9%9b%85%e7%9a%84%e4%b8%8b%e9%87%87%e6%a0%b7 aria-label="2.4 Reduction 模块：优雅的下采样">2.4 Reduction 模块：优雅的下采样</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e7%ab%a0inception-resnet%e5%bd%93-inception-%e9%81%87%e8%a7%81%e6%ae%8b%e5%b7%ae aria-label="第三章：Inception-ResNet：当 Inception 遇见残差">第三章：Inception-ResNet：当 Inception 遇见残差</a><ul><li><a href=#31-%e5%8a%a8%e6%9c%ba%e8%9e%8d%e5%90%88%e4%b8%a4%e7%a7%8d%e8%ae%be%e8%ae%a1%e5%93%b2%e5%ad%a6 aria-label="3.1 动机：融合两种设计哲学">3.1 动机：融合两种设计哲学</a></li><li><a href=#32-inception-resnet-v1-%e4%b8%8e-v2 aria-label="3.2 Inception-ResNet-v1 与 v2">3.2 Inception-ResNet-v1 与 v2</a></li><li><a href=#33-%e6%ae%8b%e5%b7%ae%e7%bc%a9%e6%94%be%e8%ae%ad%e7%bb%83%e6%9e%81%e6%b7%b1%e7%bd%91%e7%bb%9c%e7%9a%84%e5%85%b3%e9%94%ae aria-label="3.3 残差缩放：训练极深网络的关键">3.3 残差缩放：训练极深网络的关键</a></li></ul></li><li><a href=#%e7%ac%ac%e5%9b%9b%e7%ab%a0%e5%ae%9e%e9%aa%8c%e7%bb%93%e6%9e%9c%e4%b8%8e%e5%88%86%e6%9e%90 aria-label=第四章：实验结果与分析>第四章：实验结果与分析</a><ul><li><a href=#41-imagenet-%e5%88%86%e7%b1%bb%e6%80%a7%e8%83%bd aria-label="4.1 ImageNet 分类性能">4.1 ImageNet 分类性能</a></li><li><a href=#42-%e8%ae%ad%e7%bb%83%e9%80%9f%e5%ba%a6%e5%af%b9%e6%af%94 aria-label="4.2 训练速度对比">4.2 训练速度对比</a></li><li><a href=#43-%e6%a8%a1%e5%9e%8b%e9%9b%86%e6%88%90%e6%95%88%e6%9e%9c aria-label="4.3 模型集成效果">4.3 模型集成效果</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%94%e7%ab%a0%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3-inception-%e8%ae%be%e8%ae%a1 aria-label="第五章：深入理解 Inception 设计">第五章：深入理解 Inception 设计</a><ul><li><a href=#51-%e5%a4%9a%e5%b0%ba%e5%ba%a6%e7%89%b9%e5%be%81%e6%8f%90%e5%8f%96%e7%9a%84%e6%95%b0%e5%ad%a6%e6%9c%ac%e8%b4%a8 aria-label="5.1 多尺度特征提取的数学本质">5.1 多尺度特征提取的数学本质</a></li><li><a href=#52-%e9%80%9a%e9%81%93%e6%8b%bc%e6%8e%a5-vs-%e9%80%90%e5%85%83%e7%b4%a0%e7%9b%b8%e5%8a%a0 aria-label="5.2 通道拼接 vs 逐元素相加">5.2 通道拼接 vs 逐元素相加</a></li><li><a href=#53-%e6%ae%8b%e5%b7%ae%e8%bf%9e%e6%8e%a5%e7%9a%84%e6%a2%af%e5%ba%a6%e6%b5%81%e5%8a%a8%e5%88%86%e6%9e%90 aria-label="5.3 残差连接的梯度流动分析">5.3 残差连接的梯度流动分析</a></li><li><a href=#54-inception-resnet-%e7%9a%84%e9%9b%86%e6%88%90%e5%ad%a6%e4%b9%a0%e8%a7%86%e8%a7%92 aria-label="5.4 Inception-ResNet 的集成学习视角">5.4 Inception-ResNet 的集成学习视角</a></li></ul></li><li><a href=#%e7%ac%ac%e5%85%ad%e7%ab%a0%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1%e7%9a%84%e5%90%af%e7%a4%ba aria-label=第六章：架构设计的启示>第六章：架构设计的启示</a><ul><li><a href=#61-%e6%a8%a1%e5%9d%97%e5%8c%96%e7%9a%84%e5%8a%9b%e9%87%8f aria-label="6.1 模块化的力量">6.1 模块化的力量</a></li><li><a href=#62-%e8%ae%a1%e7%ae%97%e6%95%88%e7%8e%87%e4%b8%8e%e5%87%86%e7%a1%ae%e7%8e%87%e7%9a%84%e6%9d%83%e8%a1%a1 aria-label="6.2 计算效率与准确率的权衡">6.2 计算效率与准确率的权衡</a></li><li><a href=#63-%e6%ae%8b%e5%b7%ae%e8%bf%9e%e6%8e%a5%e7%9a%84%e6%ad%a3%e5%88%99%e5%8c%96%e6%95%88%e5%ba%94 aria-label="6.3 残差连接的正则化效应">6.3 残差连接的正则化效应</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%83%e7%ab%a0inception-%e7%9a%84%e5%90%8e%e7%bb%ad%e5%bd%b1%e5%93%8d aria-label="第七章：Inception 的后续影响">第七章：Inception 的后续影响</a><ul><li><a href=#71-%e5%9c%a8%e7%9b%ae%e6%a0%87%e6%a3%80%e6%b5%8b%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="7.1 在目标检测中的应用">7.1 在目标检测中的应用</a></li><li><a href=#72-%e5%af%b9%e5%90%8e%e7%bb%ad%e6%9e%b6%e6%9e%84%e7%9a%84%e5%90%af%e5%8f%91 aria-label="7.2 对后续架构的启发">7.2 对后续架构的启发</a></li><li><a href=#73-%e4%bb%8e%e6%89%8b%e5%b7%a5%e8%ae%be%e8%ae%a1%e5%88%b0%e8%87%aa%e5%8a%a8%e6%90%9c%e7%b4%a2 aria-label="7.3 从手工设计到自动搜索">7.3 从手工设计到自动搜索</a></li></ul></li><li><a href=#%e7%bb%93%e8%af%ad aria-label=结语>结语</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae aria-label=参考文献>参考文献</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=ai-论文解读系列inception-v4---going-deeper-with-convolutions>AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions<a hidden class=anchor aria-hidden=true href=#ai-论文解读系列inception-v4---going-deeper-with-convolutions>#</a></h1><h2 id=引言>引言<a hidden class=anchor aria-hidden=true href=#引言>#</a></h2><p>2016年2月，Google 的 Christian Szegedy 等人在 arXiv 上发表了一篇名为《Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning》的论文。这篇论文不仅是 Inception 系列发展的重要里程碑，更提出了一种革命性的思路：<strong>将 Inception 的多尺度特征提取能力与 ResNet 的残差连接相结合</strong>。</p><p>让我们先回顾一下当时的背景。2015年，ResNet 横空出世，用简单的跳跃连接解决了深层网络的退化问题，将网络深度推向了一百层甚至上千层。与此同时，Inception-v3 以其独特的多分支结构，在计算效率和准确率之间取得了优异的平衡。一个自然的问题浮现出来：**这两种看似迥异的设计哲学能否融合？**如果能将 Inception 的高效特征提取与残差连接的优化优势结合起来，会发生什么？</p><p>本文将系统性地解读这篇经典论文，从 Inception 系列的演进脉络出发，深入剖析 Inception-v4 的架构设计原理，探讨 Inception-ResNet 的创新之处，以及残差缩放这一关键技术的数学本质。</p><p><img alt="Inception 系列演进与 ImageNet Top-5 错误率" loading=lazy src=/images/plots/inception-evolution.png></p><p class=caption>图：Inception 系列演进历程与 ImageNet 竞赛 Top-5 错误率变化趋势</p><h2 id=第一章inception-的演进之路>第一章：Inception 的演进之路<a hidden class=anchor aria-hidden=true href=#第一章inception-的演进之路>#</a></h2><h3 id=11-inception-v1多尺度特征提取的开创>1.1 Inception-v1：多尺度特征提取的开创<a hidden class=anchor aria-hidden=true href=#11-inception-v1多尺度特征提取的开创>#</a></h3><p>要理解 Inception-v4，我们需要先回到2014年的 Inception-v1（GoogLeNet）。当时，深度学习领域的主流思路是"越深越好"——AlexNet 有8层，VGGNet 堆到了19层。但 Google 的研究者们提出了一个不同的观点：<strong>与其简单地堆叠相同的层，不如让网络自己选择如何组合不同尺度的特征</strong>。</p><p>Inception 模块的核心思想可以用一个简单的问题来概括：当我们观察一张图像时，我们究竟需要多大的感受野？</p><ul><li>识别一只猫的脸，可能只需要一个 $3 \times 3$ 的区域就能看清它的眼睛和鼻子</li><li>但要判断这是一只完整卧着的猫，可能需要一个 $5 \times 5$ 的区域来捕捉整体轮廓</li><li>而对于更宏观的场景理解，甚至需要更大的视野</li></ul><p>Inception 模块的解决方案是<strong>并行使用不同大小的卷积核</strong>，让网络自己学习每种尺度的权重。一个典型的 Inception 模块包含四个分支：</p><ol><li>$1 \times 1$ 卷积：捕捉局部特征，同时降维</li><li>$1 \times 1$ 卷积后接 $3 \times 3$ 卷积：中等尺度的特征</li><li>$1 \times 1$ 卷积后接 $5 \times 5$ 卷积：大尺度的特征</li><li>$3 \times 3$ 最大池化后接 $1 \times 1$ 卷积：保留显著特征</li></ol><p>这四个分支的输出在通道维度上拼接（concatenate），形成下一层的输入。这种设计让网络能够<strong>自适应地选择最优的特征尺度</strong>。</p><h3 id=12-inception-v2v3卷积分解的艺术>1.2 Inception-v2/v3：卷积分解的艺术<a hidden class=anchor aria-hidden=true href=#12-inception-v2v3卷积分解的艺术>#</a></h3><p>2015年，Szegedy 等人发表了《Rethinking the Inception Architecture for Computer Vision》，提出了 Inception-v2 和 Inception-v3。这篇论文的核心贡献是<strong>卷积核的因式分解（Factorization）</strong>。</p><p>研究发现，大卷积核可以用一系列小卷积核来替代，而不会损失表达能力。具体来说：</p><p><strong>空间分解</strong>：一个 $5 \times 5$ 的卷积核可以用两个 $3 \times 3$ 的卷积核串联来替代。</p><p>从数学上看，设输入特征图为 $\mathbf{X}$，$5 \times 5$ 卷积的输出为：</p><p>$$
\mathbf{Y} = W_{5 \times 5} \ast \mathbf{X}
$$</p><p>其中 $W_{5 \times 5}$ 有 $5 \times 5 \times C_{in} \times C_{out}$ 个参数。</p><p>而两个 $3 \times 3$ 卷积的级联为：</p><p>$$
\mathbf{Y}&rsquo; = W_{3 \times 3}^{(2)} \ast \sigma(W_{3 \times 3}^{(1)} \ast \mathbf{X})
$$</p><p>参数数量为 $2 \times 3 \times 3 \times C_{in} \times C_{out}$（假设中间通道数相同）。</p><p>参数比为：</p><p>$$
\frac{2 \times 3^2}{5^2} = \frac{18}{25} = 0.72
$$</p><p>这意味着在保持相似表达能力的同时，参数量减少了28%。</p><p><strong>非对称分解</strong>：更进一步，$n \times n$ 的卷积可以分解为 $n \times 1$ 后跟 $1 \times n$。</p><p><img alt=卷积核非对称分解 loading=lazy src=/images/plots/filter-factorization.png></p><p class=caption>图：卷积核非对称分解示意图，$5 \times 5$ 卷积可分解为 $5 \times 1$ 和 $1 \times 5$ 两个卷积，参数从25减少到10</p><p>这种分解在计算上的优势非常明显。对于 $5 \times 5$ 的卷积核：</p><ul><li>直接计算：每个输出位置需要 $5 \times 5 = 25$ 次乘法</li><li>分解后：先 $5 \times 1$ 需要 $5$ 次，再 $1 \times 5$ 需要 $5$ 次，共 $10$ 次</li></ul><p>计算量减少了60%，这是一个非常可观的效率提升。</p><h3 id=13-训练框架的变革与-inception-v4-的契机>1.3 训练框架的变革与 Inception-v4 的契机<a hidden class=anchor aria-hidden=true href=#13-训练框架的变革与-inception-v4-的契机>#</a></h3><p>在 Inception-v3 的开发过程中，Google 的研究团队受限于当时的训练框架（DistBelief）。Szegedy 在论文中坦言，这种限制使得他们在实验中对模型架构的修改变得保守，导致 Inception-v3 的结构显得有些复杂和不规则。</p><p>2015年底，Google 推出了 TensorFlow。新的框架消除了之前的许多限制，使得研究者能够更自由地探索网络架构。这为 Inception-v4 的诞生创造了条件：<strong>使用更统一、更模块化的方式来设计网络</strong>。</p><h2 id=第二章inception-v4-架构详解>第二章：Inception-v4 架构详解<a hidden class=anchor aria-hidden=true href=#第二章inception-v4-架构详解>#</a></h2><h3 id=21-整体架构概览>2.1 整体架构概览<a hidden class=anchor aria-hidden=true href=#21-整体架构概览>#</a></h3><p>Inception-v4 的设计理念是<strong>清晰的分阶段处理</strong>。整个网络可以看作是一条从输入到输出的流水线，每个阶段负责特定粒度的特征提取。</p><p><img alt="Inception-v4 整体架构流程" loading=lazy src=/images/plots/inception-v4-architecture.png></p><p class=caption>图：Inception-v4 整体架构流程，展示了从输入到输出的各阶段特征图尺寸变化</p><p>如上图所示，Inception-v4 包含以下主要组件：</p><ol><li><strong>Stem</strong>：初始特征提取，将 $299 \times 299 \times 3$ 的输入转换为 $35 \times 35 \times 384$</li><li><strong>Inception-A 模块</strong>（4个）：处理 $35 \times 35$ 的特征图</li><li><strong>Reduction-A</strong>：将特征图从 $35 \times 35$ 下采样到 $17 \times 17$</li><li><strong>Inception-B 模块</strong>（7个）：处理 $17 \times 17$ 的特征图</li><li><strong>Reduction-B</strong>：将特征图从 $17 \times 17$ 下采样到 $8 \times 8$</li><li><strong>Inception-C 模块</strong>（3个）：处理 $8 \times 8$ 的特征图</li><li><strong>全局平均池化、Dropout、全连接层</strong>：分类输出</li></ol><p>这种分阶段设计的一个重要特点是：<strong>不同阶段的 Inception 模块针对不同的特征图尺寸进行了专门优化</strong>。</p><h3 id=22-stem-模块高效的初始处理>2.2 Stem 模块：高效的初始处理<a hidden class=anchor aria-hidden=true href=#22-stem-模块高效的初始处理>#</a></h3><p>Stem 模块是 Inception-v4 的第一个创新点。它的任务是在进入核心 Inception 模块之前，快速降低空间维度并提取初始特征。</p><p>Inception-v4 的 Stem 包含以下步骤：</p><ol><li>$3 \times 3$ 卷积，步长2（valid padding），输出 $149 \times 149 \times 32$</li><li>$3 \times 3$ 卷积，输出 $147 \times 147 \times 32$</li><li>$3 \times 3$ 卷积，输出 $147 \times 147 \times 64$</li><li>池化分支：$3 \times 3$ 最大池化，步长2，输出 $73 \times 73 \times 64$</li><li>卷积分支：$3 \times 3$ 卷积，步长2，输出 $73 \times 73 \times 96$</li><li>拼接两个分支，输出 $73 \times 73 \times 160$</li></ol><p>这种设计的一个关键技巧是<strong>并行使用池化和卷积进行下采样</strong>。传统的做法是先卷积再池化，或者反过来。而 Inception-v4 让两者同时进行，然后将结果拼接。这样做的优势在于：</p><ul><li>卷积分支保留了更多语义信息</li><li>池化分支保留了最显著的特征响应</li><li>两者的组合提供了更丰富的特征表示</li></ul><h3 id=23-inception-abc-模块分而治之的特征提取>2.3 Inception-A/B/C 模块：分而治之的特征提取<a hidden class=anchor aria-hidden=true href=#23-inception-abc-模块分而治之的特征提取>#</a></h3><p>Inception-v4 使用了三种不同的 Inception 模块，分别针对不同尺寸的特征图进行优化。</p><p><img alt="Inception 模块多分支结构对比" loading=lazy src=/images/plots/inception-modules.png></p><p class=caption>图：Inception-A、Inception-B、Inception-C 三种模块的多分支结构对比</p><p><strong>Inception-A 模块</strong>（用于 $35 \times 35$ 的特征图）：</p><p>这个阶段的特征图尺寸较大，空间信息丰富。Inception-A 包含四个分支：</p><ul><li>分支1：$1 \times 1$ 卷积</li><li>分支2：$1 \times 1$ 卷积后接 $3 \times 3$ 卷积</li><li>分支3：$1 \times 1$ 卷积后接两个 $3 \times 3$ 卷积（等效于 $5 \times 5$）</li><li>分支4：$3 \times 3$ 平均池化后接 $1 \times 1$ 卷积</li></ul><p><strong>Inception-B 模块</strong>（用于 $17 \times 17$ 的特征图）：</p><p>当特征图缩小到 $17 \times 17$ 时，需要更大的感受野来捕捉上下文。Inception-B 引入了非对称卷积：</p><ul><li>分支1：$1 \times 1$ 卷积</li><li>分支2：$1 \times 1$ 卷积后接 $1 \times 7$ 再接 $7 \times 1$ 卷积</li><li>分支3：$1 \times 1$ 卷积后接 $7 \times 1$、$1 \times 7$、$7 \times 1$、$1 \times 7$ 四层卷积</li><li>分支4：$3 \times 3$ 平均池化后接 $1 \times 1$ 卷积</li></ul><p>这里的 $7 \times 1$ 和 $1 \times 7$ 就是前面提到的非对称分解。对于 $17 \times 17$ 的特征图，$7 \times 7$ 的感受野已经相当大，使用非对称分解可以大幅减少计算量。</p><p><strong>Inception-C 模块</strong>（用于 $8 \times 8$ 的特征图）：</p><p>在最后阶段，特征图已经很小（$8 \times 8$），但通道数很多（1536）。此时更关注细粒度的特征组合：</p><ul><li>分支1：$1 \times 1$ 卷积</li><li>分支2：$1 \times 1$ 卷积后接 $1 \times 3$ 和 $3 \times 1$ 卷积（并联）</li><li>分支3：$1 \times 1$ 卷积后接 $1 \times 3$ 再接 $3 \times 1$ 卷积，然后再次分解为 $1 \times 3$ 和 $3 \times 1$</li><li>分支4：$3 \times 3$ 平均池化后接 $1 \times 1$ 卷积</li></ul><p>这种嵌套的非对称分解可以捕捉更复杂的特征模式。</p><h3 id=24-reduction-模块优雅的下采样>2.4 Reduction 模块：优雅的下采样<a hidden class=anchor aria-hidden=true href=#24-reduction-模块优雅的下采样>#</a></h3><p>Inception-v4 的另一个创新是明确区分了<strong>特征提取模块</strong>（Inception-A/B/C）和<strong>下采样模块</strong>（Reduction-A/B）。</p><p>在早期的 Inception 版本中，下采样是通过在 Inception 模块中使用步长大于1的卷积来隐式实现的。而 Inception-v4 将下采样逻辑抽取出来，形成了专门的 Reduction 模块。</p><p><strong>Reduction-A</strong>（从 $35 \times 35$ 到 $17 \times 17$）：</p><ul><li>分支1：$3 \times 3$ 卷积，步长2</li><li>分支2：$1 \times 1$ 卷积后接 $3 \times 3$ 卷积，再接 $3 \times 3$ 卷积步长2</li><li>分支3：$3 \times 3$ 最大池化，步长2</li></ul><p>三个分支的输出拼接，通道数从 $k + l + m + n$（具体数值见论文表1）变为 $384$（Inception-v4）或 $384$（Inception-ResNet-v2）。</p><p>这种设计的好处是：</p><ul><li>模块职责更清晰，易于理解和修改</li><li>可以针对不同阶段的特性优化下采样策略</li><li>便于在实验中快速调整下采样位置</li></ul><h2 id=第三章inception-resnet当-inception-遇见残差>第三章：Inception-ResNet：当 Inception 遇见残差<a hidden class=anchor aria-hidden=true href=#第三章inception-resnet当-inception-遇见残差>#</a></h2><h3 id=31-动机融合两种设计哲学>3.1 动机：融合两种设计哲学<a hidden class=anchor aria-hidden=true href=#31-动机融合两种设计哲学>#</a></h3><p>2015年底，深度学习领域有两个最耀眼的明星：</p><ol><li><strong>ResNet</strong>：通过残差连接解决了深层网络的训练问题，将深度推向100+层</li><li><strong>Inception-v3</strong>：通过多尺度特征提取，在计算效率和准确率之间取得了优异平衡</li></ol><p>一个自然的问题是：**能否将两者的优势结合起来？**残差连接能否帮助 Inception 网络训练得更快、更深？</p><p>Inception-ResNet 的核心思想是<strong>用残差连接替代 Inception 模块中的特征拼接</strong>。在传统 Inception 中，多个分支的输出在通道维度上拼接：</p><p>$$
\mathbf{Y} = \text{concat}([\mathbf{Y}_1, \mathbf{Y}_2, \mathbf{Y}_3, \mathbf{Y}_4])
$$</p><p>而在 Inception-ResNet 中，多个分支的输出相加（逐元素相加）：</p><p>$$
\mathbf{Y} = \mathbf{X} + \sum_{i} \mathcal{F}_i(\mathbf{X})
$$</p><p>其中 $\mathcal{F}_i$ 表示第 $i$ 个分支的变换。</p><h3 id=32-inception-resnet-v1-与-v2>3.2 Inception-ResNet-v1 与 v2<a hidden class=anchor aria-hidden=true href=#32-inception-resnet-v1-与-v2>#</a></h3><p>论文提出了两个 Inception-ResNet 变体：</p><table><thead><tr><th>模型</th><th>参数量</th><th>计算复杂度</th><th>对应无残差版本</th></tr></thead><tbody><tr><td>Inception-ResNet-v1</td><td>约10M</td><td>与 Inception-v3 相当</td><td>Inception-v3</td></tr><tr><td>Inception-ResNet-v2</td><td>约55M</td><td>与 Inception-v4 相当</td><td>Inception-v4</td></tr></tbody></table><p>这种对应关系使得我们可以进行公平的对比实验：如果 Inception-ResNet-v1 比 Inception-v3 训练得更快，那就可以归因于残差连接的作用，而非网络容量差异。</p><p><strong>架构差异</strong>：</p><ul><li>Inception-ResNet-v1 使用简化的 Inception 模块</li><li>Inception-ResNet-v2 的 Stem 和 Inception-v4 相同，但 Inception 模块使用残差连接</li></ul><p><strong>维度匹配的关键设计</strong>：</p><p>由于 Inception 模块会压缩维度（通过 $1 \times 1$ 卷积），而残差连接要求输出与输入维度相同，因此 Inception-ResNet 在每个模块的最后添加了一个<strong>无激活函数的 $1 \times 1$ 卷积</strong>来扩展通道数：</p><p>$$
\mathbf{Y} = \mathbf{X} + W_{1 \times 1} \cdot \text{InceptionBranches}(\mathbf{X})
$$</p><h3 id=33-残差缩放训练极深网络的关键>3.3 残差缩放：训练极深网络的关键<a hidden class=anchor aria-hidden=true href=#33-残差缩放训练极深网络的关键>#</a></h3><p>当尝试训练非常深的 Inception-ResNet 时，研究者发现了一个有趣的现象：<strong>当滤波器数量超过1000时，训练变得不稳定</strong>。具体表现为：在训练进行几万次迭代后，最后一层平均池化前的输出会突然变成零，网络停止学习。</p><p>令人惊讶的是，降低学习率或增加额外的批归一化都无法解决这个问题。这表明问题的根源不是梯度消失或爆炸，而是<strong>残差幅度的累积</strong>。</p><p>论文提出的解决方案是<strong>残差缩放（Residual Scaling）</strong>：在对残差进行相加之前，先将其缩小一个系数。</p><p>数学上，标准的残差块为：</p><p>$$
\mathbf{Y} = \mathbf{X} + \mathcal{F}(\mathbf{X})
$$</p><p>而带缩放的残差块为：</p><p>$$
\mathbf{Y} = \mathbf{X} + \alpha \cdot \mathcal{F}(\mathbf{X})
$$</p><p>其中 $\alpha$ 是缩放系数，论文中使用的范围在 $0.1$ 到 $0.3$ 之间。</p><p><img alt=残差缩放对训练稳定性的影响 loading=lazy src=/images/plots/residual-scaling.png></p><p class=caption>图：残差缩放对训练稳定性的影响对比，展示了缩放如何防止训练过程中的震荡发散</p><p>这种缩放的直觉解释是：当网络很深时，多个残差块的输出可能会累积成一个很大的值。通过缩小每个残差的贡献，可以防止这种累积效应导致的数值不稳定。</p><p>值得注意的是，残差缩放并不会降低最终的准确率，只是让训练过程更加稳定。这与 ResNet 中使用的"预热训练"（warm-up）策略相比，是一种更直接、更可靠的解决方案。</p><h2 id=第四章实验结果与分析>第四章：实验结果与分析<a hidden class=anchor aria-hidden=true href=#第四章实验结果与分析>#</a></h2><h3 id=41-imagenet-分类性能>4.1 ImageNet 分类性能<a hidden class=anchor aria-hidden=true href=#41-imagenet-分类性能>#</a></h3><p>论文在 ImageNet 2012 分类数据集上进行了全面的实验评估。以下是各模型的 Top-5 错误率对比：</p><table><thead><tr><th>模型</th><th>Top-5 错误率 (单模型)</th><th>Top-5 错误率 (多模型集成)</th></tr></thead><tbody><tr><td>Inception-v3</td><td>5.6%</td><td>3.5%</td></tr><tr><td>Inception-v4</td><td>3.7%</td><td>3.08%</td></tr><tr><td>Inception-ResNet-v1</td><td>4.3%</td><td>-</td></tr><tr><td>Inception-ResNet-v2</td><td>3.7%</td><td>3.08%</td></tr></tbody></table><p>从结果可以看出几个重要趋势：</p><ol><li><strong>Inception-v4 相比 Inception-v3 有显著提升</strong>，Top-5 错误率从 5.6% 降至 3.7%</li><li><strong>Inception-ResNet-v2 与 Inception-v4 性能相当</strong>，但训练速度更快</li><li><strong>残差连接的训练加速效果明显</strong>：Inception-ResNet-v1 与 Inception-v3 参数量相当，但收敛更快</li></ol><h3 id=42-训练速度对比>4.2 训练速度对比<a hidden class=anchor aria-hidden=true href=#42-训练速度对比>#</a></h3><p><img alt=训练过程对比 loading=lazy src=/images/plots/inception-training-comparison.png></p><p class=caption>图：不同 Inception 变体的训练过程对比，展示了残差连接对收敛速度的加速作用</p><p>从训练曲线可以看出：</p><ul><li><strong>残差连接显著加速训练</strong>：Inception-ResNet 系列比对应的非残差版本收敛更快</li><li><strong>深层网络的优势</strong>：Inception-v4 和 Inception-ResNet-v2 虽然参数更多，但最终性能更好</li><li><strong>收敛稳定性</strong>：所有模型都能稳定收敛，说明架构设计是合理的</li></ul><p>论文中给出的具体数据是：Inception-ResNet-v1 达到 Inception-v3 最终准确率所需的时间，大约只有后者的 <strong>一半</strong>。这意味着在相同的计算预算下，使用残差连接可以训练更多轮次，或者使用更大的模型。</p><h3 id=43-模型集成效果>4.3 模型集成效果<a hidden class=anchor aria-hidden=true href=#43-模型集成效果>#</a></h3><p>当使用模型集成（model ensemble）时，Inception-v4 和 Inception-ResNet-v2 的组合取得了当时最好的结果：</p><ul><li>3 个 Inception-ResNet-v2 + 1 个 Inception-v4 的集成</li><li>Top-5 错误率：<strong>3.08%</strong></li><li>Top-1 错误率：<strong>17.5%</strong></li></ul><p>这个结果在 2016 年初是非常出色的，展示了 Inception 架构的强大潜力。</p><h2 id=第五章深入理解-inception-设计>第五章：深入理解 Inception 设计<a hidden class=anchor aria-hidden=true href=#第五章深入理解-inception-设计>#</a></h2><h3 id=51-多尺度特征提取的数学本质>5.1 多尺度特征提取的数学本质<a hidden class=anchor aria-hidden=true href=#51-多尺度特征提取的数学本质>#</a></h3><p>Inception 模块的核心是多尺度特征提取。从数学角度看，这相当于在多个尺度上应用卷积操作，然后组合结果。</p><p>设输入特征图为 $\mathbf{X} \in \mathbb{R}^{H \times W \times C}$，一个 Inception 模块可以表示为：</p><p>$$
\mathbf{Y} = \text{concat}\left(\mathbf{Y}^{(1)}, \mathbf{Y}^{(2)}, \mathbf{Y}^{(3)}, \mathbf{Y}^{(4)}\right)
$$</p><p>其中：</p><p>$$
\begin{aligned}
\mathbf{Y}^{(1)} &= W^{(1)} \ast \mathbf{X} \
\mathbf{Y}^{(2)} &= W^{(3 \times 3)} \ast \sigma(W^{(1 \times 1)}<em>{(2)} \ast \mathbf{X}) \
\mathbf{Y}^{(3)} &= W^{(5 \times 5)} \ast \sigma(W^{(1 \times 1)}</em>{(3)} \ast \mathbf{X}) \
\mathbf{Y}^{(4)} &= W^{(1 \times 1)}_{(4)} \ast \text{Pool}(\mathbf{X})
\end{aligned}
$$</p><p>这种设计的优势在于：</p><ol><li><strong>多尺度表示</strong>：不同分支捕获不同尺度的特征</li><li><strong>计算效率</strong>：通过 $1 \times 1$ 卷积降维，控制计算量</li><li><strong>表达能力</strong>：网络可以学习每种尺度的最优权重</li></ol><h3 id=52-通道拼接-vs-逐元素相加>5.2 通道拼接 vs 逐元素相加<a hidden class=anchor aria-hidden=true href=#52-通道拼接-vs-逐元素相加>#</a></h3><p>Inception（通道拼接）和 ResNet（逐元素相加）代表了两种不同的特征融合策略。</p><p><strong>通道拼接</strong>（Concatenation）：</p><ul><li>保留所有分支的完整信息</li><li>输出通道数随分支数增加</li><li>计算量随通道数线性增长</li></ul><p><strong>逐元素相加</strong>（Element-wise Addition）：</p><ul><li>融合信息，可能损失部分细节</li><li>输出通道数不变</li><li>更紧凑的表示</li></ul><p>Inception-ResNet 的尝试表明，对于 Inception 模块，逐元素相加是一种可行的替代方案。两者的主要区别在于：</p><ul><li>Inception-v4：更丰富的特征表示，适合提取多尺度信息</li><li>Inception-ResNet：更高效的特征复用，适合深层网络训练</li></ul><h3 id=53-残差连接的梯度流动分析>5.3 残差连接的梯度流动分析<a hidden class=anchor aria-hidden=true href=#53-残差连接的梯度流动分析>#</a></h3><p>让我们从数学上分析残差连接如何改善梯度流动。考虑一个简单的 $L$ 层残差网络：</p><p>$$
\mathbf{x}_{l+1} = \mathbf{x}_l + \mathcal{F}(\mathbf{x}_l, W_l)
$$</p><p>通过递归展开，第 $L$ 层的输出可以表示为：</p><p>$$
\mathbf{x}_L = \mathbf{x}<em>l + \sum</em>{i=l}^{L-1} \mathcal{F}(\mathbf{x}_i, W_i)
$$</p><p>现在考虑反向传播。损失函数 $\mathcal{L}$ 对第 $l$ 层输入的梯度为：</p><p>$$
\frac{\partial \mathcal{L}}{\partial \mathbf{x}_l} = \frac{\partial \mathcal{L}}{\partial \mathbf{x}_L} \cdot \frac{\partial \mathbf{x}_L}{\partial \mathbf{x}_l}
$$</p><p>由于 $\mathbf{x}_L = \mathbf{x}<em>l + \sum</em>{i=l}^{L-1} \mathcal{F}(\mathbf{x}_i, W_i)$，我们有：</p><p>$$
\frac{\partial \mathbf{x}_L}{\partial \mathbf{x}_l} = I + \frac{\partial}{\partial \mathbf{x}<em>l} \sum</em>{i=l}^{L-1} \mathcal{F}(\mathbf{x}_i, W_i)
$$</p><p>因此：</p><p>$$
\frac{\partial \mathcal{L}}{\partial \mathbf{x}_l} = \frac{\partial \mathcal{L}}{\partial \mathbf{x}_L} + \frac{\partial \mathcal{L}}{\partial \mathbf{x}_L} \cdot \frac{\partial}{\partial \mathbf{x}<em>l} \sum</em>{i=l}^{L-1} \mathcal{F}(\mathbf{x}_i, W_i)
$$</p><p>这个分解揭示了残差连接的关键作用：<strong>梯度可以直接从深层流向浅层</strong>（第一项），而不需要经过中间层的复杂变换。这创建了一条梯度传播的"高速公路"，有效缓解了梯度消失问题。</p><h3 id=54-inception-resnet-的集成学习视角>5.4 Inception-ResNet 的集成学习视角<a hidden class=anchor aria-hidden=true href=#54-inception-resnet-的集成学习视角>#</a></h3><p>2016年，Veit 等人的一篇论文《Residual Networks Behave Like Ensembles of Relatively Shallow Networks》提出了一个有趣的视角：<strong>残差网络实际上是一个指数级大小的隐式集成模型</strong>。</p><p>考虑一个3层的 Inception-ResNet，其展开形式为：</p><p>$$
\mathbf{x}_3 = \mathbf{x}_0 + \mathcal{F}_1(\mathbf{x}_0) + \mathcal{F}_2(\mathbf{x}_1) + \mathcal{F}_3(\mathbf{x}_2)
$$</p><p>如果每个残差块可以选择"使用"或"不使用"，那么 $n$ 个残差块可以产生 $2^n$ 条不同的路径。这解释了为什么删除 ResNet 中的某些层对性能影响很小——网络有其他路径可以补偿。</p><p>对于 Inception-ResNet，这种效应更加明显，因为每个 Inception 模块内部还有多个分支。这意味着 Inception-ResNet 不仅是一个深层的网络，还是一个<strong>多路径的集成系统</strong>。</p><h2 id=第六章架构设计的启示>第六章：架构设计的启示<a hidden class=anchor aria-hidden=true href=#第六章架构设计的启示>#</a></h2><h3 id=61-模块化的力量>6.1 模块化的力量<a hidden class=anchor aria-hidden=true href=#61-模块化的力量>#</a></h3><p>Inception-v4 的一个重要启示是<strong>模块化设计的力量</strong>。通过将网络分解为清晰的模块（Stem、Inception-A/B/C、Reduction），研究者可以：</p><ol><li><strong>独立优化每个模块</strong>：针对不同阶段的特征图尺寸优化计算效率</li><li><strong>快速实验</strong>：可以替换或修改单个模块而不影响整体架构</li><li><strong>更好的可解释性</strong>：每个模块的职责清晰，便于理解网络行为</li></ol><p>这种模块化思想在后续的神经网络设计中被广泛采用，如 EfficientNet 的复合缩放策略、RegNet 的设计空间探索等。</p><h3 id=62-计算效率与准确率的权衡>6.2 计算效率与准确率的权衡<a hidden class=anchor aria-hidden=true href=#62-计算效率与准确率的权衡>#</a></h3><p>Inception 系列的核心设计目标之一是<strong>计算效率</strong>。通过以下技巧，Inception-v4 在保持高准确率的同时控制了计算量：</p><ol><li><strong>$1 \times 1$ 卷积降维</strong>：在进入大卷积核之前减少通道数</li><li><strong>非对称分解</strong>：用 $n \times 1$ 和 $1 \times n$ 替代 $n \times n$ 卷积</li><li><strong>并行下采样</strong>：池化和卷积同时进行，充分利用计算</li></ol><p>这些技巧背后有一个共同的数学原理：<strong>卷积操作的计算复杂度与卷积核大小的平方成正比，但通过合理的分解和降维，可以在保持表达能力的同时大幅降低计算量</strong>。</p><h3 id=63-残差连接的正则化效应>6.3 残差连接的正则化效应<a hidden class=anchor aria-hidden=true href=#63-残差连接的正则化效应>#</a></h3><p>残差缩放技术的发现揭示了一个重要现象：<strong>深层网络的训练不仅受梯度流动影响，还受残差幅度的数值稳定性制约</strong>。</p><p>残差缩放的数学本质是引入了一个可调节的超参数 $\alpha$，控制残差对最终输出的贡献程度。这实际上是一种<strong>软正则化</strong>：</p><p>$$
\mathbf{Y} = \mathbf{X} + \alpha \cdot \mathcal{F}(\mathbf{X})
$$</p><p>当 $\alpha$ 较小时，网络更倾向于使用恒等映射，相当于对残差函数的复杂度进行了惩罚。这种正则化帮助网络在深度和稳定性之间找到平衡。</p><h2 id=第七章inception-的后续影响>第七章：Inception 的后续影响<a hidden class=anchor aria-hidden=true href=#第七章inception-的后续影响>#</a></h2><h3 id=71-在目标检测中的应用>7.1 在目标检测中的应用<a hidden class=anchor aria-hidden=true href=#71-在目标检测中的应用>#</a></h3><p>Inception-v4 和 Inception-ResNet 不仅在图像分类中表现出色，还被广泛应用于目标检测任务。</p><p><strong>Faster R-CNN with Inception-ResNet</strong>：将 Inception-ResNet 作为骨干网络（backbone）替换 VGG-16，在 MS COCO 数据集上取得了显著的性能提升。</p><p><strong>SSD（Single Shot MultiBox Detector）</strong>：使用 Inception 模块作为特征提取层，实现了高效的多尺度目标检测。</p><p>这些应用证明了 Inception 架构提取的多尺度特征对于定位不同大小的目标非常有效。</p><h3 id=72-对后续架构的启发>7.2 对后续架构的启发<a hidden class=anchor aria-hidden=true href=#72-对后续架构的启发>#</a></h3><p>Inception-v4 和 Inception-ResNet 的设计理念影响了后续的许多网络架构：</p><p><strong>Xception</strong>：将 Inception 的思想推向极致，使用深度可分离卷积（depthwise separable convolution）替代标准卷积。这可以看作是 Inception 模块的极端形式：每个通道独立进行空间卷积，然后用 $1 \times 1$ 卷积组合。</p><p><strong>MobileNet</strong>：为了在移动设备上高效运行，MobileNet 采用了类似的分解策略，将标准卷积分解为 depthwise 卷积和 pointwise 卷积。</p><p><strong>EfficientNet</strong>：结合 Inception 的多尺度思想和复合缩放策略，通过统一缩放网络的深度、宽度和分辨率，在计算效率和准确率之间取得了新的平衡。</p><h3 id=73-从手工设计到自动搜索>7.3 从手工设计到自动搜索<a hidden class=anchor aria-hidden=true href=#73-从手工设计到自动搜索>#</a></h3><p>Inception 系列代表了深度学习的一个重要阶段：<strong>手工设计的网络架构</strong>。研究者基于对卷积神经网络的深入理解，精心设计了 Inception 模块的各种变体。</p><p>然而，2017年后，自动架构搜索（NAS）开始兴起。Google 的 NASNet 使用强化学习自动搜索最优的网络结构，发现了许多与手工设计相似的架构单元（如类似于 Inception 的多分支结构）。</p><p>这引出了一个有趣的思考：<strong>人类设计者的直觉与自动搜索算法找到的解决方案之间存在怎样的关系？</strong></p><p>事实上，NAS 发现的许多最优单元与 Inception 模块有着惊人的相似之处——多分支、不同尺度的卷积、降维策略等。这验证了 Inception 设计者的直觉是正确的，同时也展示了自动搜索在探索更大设计空间方面的优势。</p><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>Inception-v4 和 Inception-ResNet 的论文是深度学习发展史上的一个重要里程碑。它不仅是 Inception 系列的集大成之作，更开创性地将两种不同的设计哲学——Inception 的多尺度特征提取和 ResNet 的残差学习——融合在了一起。</p><p>回顾这篇论文的核心贡献：</p><ol><li><strong>更简洁统一的架构</strong>：通过模块化的 Stem、Inception、Reduction 设计，创造了更清晰、更易于扩展的网络结构</li><li><strong>残差连接与 Inception 的融合</strong>：证明了残差连接不仅适用于简单的堆叠架构，也能与复杂的 Inception 模块有效结合</li><li><strong>残差缩放技术</strong>：发现了训练极深网络时的数值稳定性问题，并提出了有效的解决方案</li><li><strong>计算效率的持续优化</strong>：通过非对称分解等技巧，在保持准确率的同时控制了计算量</li></ol><p>Inception-v4 的成功告诉我们：<strong>好的架构设计需要深入理解数据的本质和计算的特性</strong>。图像数据具有多尺度的特点，因此需要多尺度的特征提取；深度网络的训练需要稳定的梯度流动，因此需要残差连接；实际应用需要高效的计算，因此需要精心的卷积分解。</p><p>从 2014 年的 Inception-v1 到 2016 年的 Inception-v4，再到后来的 Xception、MobileNet、EfficientNet，我们可以看到一条清晰的发展脉络：<strong>对卷积运算本质的不断深入理解，推动着网络架构的持续演进</strong>。</p><p>今天，虽然 Transformer 架构在计算机视觉领域（如 ViT、Swin Transformer）取得了显著进展，但 Inception 的设计理念——多尺度特征提取、计算效率优化、模块化设计——仍然具有重要的参考价值。理解 Inception-v4，不仅是对一篇经典论文的回顾，更是对深度学习架构设计思想的一次深入探索。</p><h2 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h2><ol><li><p>Szegedy, C., Ioffe, S., Vanhoucke, V., & Alemi, A. (2016). &ldquo;Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning.&rdquo; <em>AAAI Conference on Artificial Intelligence</em>, 31(1).</p></li><li><p>Szegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S., Anguelov, D., &mldr; & Rabinovich, A. (2015). &ldquo;Going Deeper with Convolutions.&rdquo; <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 1-9.</p></li><li><p>Szegedy, C., Vanhoucke, V., Ioffe, S., Shlens, J., & Wojna, Z. (2016). &ldquo;Rethinking the Inception Architecture for Computer Vision.&rdquo; <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 2818-2826.</p></li><li><p>He, K., Zhang, X., Ren, S., & Sun, J. (2016). &ldquo;Deep Residual Learning for Image Recognition.&rdquo; <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 770-778.</p></li><li><p>Chollet, F. (2017). &ldquo;Xception: Deep Learning with Depthwise Separable Convolutions.&rdquo; <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 1251-1258.</p></li><li><p>Howard, A. G., Zhu, M., Chen, B., Kalenichenko, D., Wang, W., Weyand, T., &mldr; & Adam, H. (2017). &ldquo;MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications.&rdquo; <em>arXiv preprint arXiv:1704.04861</em>.</p></li><li><p>Tan, M., & Le, Q. (2019). &ldquo;EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks.&rdquo; <em>International Conference on Machine Learning (ICML)</em>, 6105-6114.</p></li><li><p>Veit, A., Wilber, M. J., & Belongie, S. (2016). &ldquo;Residual Networks Behave Like Ensembles of Relatively Shallow Networks.&rdquo; <em>Advances in Neural Information Processing Systems (NeurIPS)</em>, 29.</p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://s-ai-unix.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/>深度学习</a></li><li><a href=https://s-ai-unix.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/>神经网络</a></li><li><a href=https://s-ai-unix.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>机器学习</a></li><li><a href=https://s-ai-unix.github.io/tags/%E7%BB%BC%E8%BF%B0/>综述</a></li></ul><nav class=paginav><a class=prev href=https://s-ai-unix.github.io/posts/2026-01-30-alphago-paper-interpretation/><span class=title>« Prev</span><br><span>AI 论文解读系列：AlphaGo - 深度学习与树搜索征服围棋</span>
</a><a class=next href=https://s-ai-unix.github.io/posts/2026-01-30-bert-paper-interpretation/><span class=title>Next »</span><br><span>AI 论文解读系列：BERT - 预训练深度双向 Transformer 的革命</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions on x" href="https://x.com/intent/tweet/?text=AI%20%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb%e7%b3%bb%e5%88%97%ef%bc%9aInception-v4%20-%20Going%20Deeper%20with%20Convolutions&amp;url=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-30-ai-%25E8%25AE%25BA%25E6%2596%2587%25E8%25A7%25A3%25E8%25AF%25BB%25E7%25B3%25BB%25E5%2588%2597-inception-v4-going-deeper-with-convolutions%2f&amp;hashtags=%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%2c%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%2c%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%2c%e7%bb%bc%e8%bf%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-30-ai-%25E8%25AE%25BA%25E6%2596%2587%25E8%25A7%25A3%25E8%25AF%25BB%25E7%25B3%25BB%25E5%2588%2597-inception-v4-going-deeper-with-convolutions%2f&amp;title=AI%20%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb%e7%b3%bb%e5%88%97%ef%bc%9aInception-v4%20-%20Going%20Deeper%20with%20Convolutions&amp;summary=AI%20%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb%e7%b3%bb%e5%88%97%ef%bc%9aInception-v4%20-%20Going%20Deeper%20with%20Convolutions&amp;source=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-30-ai-%25E8%25AE%25BA%25E6%2596%2587%25E8%25A7%25A3%25E8%25AF%25BB%25E7%25B3%25BB%25E5%2588%2597-inception-v4-going-deeper-with-convolutions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-30-ai-%25E8%25AE%25BA%25E6%2596%2587%25E8%25A7%25A3%25E8%25AF%25BB%25E7%25B3%25BB%25E5%2588%2597-inception-v4-going-deeper-with-convolutions%2f&title=AI%20%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb%e7%b3%bb%e5%88%97%ef%bc%9aInception-v4%20-%20Going%20Deeper%20with%20Convolutions"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 论文解读系列：Inception-v4 - Going Deeper with Convolutions on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-30-ai-%25E8%25AE%25BA%25E6%2596%2587%25E8%25A7%25A3%25E8%25AF%25BB%25E7%25B3%25BB%25E5%2588%2597-inception-v4-going-deeper-with-convolutions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=s-ai-unix/blog data-repo-id=R_kgDOQ3Njaw data-category=General data-category-id=DIC_kwDOQ3Nja84C0yve data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=https://s-ai-unix.github.io/>s-ai-unix's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script></body></html>