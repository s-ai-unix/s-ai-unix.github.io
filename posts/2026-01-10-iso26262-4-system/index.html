<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ISO 26262-4 系统级开发：从概念到实现 | s-ai-unix's Blog</title><meta name=keywords content="ISO 26262,功能安全,系统管理"><meta name=description content="深入解读 ISO 26262-4 系统级开发部分，学习如何将概念阶段的安全需求转化为系统设计、硬件需求和软件需求。"><meta name=author content="s-ai-unix"><link rel=canonical href=https://s-ai-unix.github.io/posts/2026-01-10-iso26262-4-system/><link crossorigin=anonymous href=/assets/css/stylesheet.0833aff7e1cf567ecfb9755701ee95a80535f671e2e1a0a770c9bc20a0a7b5bb.css integrity="sha256-CDOv9+HPVn7PuXVXAe6VqAU19nHi4aCncMm8IKCntbs=" rel="preload stylesheet" as=style><link rel=icon href=https://s-ai-unix.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s-ai-unix.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s-ai-unix.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s-ai-unix.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s-ai-unix.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://s-ai-unix.github.io/posts/2026-01-10-iso26262-4-system/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://s-ai-unix.github.io/posts/2026-01-10-iso26262-4-system/"><meta property="og:site_name" content="s-ai-unix's Blog"><meta property="og:title" content="ISO 26262-4 系统级开发：从概念到实现"><meta property="og:description" content="深入解读 ISO 26262-4 系统级开发部分，学习如何将概念阶段的安全需求转化为系统设计、硬件需求和软件需求。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-10T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-10T00:00:00+00:00"><meta property="article:tag" content="ISO 26262"><meta property="article:tag" content="功能安全"><meta property="article:tag" content="系统管理"><meta property="og:image" content="https://s-ai-unix.github.io/images/covers/iso26262-4-system.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://s-ai-unix.github.io/images/covers/iso26262-4-system.jpg"><meta name=twitter:title content="ISO 26262-4 系统级开发：从概念到实现"><meta name=twitter:description content="深入解读 ISO 26262-4 系统级开发部分，学习如何将概念阶段的安全需求转化为系统设计、硬件需求和软件需求。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://s-ai-unix.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ISO 26262-4 系统级开发：从概念到实现","item":"https://s-ai-unix.github.io/posts/2026-01-10-iso26262-4-system/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ISO 26262-4 系统级开发：从概念到实现","name":"ISO 26262-4 系统级开发：从概念到实现","description":"深入解读 ISO 26262-4 系统级开发部分，学习如何将概念阶段的安全需求转化为系统设计、硬件需求和软件需求。","keywords":["ISO 26262","功能安全","系统管理"],"articleBody":"引言 如果说 ISO 26262-3 概念阶段是绘制蓝图，那么 ISO 26262-4 系统级开发就是根据蓝图建造房子的主体结构。在这个阶段，我们将概念阶段定义的抽象安全目标转化为具体的技术实现方案。\n想象一个实际场景：某汽车电子公司开发了一款电子稳定控制系统（ESC），概念阶段确定了\"防止车辆失控\"的安全目标（ASIL D）。但是，如何实现这个目标？需要什么样的硬件？需要什么样的传感器？如何设计软件架构？如何确保系统在故障时仍然安全？这些都是系统级开发要回答的问题。\nISO 26262-4 提供了完整的框架，指导我们如何：\n设计系统架构 将功能安全需求分配到硬件和软件 定义硬件和软件的接口 集成和测试系统 系统级开发的目标和范围 系统级开发的核心活动 ISO 26262-4 定义了系统级开发的六个核心活动：\n技术安全概念（TSC）的开发\n将功能安全概念转化为技术实现方案 定义系统架构和安全机制 系统安全需求（SSyR）的制定\n从 FSR 派生系统级安全需求 分配到硬件和软件 硬件安全需求（HSR）和软件安全需求（SSR）\n将系统安全需求具体化 定义硬件和软件的接口 系统架构设计\n设计硬件架构 设计软件架构 定义硬件和软件的交互 硬件/软件集成（HSI）\n定义硬件和软件的接口 确保接口的一致性 系统集成和测试\n集成硬件和软件 验证系统满足安全需求 系统级开发的输入和输出 输入 功能安全概念（FSC）：来自概念阶段 功能安全需求（FSR）：来自概念阶段 安全目标（SG）：来自概念阶段 系统需求：非安全相关的系统需求 硬件和软件约束：技术约束、成本约束、时间约束 输出 技术安全概念（TSC）：技术实现方案 系统安全需求（SSyR）：系统级安全需求 硬件安全需求（HSR）：硬件级安全需求 软件安全需求（SSR）：软件级安全需求 系统架构设计：硬件和软件架构 硬件/软件接口规范（HSIS）：接口定义 系统集成测试报告：测试结果 技术安全概念（TSC）的开发 TSC 的定义和作用 技术安全概念（TSC） 是实现功能安全概念的技术策略。它描述了：\n如何在技术上实现安全目标 如何在硬件和软件之间分配安全需求 如何设计安全机制 如何确保硬件和软件的独立性 TSC 的开发步骤 第一步：分析功能安全概念 首先，需要深入理解概念阶段定义的功能安全概念。\n第二步：确定技术实现策略 选择合适的技术方案，如：\n冗余架构（双通道、三模冗余） 故障检测机制（看门狗、CRC、ECC） 故障容错机制（投票机制、降级模式） 故障恢复机制（重启、安全状态切换） 第三步：设计系统架构 设计硬件架构和软件架构，并确定安全机制的分配。\n第四步：分配安全需求到硬件和软件 将系统安全需求具体化为硬件安全需求和软件安全需求。\n案例：制动系统的技术安全概念 让我们以**电子液压制动系统（EHB）**为例，展示 TSC 的开发过程。\n功能安全概念（来自概念阶段） 安全目标（SG-1）：\n“制动助力系统的故障不得导致制动性能的显著降低，ASIL C”\n功能安全需求（FSR-1.1）：\n“系统应在 100 ms 内检测到制动助力失效”\n功能安全需求（FSR-1.2）：\n“在检测到助力失效后，系统应立即启动机械制动备份”\n技术实现策略 技术方案选择：\n冗余架构：双通道控制器架构 故障检测：压力传感器冗余、电流监测、看门狗 故障容错：主通道故障时切换到备份通道 故障恢复：系统重启、故障记录 系统架构设计 硬件架构：\n电源管理单元 │ ┌──────────────┼──────────────┐ │ │ │ 主控制器（MCU1） 备份控制器（MCU2） 安全监控器 │ │ │ │ │ │ 压力传感器1 压力传感器2 阀门驱动 │ │ │ └──────────────┼──────────────┘ │ 液压执行单元 │ 车轮制动器 软件架构：\n应用层 ├── 控制算法层 │ ├── 制动控制 │ ├── 压力调节 │ └── 故障诊断 │ 中间件层 ├── 通信层（CAN、SPI） ├── 诊断层（UDS） └── 时间管理 │ 硬件抽象层（HAL） ├── ADC 驱动 ├── GPIO 驱动 ├── SPI 驱动 └── 看门狗驱动 │ 硬件层 ├── MCU1 ├── MCU2 ├── 传感器 └── 执行器 技术安全需求 TSR-1.1.1：\n“硬件应实现双通道压力传感器，每个传感器由独立的 MCU 监测”\nTSR-1.1.2：\n“软件应每 10 ms 读取一次压力传感器数据，并执行一致性检查”\nTSR-1.2.1：\n“硬件应实现双通道控制器架构，主/备通道独立运行”\nTSR-1.2.2：\n“软件应实现主/备通道的故障检测和切换逻辑”\nTSR-1.3.1：\n“硬件应实现独立于 CPU 的看门狗定时器”\nTSR-1.3.2：\n“软件应定期喂狗（例如每 5 ms）”\n系统安全需求（SSyR）的制定 SSyR 的定义和作用 系统安全需求（SSyR） 是系统级的安全需求，它从功能安全需求派生而来，是硬件和软件需求的桥梁。\nSSyR 的分类 1. 性能需求 定义系统的性能指标，如：\n响应时间 故障检测时间 故障恢复时间 2. 功能需求 定义系统的功能要求，如：\n故障检测功能 故障容错功能 故障恢复功能 3. 接口需求 定义系统内部和外部接口，如：\n硬件/软件接口 与其他系统的接口 4. 约束需求 定义系统的约束条件，如：\n硬件资源约束 软件资源约束 时序约束 案例：制动系统的系统安全需求 SSyR-1（来自 FSR-1.1）：\n“系统应在 100 ms 内检测到制动助力失效”\nSSyR-1.1（性能需求）：\n“压力传感器的采样周期不得大于 10 ms”\nSSyR-1.2（功能需求）：\n“系统应实现压力传感器故障诊断算法”\nSSyR-1.3（性能需求）：\n“故障诊断算法的执行时间不得超过 20 ms”\nSSyR-1.4（功能需求）：\n“系统应实现压力传感器数据一致性检查”\nSSyR-2（来自 FSR-1.2）：\n“在检测到助力失效后，系统应立即启动机械制动备份”\nSSyR-2.1（功能需求）：\n“系统应实现主/备通道故障检测和切换逻辑”\nSSyR-2.2（性能需求）：\n“通道切换时间不得超过 50 ms”\nSSyR-2.3（功能需求）：\n“系统应实现机械制动备份路径的控制逻辑”\n硬件安全需求（HSR）和软件安全需求（SSR） HSR 的定义和作用 硬件安全需求（HSR） 是对硬件的具体安全要求。\nHSR 的内容 硬件组件需求：\nMCU 选型要求 传感器选型要求 执行器选型要求 硬件接口需求：\n电源接口 信号接口 通信接口 硬件安全机制需求：\n看门狗定时器 ECC 内存 冗余设计 SSR 的定义和作用 软件安全需求（SSR） 是对软件的具体安全要求。\nSSR 的内容 软件架构需求：\n分层架构 模块化设计 独立性要求 软件功能需求：\n故障检测算法 故障容错逻辑 故障恢复流程 软件质量需求：\nMISRA C 编码规范 代码复杂度要求 测试覆盖率要求 案例：制动系统的 HSR 和 SSR HSR-1.1.1（来自 TSR-1.1.1）： “硬件应实现双通道压力传感器，每个传感器由独立的 MCU 监测”\n具体要求：\n压力传感器型号：Bosch 0 986 593 501 压力传感器精度：±0.1 bar 压力传感器故障模式检测：开路、短路、漂移 MCU1 和 MCU2 应独立供电 HSR-1.3.1（来自 TSR-1.3.1）： “硬件应实现独立于 CPU 的看门狗定时器”\n具体要求：\n看门狗类型：外部窗口看门狗 看门狗超时时间：可配置（默认 100 ms） 看门狗复位类型：系统复位 SSR-1.1.2（来自 TSR-1.1.2）： “软件应每 10 ms 读取一次压力传感器数据，并执行一致性检查”\n具体要求：\n使用硬件定时器中断，周期 10 ms 一致性检查算法： 如果 |P1 - P2| \u003e 阈值，判定为故障 阈值根据工况动态调整 故障判定逻辑： 连续 3 次检测到不一致，判定为传感器故障 SSR-1.2.2（来自 TSR-1.2.2）： “软件应实现主/备通道的故障检测和切换逻辑”\n具体要求：\n主通道故障检测： MCU1 看门狗超时 MCU1 压力传感器故障 MCU1 通信故障 切换逻辑： 检测到主通道故障，立即切换到备份通道 切换时间 \u003c 50 ms 切换过程中保持制动功能 系统架构设计 硬件架构设计 硬件架构的原则 独立性原则：冗余通道之间应该独立，避免共因故障 多样性原则：不同通道采用不同的实现方式，避免系统性故障 诊断性原则：硬件应具备自诊断能力 硬件架构的类型 单通道架构：\n适用于 ASIL A/B 成本低 安全性有限 双通道冗余架构：\n适用于 ASIL C/D 成本中等 安全性高 三模冗余架构（TMR）：\n适用于 ASIL D 高要求场景 成本高 安全性最高 案例：ASIL D 系统的三模冗余架构 对于 ASIL D 的电子驻车制动系统（EPB），采用三模冗余架构：\n传感器 │ ┌────────┼────────┐ │ │ │ MCU1 MCU2 MCU3 │ │ │ └────────┼────────┘ │ 投票器 │ 执行器 可靠性计算：\n假设单个 MCU 的可靠度为 $R = 0.9999$（在任务时间内）。\n系统成功运行的条件是：至少两个 MCU 正常工作。\n$$ R_{\\text{system}} = R^3 + 3 \\times R^2 \\times (1-R) $$\n代入数值： $$ R_{\\text{system}} = 0.9999^3 + 3 \\times 0.9999^2 \\times 0.0001 $$ $$ R_{\\text{system}} = 0.9997 + 0.00029997 $$ $$ R_{\\text{system}} = 0.99999997 $$\n可以看到，通过三模冗余，系统可靠度从 99.99% 提升到了 99.999997%。\n软件架构设计 软件架构的原则 分层原则：应用层、中间件层、硬件抽象层、硬件层 模块化原则：每个模块功能单一，接口清晰 独立性原则：安全相关软件与非安全相关软件分离 软件架构的类型 分层架构：\n优点：模块化、可维护性好 缺点：性能开销大 面向对象架构：\n优点：灵活性高、可扩展性好 缺点：资源消耗大 事件驱动架构：\n优点：实时性好、响应快 缺点：调试困难 案例：制动系统的软件架构 分层架构设计：\n应用层（Application Layer） ├── 制动控制模块 │ ├── 压力控制算法 │ ├── 车轮速度控制 │ └── 车辆稳定性控制 │ ├── 故障诊断模块 │ ├── 传感器故障诊断 │ ├── 执行器故障诊断 │ └── 系统故障诊断 │ ├── 安全管理模块 │ ├── 故障处理逻辑 │ ├── 安全状态管理 │ └── 故障记录 │ └── 通信模块 ├── CAN 通信 └── 诊断服务 │ 中间件层（Middleware Layer） ├── 操作系统抽象层（OSAL） │ ├── 任务调度 │ ├── 事件管理 │ └── 定时器管理 │ ├── 通信层（Communication Layer） │ ├── CAN 驱动 │ ├── SPI 驱动 │ └── LIN 驱动 │ └── 存储层（Storage Layer） ├── EEPROM 驱动 └── Flash 驱动 │ 硬件抽象层（HAL） ├── ADC 驱动 ├── GPIO 驱动 ├── PWM 驱动 ├── 定时器驱动 └── 看门狗驱动 │ 硬件层（Hardware Layer） ├── MCU ├── 传感器 ├── 执行器 └── 电源管理 软件模块接口定义：\n// 制动控制模块接口 typedef struct { float pedal_position; // 制动踏板位置（0-1） float vehicle_speed; // 车辆速度（km/h） float wheel_speeds[4]; // 车轮速度（km/h） } BrakingControlInput; typedef struct { float target_pressure; // 目标制动压力（bar） float valve_command[4]; // 阀门控制指令（0-1） } BrakingControlOutput; // 函数原型 void BrakingControl_Init(void); void BrakingControl_Run(const BrakingControlInput* input, BrakingControlOutput* output); // 故障诊断模块接口 typedef enum { FAULT_NONE = 0, FAULT_SENSOR_OPEN, FAULT_SENSOR_SHORT, FAULT_SENSOR_DRIFT, FAULT_ACTUATOR_STUCK, FAULT_WATCHDOG_TIMEOUT } FaultType; typedef struct { FaultType fault_type; uint8_t component_id; uint32_t timestamp; } FaultEvent; // 函数原型 void FaultDiagnosis_Init(void); void FaultDiagnosis_Run(void); bool FaultDiagnosis_GetFault(FaultEvent* event); 硬件/软件集成（HSI） HSI 的定义和作用 硬件/软件集成（HSI） 是定义硬件和软件接口的过程。\nHSI 的内容 1. 内存映射 定义硬件寄存器的内存地址，软件通过读写这些寄存器来控制硬件。\n2. 中断向量表 定义硬件中断源和软件中断处理程序的对应关系。\n3. 数据结构 定义硬件和软件之间交换数据的格式。\n4. 时序约束 定义硬件和软件之间交互的时间要求。\n案例：制动系统的 HSI 内存映射 寄存器名称 地址 访问类型 描述 P1_DATA_REG 0x4000 0000 R 压力传感器1数据寄存器 P2_DATA_REG 0x4000 0004 R 压力传感器2数据寄存器 VALVE_CMD_REG 0x4000 0008 W 阀门控制寄存器 WDT_FEED_REG 0x4000 000C W 看门狗喂狗寄存器 STATUS_REG 0x4000 0010 R 状态寄存器 中断向量表 中断源 优先级 中断处理函数 描述 Timer0 1 Timer0_ISR 10ms 定时中断 ADC_Conv_Complete 2 ADC_ISR ADC 转换完成中断 CAN_Rx 3 CAN_Rx_ISR CAN 接收中断 WDT_Timeout 4 WDT_ISR 看门狗超时中断 数据结构 // 硬件寄存器定义 #define P1_DATA_REG (*(volatile uint32_t*)0x40000000) #define P2_DATA_REG (*(volatile uint32_t*)0x40000004) #define VALVE_CMD_REG (*(volatile uint32_t*)0x40000008) #define WDT_FEED_REG (*(volatile uint32_t*)0x4000000C) #define STATUS_REG (*(volatile uint32_t*)0x40000010) // 硬件状态定义 typedef struct { uint8_t p1_ready : 1; // 压力传感器1就绪 uint8_t p2_ready : 1; // 压力传感器2就绪 uint8_t valve_error : 1; // 阀门错误 uint8_t wdt_timeout : 1; // 看门狗超时 uint8_t reserved : 4; // 保留 } HardwareStatus; 时序约束 操作 时间要求 说明 传感器采样 10 ms 定期读取传感器数据 控制算法执行 \u003c 5 ms 单次控制算法执行时间 阀门响应 \u003c 10 ms 从发出指令到阀门动作的时间 故障检测 \u003c 20 ms 从故障发生到检测到故障的时间 安全状态切换 \u003c 50 ms 从检测到故障到进入安全状态的时间 系统集成和测试 系统集成 系统集成的步骤：\n单元测试：测试每个硬件组件和软件模块 集成测试：测试硬件和软件的集成 系统测试：测试整个系统的功能 验收测试：验证系统满足需求 系统测试 测试类型 功能测试：\n测试系统是否实现了所有功能 测试各种正常和异常场景 性能测试：\n测试系统的响应时间 测试系统的吞吐量 安全测试：\n故障注入测试 安全状态切换测试 冗余机制测试 可靠性测试：\n长时间运行测试 压力测试 案例：制动系统的系统测试 测试用例 1：压力传感器故障检测\n测试步骤：\n系统上电初始化 模拟压力传感器1开路故障 等待 30 ms 检查系统是否检测到故障 检查系统是否进入安全状态 预期结果：\n系统在 30 ms 内检测到传感器1开路故障 系统切换到传感器2 系统向驾驶员发出报警 测试用例 2：主控制器故障检测\n测试步骤：\n系统上电初始化 模拟主控制器（MCU1）看门狗超时 等待 60 ms 检查系统是否检测到故障 检查系统是否切换到备份控制器 预期结果：\n系统在 60 ms 内检测到主控制器故障 系统切换到备份控制器 制动功能保持正常 测试用例 3：阀门故障容错\n测试步骤：\n系统上电初始化 模拟阀门卡死故障 施加制动踏板 检查系统是否检测到故障 检查系统是否进入安全状态 预期结果：\n系统检测到阀门卡死故障 系统进入安全状态（机械制动备份） 驾驶员可以继续制动 实战案例：自动紧急制动系统（AEB）的系统级开发 让我们以一个实际项目为例，展示系统级开发的完整流程。\n项目背景 某汽车厂商正在开发 AEB 系统，用于在检测到碰撞风险时自动施加制动，避免或减轻碰撞。\n第一步：分析功能安全概念 来自概念阶段的安全目标（SG）：\n“AEB 系统不得在未检测到碰撞风险时误制动，ASIL D”\n功能安全需求（FSR）：\n“AEB 系统应准确检测碰撞风险，误判率 \u003c 0.001%”\n第二步：开发技术安全概念 技术方案选择：\n传感器融合：摄像头 + 雷达 + 超声波传感器 冗余架构：双通道 ECU 架构 故障检测：传感器健康监测、数据一致性检查 故障容错：单传感器故障时仍能工作 系统架构设计：\n┌─────────┐ │ 摄像头 │ └────┬────┘ │ ┌────▼────┐ │ 前雷达 │ └────┬────┘ │ ┌────▼────┐ │ 超声波 │ └────┬────┘ │ ┌────▼──────────────┐ │ 传感器融合单元 │ └────┬──────────────┘ │ ┌──────────────┼──────────────┐ │ │ │ 主控制器（ECU1） 备份控制器（ECU2） 安全监控器 │ │ │ └──────────────┼──────────────┘ │ 制动执行器 第三步：制定系统安全需求 SSyR-1（来自 FSR）：\n“AEB 系统应准确检测碰撞风险，误判率 \u003c 0.001%”\nSSyR-1.1（功能需求）：\n“系统应实现多传感器融合算法，综合判断碰撞风险”\nSSyR-1.2（性能需求）：\n“碰撞风险检测时间不得大于 50 ms”\nSSyR-1.3（功能需求）：\n“系统应实现传感器健康监测，检测传感器故障”\nSSyR-2（来自 FSR）：\n“系统在检测到碰撞风险时，应及时施加制动”\nSSyR-2.1（性能需求）：\n“从检测到碰撞风险到施加制动的时间不得大于 150 ms”\n第四步：制定硬件安全需求 HSR-1.1.1（传感器选型）：\n“摄像头应具备车道检测和障碍物检测功能”\n具体要求：\n分辨率：1280 × 720 帧率：30 fps 视场角：90° HSR-1.1.2（ECU 选型）：\n“ECU 应具备双核处理器，分别运行主/备通道”\n具体要求：\nCPU：双核 ARM Cortex-A53 @ 1.5GHz 内存：4GB DDR4 存储：32GB eMMC 第五步：制定软件安全需求 SSR-1.1.1（传感器融合算法）：\n“软件应实现卡尔曼滤波算法，融合多传感器数据”\n具体要求：\n算法类型：扩展卡尔曼滤波（EKF） 更新频率：10 Hz 预测误差：距离 \u003c 0.5m，速度 \u003c 1km/h SSR-1.3.1（传感器故障诊断）：\n“软件应实现传感器数据一致性检查”\n具体要求：\n检查方法：多传感器数据交叉验证 故障判定：连续 5 次数据不一致 故障响应：标记传感器为不可用，并报警 第六步：定义硬件/软件接口 内存映射：\n寄存器名称 地址 访问类型 描述 CAMERA_DATA_REG 0x5000 0000 R 摄像头数据寄存器 RADAR_DATA_REG 0x5000 0100 R 雷达数据寄存器 ULTRASONIC_DATA_REG 0x5000 0200 R 超声波数据寄存器 BRAKE_CMD_REG 0x5000 0300 W 制动命令寄存器 STATUS_REG 0x5000 0400 R 状态寄存器 中断向量表：\n中断源 优先级 中断处理函数 描述 Timer0 1 Timer0_ISR 10ms 定时中断（控制循环） Camera_Frame 2 Camera_ISR 摄像头帧中断 Radar_Data 3 Radar_ISR 雷达数据中断 Ultrasonic_Data 4 Ultrasonic_ISR 超声波数据中断 CAN_Rx 5 CAN_Rx_ISR CAN 接收中断 第七步：系统集成和测试 集成测试计划：\n测试用例 测试目的 测试步骤 预期结果 TC-1 正常制动功能 模拟障碍物出现，检测AEB是否制动 AEB及时制动，避免碰撞 TC-2 摄像头故障容错 模拟摄像头故障，检测AEB是否工作 AEB切换到雷达+超声波，正常工作 TC-3 雷达故障容错 模拟雷达故障，检测AEB是否工作 AEB切换到摄像头+超声波，正常工作 TC-4 误制动测试 正常驾驶，检测AEB是否误制动 AEB不误制动 TC-5 响应时间测试 测量从检测障碍物到制动的时间 响应时间 \u003c 150 ms 常见错误和最佳实践 常见错误 硬件/软件接口定义不清\n内存映射混乱 中断配置错误 数据格式不一致 架构设计不合理\n模块耦合度过高 缺乏独立性 冗余设计不充分 需求追溯不完整\nFSR → SSyR → HSR/SSR 追溯断裂 无法验证是否满足需求 集成测试不充分\n只测试正常场景，忽视故障场景 未进行故障注入测试 最佳实践 使用 SysML/UML 建模\n清晰地表达系统架构 建立完整的追溯关系 建立需求追溯矩阵\n确保每个需求都有对应的实现和测试 便于审查和审计 采用模块化设计\n高内聚、低耦合 便于维护和升级 充分的测试\n覆盖所有需求和场景 特别是故障场景 总结 ISO 26262-4 系统级开发是连接概念阶段和具体实现的桥梁。通过本文的深入解读和丰富的案例实践，我们掌握了：\n技术安全概念（TSC）的开发：\nTSC 的定义和作用 TSC 的开发步骤 制动系统的 TSC 实践 系统安全需求（SSyR）的制定：\nSSyR 的分类 SSyR 的制定方法 制动系统的 SSyR 实例 硬件安全需求（HSR）和软件安全需求（SSR）：\nHSR 和 SSR 的定义和作用 HSR 和 SSR 的内容 制动系统的 HSR/SSR 实例 系统架构设计：\n硬件架构设计（单通道、双通道、三模冗余） 软件架构设计（分层架构） 三模冗余的可靠性计算 硬件/软件集成（HSI）：\nHSI 的定义和作用 HSI 的内容（内存映射、中断向量表、数据结构、时序约束） 制动系统的 HSI 实例 系统集成和测试：\n系统集成的步骤 系统测试的类型 制动系统的测试用例 实战案例：\nAEB 系统的系统级开发完整实践 核心要点：\n系统级开发是将概念阶段的安全需求转化为具体技术实现的关键环节 TSC 是连接概念阶段和系统级开发的桥梁 HSR 和 SSR 必须追溯到 SSyR，SSyR 必须追溯到 FSR 系统架构设计必须考虑独立性、多样性和诊断性 HSI 是硬件和软件协同工作的基础 充分的测试是确保系统安全的关键 在下一篇文章中，我们将深入解读 ISO 26262-5 硬件级开发部分，学习如何设计和开发安全的硬件。\n延伸阅读 ISO 26262-1: 词汇 ISO 26262-2: 功能安全管理 ISO 26262-3: 概念阶段 ISO 26262-5: 硬件级开发 ISO 26262 整体综述 ","wordCount":"1248","inLanguage":"en","image":"https://s-ai-unix.github.io/images/covers/iso26262-4-system.jpg","datePublished":"2026-01-10T00:00:00Z","dateModified":"2026-01-10T00:00:00Z","author":{"@type":"Person","name":"s-ai-unix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://s-ai-unix.github.io/posts/2026-01-10-iso26262-4-system/"},"publisher":{"@type":"Organization","name":"s-ai-unix's Blog","logo":{"@type":"ImageObject","url":"https://s-ai-unix.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://s-ai-unix.github.io/css/classical-quote.css></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://s-ai-unix.github.io/ accesskey=h title="s-ai-unix's Blog (Alt + H)">s-ai-unix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s-ai-unix.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://s-ai-unix.github.io/posts/ title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://s-ai-unix.github.io/archives/ title="📁 归档"><span>📁 归档</span></a></li><li><a href=https://s-ai-unix.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://s-ai-unix.github.io/search/ title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://s-ai-unix.github.io/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://s-ai-unix.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://s-ai-unix.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ISO 26262-4 系统级开发：从概念到实现</h1><div class=post-description>深入解读 ISO 26262-4 系统级开发部分，学习如何将概念阶段的安全需求转化为系统设计、硬件需求和软件需求。</div><div class=post-meta><span title='2026-01-10 00:00:00 +0000 UTC'>January 10, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1248 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></div></header><figure class=entry-cover><a href=https://s-ai-unix.github.io/images/covers/iso26262-4-system.jpg target=_blank rel="noopener noreferrer"><img loading=eager src=https://s-ai-unix.github.io/images/covers/iso26262-4-system.jpg alt="ISO 26262 系统级开发"></a><figcaption>从概念到实现的桥梁</figcaption></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%bc%95%e8%a8%80 aria-label=引言>引言</a></li><li><a href=#%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%bc%80%e5%8f%91%e7%9a%84%e7%9b%ae%e6%a0%87%e5%92%8c%e8%8c%83%e5%9b%b4 aria-label=系统级开发的目标和范围>系统级开发的目标和范围</a><ul><li><a href=#%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%bc%80%e5%8f%91%e7%9a%84%e6%a0%b8%e5%bf%83%e6%b4%bb%e5%8a%a8 aria-label=系统级开发的核心活动>系统级开发的核心活动</a></li><li><a href=#%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%bc%80%e5%8f%91%e7%9a%84%e8%be%93%e5%85%a5%e5%92%8c%e8%be%93%e5%87%ba aria-label=系统级开发的输入和输出>系统级开发的输入和输出</a><ul><li><a href=#%e8%be%93%e5%85%a5 aria-label=输入>输入</a></li><li><a href=#%e8%be%93%e5%87%ba aria-label=输出>输出</a></li></ul></li></ul></li><li><a href=#%e6%8a%80%e6%9c%af%e5%ae%89%e5%85%a8%e6%a6%82%e5%bf%b5tsc%e7%9a%84%e5%bc%80%e5%8f%91 aria-label=技术安全概念（TSC）的开发>技术安全概念（TSC）的开发</a><ul><li><a href=#tsc-%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%9c%e7%94%a8 aria-label="TSC 的定义和作用">TSC 的定义和作用</a></li><li><a href=#tsc-%e7%9a%84%e5%bc%80%e5%8f%91%e6%ad%a5%e9%aa%a4 aria-label="TSC 的开发步骤">TSC 的开发步骤</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e6%ad%a5%e5%88%86%e6%9e%90%e5%8a%9f%e8%83%bd%e5%ae%89%e5%85%a8%e6%a6%82%e5%bf%b5 aria-label=第一步：分析功能安全概念>第一步：分析功能安全概念</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e6%ad%a5%e7%a1%ae%e5%ae%9a%e6%8a%80%e6%9c%af%e5%ae%9e%e7%8e%b0%e7%ad%96%e7%95%a5 aria-label=第二步：确定技术实现策略>第二步：确定技术实现策略</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e6%ad%a5%e8%ae%be%e8%ae%a1%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84 aria-label=第三步：设计系统架构>第三步：设计系统架构</a></li><li><a href=#%e7%ac%ac%e5%9b%9b%e6%ad%a5%e5%88%86%e9%85%8d%e5%ae%89%e5%85%a8%e9%9c%80%e6%b1%82%e5%88%b0%e7%a1%ac%e4%bb%b6%e5%92%8c%e8%bd%af%e4%bb%b6 aria-label=第四步：分配安全需求到硬件和软件>第四步：分配安全需求到硬件和软件</a></li></ul></li><li><a href=#%e6%a1%88%e4%be%8b%e5%88%b6%e5%8a%a8%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%8a%80%e6%9c%af%e5%ae%89%e5%85%a8%e6%a6%82%e5%bf%b5 aria-label=案例：制动系统的技术安全概念>案例：制动系统的技术安全概念</a><ul><li><a href=#%e5%8a%9f%e8%83%bd%e5%ae%89%e5%85%a8%e6%a6%82%e5%bf%b5%e6%9d%a5%e8%87%aa%e6%a6%82%e5%bf%b5%e9%98%b6%e6%ae%b5 aria-label=功能安全概念（来自概念阶段）>功能安全概念（来自概念阶段）</a></li><li><a href=#%e6%8a%80%e6%9c%af%e5%ae%9e%e7%8e%b0%e7%ad%96%e7%95%a5 aria-label=技术实现策略>技术实现策略</a></li><li><a href=#%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1 aria-label=系统架构设计>系统架构设计</a></li><li><a href=#%e6%8a%80%e6%9c%af%e5%ae%89%e5%85%a8%e9%9c%80%e6%b1%82 aria-label=技术安全需求>技术安全需求</a></li></ul></li></ul></li><li><a href=#%e7%b3%bb%e7%bb%9f%e5%ae%89%e5%85%a8%e9%9c%80%e6%b1%82ssyr%e7%9a%84%e5%88%b6%e5%ae%9a aria-label=系统安全需求（SSyR）的制定>系统安全需求（SSyR）的制定</a><ul><li><a href=#ssyr-%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%9c%e7%94%a8 aria-label="SSyR 的定义和作用">SSyR 的定义和作用</a></li><li><a href=#ssyr-%e7%9a%84%e5%88%86%e7%b1%bb aria-label="SSyR 的分类">SSyR 的分类</a><ul><li><a href=#1-%e6%80%a7%e8%83%bd%e9%9c%80%e6%b1%82 aria-label="1. 性能需求">1. 性能需求</a></li><li><a href=#2-%e5%8a%9f%e8%83%bd%e9%9c%80%e6%b1%82 aria-label="2. 功能需求">2. 功能需求</a></li><li><a href=#3-%e6%8e%a5%e5%8f%a3%e9%9c%80%e6%b1%82 aria-label="3. 接口需求">3. 接口需求</a></li><li><a href=#4-%e7%ba%a6%e6%9d%9f%e9%9c%80%e6%b1%82 aria-label="4. 约束需求">4. 约束需求</a></li></ul></li><li><a href=#%e6%a1%88%e4%be%8b%e5%88%b6%e5%8a%a8%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%b3%bb%e7%bb%9f%e5%ae%89%e5%85%a8%e9%9c%80%e6%b1%82 aria-label=案例：制动系统的系统安全需求>案例：制动系统的系统安全需求</a></li></ul></li><li><a href=#%e7%a1%ac%e4%bb%b6%e5%ae%89%e5%85%a8%e9%9c%80%e6%b1%82hsr%e5%92%8c%e8%bd%af%e4%bb%b6%e5%ae%89%e5%85%a8%e9%9c%80%e6%b1%82ssr aria-label=硬件安全需求（HSR）和软件安全需求（SSR）>硬件安全需求（HSR）和软件安全需求（SSR）</a><ul><li><a href=#hsr-%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%9c%e7%94%a8 aria-label="HSR 的定义和作用">HSR 的定义和作用</a><ul><li><a href=#hsr-%e7%9a%84%e5%86%85%e5%ae%b9 aria-label="HSR 的内容">HSR 的内容</a></li></ul></li><li><a href=#ssr-%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%9c%e7%94%a8 aria-label="SSR 的定义和作用">SSR 的定义和作用</a><ul><li><a href=#ssr-%e7%9a%84%e5%86%85%e5%ae%b9 aria-label="SSR 的内容">SSR 的内容</a></li></ul></li><li><a href=#%e6%a1%88%e4%be%8b%e5%88%b6%e5%8a%a8%e7%b3%bb%e7%bb%9f%e7%9a%84-hsr-%e5%92%8c-ssr aria-label="案例：制动系统的 HSR 和 SSR">案例：制动系统的 HSR 和 SSR</a><ul><li><a href=#hsr-111%e6%9d%a5%e8%87%aa-tsr-111 aria-label="HSR-1.1.1（来自 TSR-1.1.1）：">HSR-1.1.1（来自 TSR-1.1.1）：</a></li><li><a href=#hsr-131%e6%9d%a5%e8%87%aa-tsr-131 aria-label="HSR-1.3.1（来自 TSR-1.3.1）：">HSR-1.3.1（来自 TSR-1.3.1）：</a></li><li><a href=#ssr-112%e6%9d%a5%e8%87%aa-tsr-112 aria-label="SSR-1.1.2（来自 TSR-1.1.2）：">SSR-1.1.2（来自 TSR-1.1.2）：</a></li><li><a href=#ssr-122%e6%9d%a5%e8%87%aa-tsr-122 aria-label="SSR-1.2.2（来自 TSR-1.2.2）：">SSR-1.2.2（来自 TSR-1.2.2）：</a></li></ul></li></ul></li><li><a href=#%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1-1 aria-label=系统架构设计>系统架构设计</a><ul><li><a href=#%e7%a1%ac%e4%bb%b6%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1 aria-label=硬件架构设计>硬件架构设计</a><ul><li><a href=#%e7%a1%ac%e4%bb%b6%e6%9e%b6%e6%9e%84%e7%9a%84%e5%8e%9f%e5%88%99 aria-label=硬件架构的原则>硬件架构的原则</a></li><li><a href=#%e7%a1%ac%e4%bb%b6%e6%9e%b6%e6%9e%84%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label=硬件架构的类型>硬件架构的类型</a></li><li><a href=#%e6%a1%88%e4%be%8basil-d-%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%b8%89%e6%a8%a1%e5%86%97%e4%bd%99%e6%9e%b6%e6%9e%84 aria-label="案例：ASIL D 系统的三模冗余架构">案例：ASIL D 系统的三模冗余架构</a></li></ul></li><li><a href=#%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1 aria-label=软件架构设计>软件架构设计</a><ul><li><a href=#%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e7%9a%84%e5%8e%9f%e5%88%99 aria-label=软件架构的原则>软件架构的原则</a></li><li><a href=#%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label=软件架构的类型>软件架构的类型</a></li><li><a href=#%e6%a1%88%e4%be%8b%e5%88%b6%e5%8a%a8%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84 aria-label=案例：制动系统的软件架构>案例：制动系统的软件架构</a></li></ul></li></ul></li><li><a href=#%e7%a1%ac%e4%bb%b6%e8%bd%af%e4%bb%b6%e9%9b%86%e6%88%90hsi aria-label=硬件/软件集成（HSI）>硬件/软件集成（HSI）</a><ul><li><a href=#hsi-%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%9c%e7%94%a8 aria-label="HSI 的定义和作用">HSI 的定义和作用</a></li><li><a href=#hsi-%e7%9a%84%e5%86%85%e5%ae%b9 aria-label="HSI 的内容">HSI 的内容</a><ul><li><a href=#1-%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84 aria-label="1. 内存映射">1. 内存映射</a></li><li><a href=#2-%e4%b8%ad%e6%96%ad%e5%90%91%e9%87%8f%e8%a1%a8 aria-label="2. 中断向量表">2. 中断向量表</a></li><li><a href=#3-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="3. 数据结构">3. 数据结构</a></li><li><a href=#4-%e6%97%b6%e5%ba%8f%e7%ba%a6%e6%9d%9f aria-label="4. 时序约束">4. 时序约束</a></li></ul></li><li><a href=#%e6%a1%88%e4%be%8b%e5%88%b6%e5%8a%a8%e7%b3%bb%e7%bb%9f%e7%9a%84-hsi aria-label="案例：制动系统的 HSI">案例：制动系统的 HSI</a><ul><li><a href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84 aria-label=内存映射>内存映射</a></li><li><a href=#%e4%b8%ad%e6%96%ad%e5%90%91%e9%87%8f%e8%a1%a8 aria-label=中断向量表>中断向量表</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a></li><li><a href=#%e6%97%b6%e5%ba%8f%e7%ba%a6%e6%9d%9f aria-label=时序约束>时序约束</a></li></ul></li></ul></li><li><a href=#%e7%b3%bb%e7%bb%9f%e9%9b%86%e6%88%90%e5%92%8c%e6%b5%8b%e8%af%95 aria-label=系统集成和测试>系统集成和测试</a><ul><li><a href=#%e7%b3%bb%e7%bb%9f%e9%9b%86%e6%88%90 aria-label=系统集成>系统集成</a></li><li><a href=#%e7%b3%bb%e7%bb%9f%e6%b5%8b%e8%af%95 aria-label=系统测试>系统测试</a><ul><li><a href=#%e6%b5%8b%e8%af%95%e7%b1%bb%e5%9e%8b aria-label=测试类型>测试类型</a></li><li><a href=#%e6%a1%88%e4%be%8b%e5%88%b6%e5%8a%a8%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%b3%bb%e7%bb%9f%e6%b5%8b%e8%af%95 aria-label=案例：制动系统的系统测试>案例：制动系统的系统测试</a></li></ul></li></ul></li><li><a href=#%e5%ae%9e%e6%88%98%e6%a1%88%e4%be%8b%e8%87%aa%e5%8a%a8%e7%b4%a7%e6%80%a5%e5%88%b6%e5%8a%a8%e7%b3%bb%e7%bb%9faeb%e7%9a%84%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%bc%80%e5%8f%91 aria-label=实战案例：自动紧急制动系统（AEB）的系统级开发>实战案例：自动紧急制动系统（AEB）的系统级开发</a><ul><li><a href=#%e9%a1%b9%e7%9b%ae%e8%83%8c%e6%99%af aria-label=项目背景>项目背景</a></li><li><a href=#%e7%ac%ac%e4%b8%80%e6%ad%a5%e5%88%86%e6%9e%90%e5%8a%9f%e8%83%bd%e5%ae%89%e5%85%a8%e6%a6%82%e5%bf%b5-1 aria-label=第一步：分析功能安全概念>第一步：分析功能安全概念</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e6%ad%a5%e5%bc%80%e5%8f%91%e6%8a%80%e6%9c%af%e5%ae%89%e5%85%a8%e6%a6%82%e5%bf%b5 aria-label=第二步：开发技术安全概念>第二步：开发技术安全概念</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e6%ad%a5%e5%88%b6%e5%ae%9a%e7%b3%bb%e7%bb%9f%e5%ae%89%e5%85%a8%e9%9c%80%e6%b1%82 aria-label=第三步：制定系统安全需求>第三步：制定系统安全需求</a></li><li><a href=#%e7%ac%ac%e5%9b%9b%e6%ad%a5%e5%88%b6%e5%ae%9a%e7%a1%ac%e4%bb%b6%e5%ae%89%e5%85%a8%e9%9c%80%e6%b1%82 aria-label=第四步：制定硬件安全需求>第四步：制定硬件安全需求</a></li><li><a href=#%e7%ac%ac%e4%ba%94%e6%ad%a5%e5%88%b6%e5%ae%9a%e8%bd%af%e4%bb%b6%e5%ae%89%e5%85%a8%e9%9c%80%e6%b1%82 aria-label=第五步：制定软件安全需求>第五步：制定软件安全需求</a></li><li><a href=#%e7%ac%ac%e5%85%ad%e6%ad%a5%e5%ae%9a%e4%b9%89%e7%a1%ac%e4%bb%b6%e8%bd%af%e4%bb%b6%e6%8e%a5%e5%8f%a3 aria-label=第六步：定义硬件/软件接口>第六步：定义硬件/软件接口</a></li><li><a href=#%e7%ac%ac%e4%b8%83%e6%ad%a5%e7%b3%bb%e7%bb%9f%e9%9b%86%e6%88%90%e5%92%8c%e6%b5%8b%e8%af%95 aria-label=第七步：系统集成和测试>第七步：系统集成和测试</a></li></ul></li><li><a href=#%e5%b8%b8%e8%a7%81%e9%94%99%e8%af%af%e5%92%8c%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5 aria-label=常见错误和最佳实践>常见错误和最佳实践</a><ul><li><a href=#%e5%b8%b8%e8%a7%81%e9%94%99%e8%af%af aria-label=常见错误>常见错误</a></li><li><a href=#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5 aria-label=最佳实践>最佳实践</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb aria-label=延伸阅读>延伸阅读</a></li></ul></div></details></div><div class=post-content><h2 id=引言>引言<a hidden class=anchor aria-hidden=true href=#引言>#</a></h2><p>如果说 ISO 26262-3 概念阶段是绘制蓝图，那么 ISO 26262-4 系统级开发就是根据蓝图建造房子的主体结构。在这个阶段，我们将概念阶段定义的抽象安全目标转化为具体的技术实现方案。</p><p>想象一个实际场景：某汽车电子公司开发了一款电子稳定控制系统（ESC），概念阶段确定了"防止车辆失控"的安全目标（ASIL D）。但是，如何实现这个目标？需要什么样的硬件？需要什么样的传感器？如何设计软件架构？如何确保系统在故障时仍然安全？这些都是系统级开发要回答的问题。</p><p>ISO 26262-4 提供了完整的框架，指导我们如何：</p><ul><li>设计系统架构</li><li>将功能安全需求分配到硬件和软件</li><li>定义硬件和软件的接口</li><li>集成和测试系统</li></ul><h2 id=系统级开发的目标和范围>系统级开发的目标和范围<a hidden class=anchor aria-hidden=true href=#系统级开发的目标和范围>#</a></h2><h3 id=系统级开发的核心活动>系统级开发的核心活动<a hidden class=anchor aria-hidden=true href=#系统级开发的核心活动>#</a></h3><p>ISO 26262-4 定义了系统级开发的六个核心活动：</p><ol><li><p><strong>技术安全概念（TSC）的开发</strong></p><ul><li>将功能安全概念转化为技术实现方案</li><li>定义系统架构和安全机制</li></ul></li><li><p><strong>系统安全需求（SSyR）的制定</strong></p><ul><li>从 FSR 派生系统级安全需求</li><li>分配到硬件和软件</li></ul></li><li><p><strong>硬件安全需求（HSR）和软件安全需求（SSR）</strong></p><ul><li>将系统安全需求具体化</li><li>定义硬件和软件的接口</li></ul></li><li><p><strong>系统架构设计</strong></p><ul><li>设计硬件架构</li><li>设计软件架构</li><li>定义硬件和软件的交互</li></ul></li><li><p><strong>硬件/软件集成（HSI）</strong></p><ul><li>定义硬件和软件的接口</li><li>确保接口的一致性</li></ul></li><li><p><strong>系统集成和测试</strong></p><ul><li>集成硬件和软件</li><li>验证系统满足安全需求</li></ul></li></ol><h3 id=系统级开发的输入和输出>系统级开发的输入和输出<a hidden class=anchor aria-hidden=true href=#系统级开发的输入和输出>#</a></h3><h4 id=输入>输入<a hidden class=anchor aria-hidden=true href=#输入>#</a></h4><ul><li><strong>功能安全概念（FSC）</strong>：来自概念阶段</li><li><strong>功能安全需求（FSR）</strong>：来自概念阶段</li><li><strong>安全目标（SG）</strong>：来自概念阶段</li><li><strong>系统需求</strong>：非安全相关的系统需求</li><li><strong>硬件和软件约束</strong>：技术约束、成本约束、时间约束</li></ul><h4 id=输出>输出<a hidden class=anchor aria-hidden=true href=#输出>#</a></h4><ul><li><strong>技术安全概念（TSC）</strong>：技术实现方案</li><li><strong>系统安全需求（SSyR）</strong>：系统级安全需求</li><li><strong>硬件安全需求（HSR）</strong>：硬件级安全需求</li><li><strong>软件安全需求（SSR）</strong>：软件级安全需求</li><li><strong>系统架构设计</strong>：硬件和软件架构</li><li><strong>硬件/软件接口规范（HSIS）</strong>：接口定义</li><li><strong>系统集成测试报告</strong>：测试结果</li></ul><h2 id=技术安全概念tsc的开发>技术安全概念（TSC）的开发<a hidden class=anchor aria-hidden=true href=#技术安全概念tsc的开发>#</a></h2><h3 id=tsc-的定义和作用>TSC 的定义和作用<a hidden class=anchor aria-hidden=true href=#tsc-的定义和作用>#</a></h3><p><strong>技术安全概念（TSC）</strong> 是实现功能安全概念的技术策略。它描述了：</p><ol><li>如何在技术上实现安全目标</li><li>如何在硬件和软件之间分配安全需求</li><li>如何设计安全机制</li><li>如何确保硬件和软件的独立性</li></ol><h3 id=tsc-的开发步骤>TSC 的开发步骤<a hidden class=anchor aria-hidden=true href=#tsc-的开发步骤>#</a></h3><h4 id=第一步分析功能安全概念>第一步：分析功能安全概念<a hidden class=anchor aria-hidden=true href=#第一步分析功能安全概念>#</a></h4><p>首先，需要深入理解概念阶段定义的功能安全概念。</p><h4 id=第二步确定技术实现策略>第二步：确定技术实现策略<a hidden class=anchor aria-hidden=true href=#第二步确定技术实现策略>#</a></h4><p>选择合适的技术方案，如：</p><ul><li>冗余架构（双通道、三模冗余）</li><li>故障检测机制（看门狗、CRC、ECC）</li><li>故障容错机制（投票机制、降级模式）</li><li>故障恢复机制（重启、安全状态切换）</li></ul><h4 id=第三步设计系统架构>第三步：设计系统架构<a hidden class=anchor aria-hidden=true href=#第三步设计系统架构>#</a></h4><p>设计硬件架构和软件架构，并确定安全机制的分配。</p><h4 id=第四步分配安全需求到硬件和软件>第四步：分配安全需求到硬件和软件<a hidden class=anchor aria-hidden=true href=#第四步分配安全需求到硬件和软件>#</a></h4><p>将系统安全需求具体化为硬件安全需求和软件安全需求。</p><h3 id=案例制动系统的技术安全概念>案例：制动系统的技术安全概念<a hidden class=anchor aria-hidden=true href=#案例制动系统的技术安全概念>#</a></h3><p>让我们以**电子液压制动系统（EHB）**为例，展示 TSC 的开发过程。</p><h4 id=功能安全概念来自概念阶段>功能安全概念（来自概念阶段）<a hidden class=anchor aria-hidden=true href=#功能安全概念来自概念阶段>#</a></h4><p><strong>安全目标（SG-1）</strong>：</p><blockquote><p>&ldquo;制动助力系统的故障不得导致制动性能的显著降低，ASIL C&rdquo;</p></blockquote><p><strong>功能安全需求（FSR-1.1）</strong>：</p><blockquote><p>&ldquo;系统应在 100 ms 内检测到制动助力失效&rdquo;</p></blockquote><p><strong>功能安全需求（FSR-1.2）</strong>：</p><blockquote><p>&ldquo;在检测到助力失效后，系统应立即启动机械制动备份&rdquo;</p></blockquote><h4 id=技术实现策略>技术实现策略<a hidden class=anchor aria-hidden=true href=#技术实现策略>#</a></h4><p><strong>技术方案选择</strong>：</p><ol><li><strong>冗余架构</strong>：双通道控制器架构</li><li><strong>故障检测</strong>：压力传感器冗余、电流监测、看门狗</li><li><strong>故障容错</strong>：主通道故障时切换到备份通道</li><li><strong>故障恢复</strong>：系统重启、故障记录</li></ol><h4 id=系统架构设计>系统架构设计<a hidden class=anchor aria-hidden=true href=#系统架构设计>#</a></h4><p><strong>硬件架构</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                    电源管理单元
</span></span><span class=line><span class=cl>                         │
</span></span><span class=line><span class=cl>          ┌──────────────┼──────────────┐
</span></span><span class=line><span class=cl>          │              │              │
</span></span><span class=line><span class=cl>    主控制器（MCU1）  备份控制器（MCU2）  安全监控器
</span></span><span class=line><span class=cl>          │              │              │
</span></span><span class=line><span class=cl>          │              │              │
</span></span><span class=line><span class=cl>    压力传感器1      压力传感器2      阀门驱动
</span></span><span class=line><span class=cl>          │              │              │
</span></span><span class=line><span class=cl>          └──────────────┼──────────────┘
</span></span><span class=line><span class=cl>                         │
</span></span><span class=line><span class=cl>                    液压执行单元
</span></span><span class=line><span class=cl>                         │
</span></span><span class=line><span class=cl>                    车轮制动器
</span></span></code></pre></div><p><strong>软件架构</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>应用层
</span></span><span class=line><span class=cl>    ├── 控制算法层
</span></span><span class=line><span class=cl>    │   ├── 制动控制
</span></span><span class=line><span class=cl>    │   ├── 压力调节
</span></span><span class=line><span class=cl>    │   └── 故障诊断
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>中间件层
</span></span><span class=line><span class=cl>    ├── 通信层（CAN、SPI）
</span></span><span class=line><span class=cl>    ├── 诊断层（UDS）
</span></span><span class=line><span class=cl>    └── 时间管理
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>硬件抽象层（HAL）
</span></span><span class=line><span class=cl>    ├── ADC 驱动
</span></span><span class=line><span class=cl>    ├── GPIO 驱动
</span></span><span class=line><span class=cl>    ├── SPI 驱动
</span></span><span class=line><span class=cl>    └── 看门狗驱动
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>硬件层
</span></span><span class=line><span class=cl>    ├── MCU1
</span></span><span class=line><span class=cl>    ├── MCU2
</span></span><span class=line><span class=cl>    ├── 传感器
</span></span><span class=line><span class=cl>    └── 执行器
</span></span></code></pre></div><h4 id=技术安全需求>技术安全需求<a hidden class=anchor aria-hidden=true href=#技术安全需求>#</a></h4><p><strong>TSR-1.1.1</strong>：</p><blockquote><p>&ldquo;硬件应实现双通道压力传感器，每个传感器由独立的 MCU 监测&rdquo;</p></blockquote><p><strong>TSR-1.1.2</strong>：</p><blockquote><p>&ldquo;软件应每 10 ms 读取一次压力传感器数据，并执行一致性检查&rdquo;</p></blockquote><p><strong>TSR-1.2.1</strong>：</p><blockquote><p>&ldquo;硬件应实现双通道控制器架构，主/备通道独立运行&rdquo;</p></blockquote><p><strong>TSR-1.2.2</strong>：</p><blockquote><p>&ldquo;软件应实现主/备通道的故障检测和切换逻辑&rdquo;</p></blockquote><p><strong>TSR-1.3.1</strong>：</p><blockquote><p>&ldquo;硬件应实现独立于 CPU 的看门狗定时器&rdquo;</p></blockquote><p><strong>TSR-1.3.2</strong>：</p><blockquote><p>&ldquo;软件应定期喂狗（例如每 5 ms）&rdquo;</p></blockquote><h2 id=系统安全需求ssyr的制定>系统安全需求（SSyR）的制定<a hidden class=anchor aria-hidden=true href=#系统安全需求ssyr的制定>#</a></h2><h3 id=ssyr-的定义和作用>SSyR 的定义和作用<a hidden class=anchor aria-hidden=true href=#ssyr-的定义和作用>#</a></h3><p><strong>系统安全需求（SSyR）</strong> 是系统级的安全需求，它从功能安全需求派生而来，是硬件和软件需求的桥梁。</p><h3 id=ssyr-的分类>SSyR 的分类<a hidden class=anchor aria-hidden=true href=#ssyr-的分类>#</a></h3><h4 id=1-性能需求>1. 性能需求<a hidden class=anchor aria-hidden=true href=#1-性能需求>#</a></h4><p>定义系统的性能指标，如：</p><ul><li>响应时间</li><li>故障检测时间</li><li>故障恢复时间</li></ul><h4 id=2-功能需求>2. 功能需求<a hidden class=anchor aria-hidden=true href=#2-功能需求>#</a></h4><p>定义系统的功能要求，如：</p><ul><li>故障检测功能</li><li>故障容错功能</li><li>故障恢复功能</li></ul><h4 id=3-接口需求>3. 接口需求<a hidden class=anchor aria-hidden=true href=#3-接口需求>#</a></h4><p>定义系统内部和外部接口，如：</p><ul><li>硬件/软件接口</li><li>与其他系统的接口</li></ul><h4 id=4-约束需求>4. 约束需求<a hidden class=anchor aria-hidden=true href=#4-约束需求>#</a></h4><p>定义系统的约束条件，如：</p><ul><li>硬件资源约束</li><li>软件资源约束</li><li>时序约束</li></ul><h3 id=案例制动系统的系统安全需求>案例：制动系统的系统安全需求<a hidden class=anchor aria-hidden=true href=#案例制动系统的系统安全需求>#</a></h3><p><strong>SSyR-1</strong>（来自 FSR-1.1）：</p><blockquote><p>&ldquo;系统应在 100 ms 内检测到制动助力失效&rdquo;</p></blockquote><p><strong>SSyR-1.1</strong>（性能需求）：</p><blockquote><p>&ldquo;压力传感器的采样周期不得大于 10 ms&rdquo;</p></blockquote><p><strong>SSyR-1.2</strong>（功能需求）：</p><blockquote><p>&ldquo;系统应实现压力传感器故障诊断算法&rdquo;</p></blockquote><p><strong>SSyR-1.3</strong>（性能需求）：</p><blockquote><p>&ldquo;故障诊断算法的执行时间不得超过 20 ms&rdquo;</p></blockquote><p><strong>SSyR-1.4</strong>（功能需求）：</p><blockquote><p>&ldquo;系统应实现压力传感器数据一致性检查&rdquo;</p></blockquote><p><strong>SSyR-2</strong>（来自 FSR-1.2）：</p><blockquote><p>&ldquo;在检测到助力失效后，系统应立即启动机械制动备份&rdquo;</p></blockquote><p><strong>SSyR-2.1</strong>（功能需求）：</p><blockquote><p>&ldquo;系统应实现主/备通道故障检测和切换逻辑&rdquo;</p></blockquote><p><strong>SSyR-2.2</strong>（性能需求）：</p><blockquote><p>&ldquo;通道切换时间不得超过 50 ms&rdquo;</p></blockquote><p><strong>SSyR-2.3</strong>（功能需求）：</p><blockquote><p>&ldquo;系统应实现机械制动备份路径的控制逻辑&rdquo;</p></blockquote><h2 id=硬件安全需求hsr和软件安全需求ssr>硬件安全需求（HSR）和软件安全需求（SSR）<a hidden class=anchor aria-hidden=true href=#硬件安全需求hsr和软件安全需求ssr>#</a></h2><h3 id=hsr-的定义和作用>HSR 的定义和作用<a hidden class=anchor aria-hidden=true href=#hsr-的定义和作用>#</a></h3><p><strong>硬件安全需求（HSR）</strong> 是对硬件的具体安全要求。</p><h4 id=hsr-的内容>HSR 的内容<a hidden class=anchor aria-hidden=true href=#hsr-的内容>#</a></h4><ol><li><p><strong>硬件组件需求</strong>：</p><ul><li>MCU 选型要求</li><li>传感器选型要求</li><li>执行器选型要求</li></ul></li><li><p><strong>硬件接口需求</strong>：</p><ul><li>电源接口</li><li>信号接口</li><li>通信接口</li></ul></li><li><p><strong>硬件安全机制需求</strong>：</p><ul><li>看门狗定时器</li><li>ECC 内存</li><li>冗余设计</li></ul></li></ol><h3 id=ssr-的定义和作用>SSR 的定义和作用<a hidden class=anchor aria-hidden=true href=#ssr-的定义和作用>#</a></h3><p><strong>软件安全需求（SSR）</strong> 是对软件的具体安全要求。</p><h4 id=ssr-的内容>SSR 的内容<a hidden class=anchor aria-hidden=true href=#ssr-的内容>#</a></h4><ol><li><p><strong>软件架构需求</strong>：</p><ul><li>分层架构</li><li>模块化设计</li><li>独立性要求</li></ul></li><li><p><strong>软件功能需求</strong>：</p><ul><li>故障检测算法</li><li>故障容错逻辑</li><li>故障恢复流程</li></ul></li><li><p><strong>软件质量需求</strong>：</p><ul><li>MISRA C 编码规范</li><li>代码复杂度要求</li><li>测试覆盖率要求</li></ul></li></ol><h3 id=案例制动系统的-hsr-和-ssr>案例：制动系统的 HSR 和 SSR<a hidden class=anchor aria-hidden=true href=#案例制动系统的-hsr-和-ssr>#</a></h3><h4 id=hsr-111来自-tsr-111>HSR-1.1.1（来自 TSR-1.1.1）：<a hidden class=anchor aria-hidden=true href=#hsr-111来自-tsr-111>#</a></h4><blockquote><p>&ldquo;硬件应实现双通道压力传感器，每个传感器由独立的 MCU 监测&rdquo;</p></blockquote><p><strong>具体要求</strong>：</p><ul><li>压力传感器型号：Bosch 0 986 593 501</li><li>压力传感器精度：±0.1 bar</li><li>压力传感器故障模式检测：开路、短路、漂移</li><li>MCU1 和 MCU2 应独立供电</li></ul><h4 id=hsr-131来自-tsr-131>HSR-1.3.1（来自 TSR-1.3.1）：<a hidden class=anchor aria-hidden=true href=#hsr-131来自-tsr-131>#</a></h4><blockquote><p>&ldquo;硬件应实现独立于 CPU 的看门狗定时器&rdquo;</p></blockquote><p><strong>具体要求</strong>：</p><ul><li>看门狗类型：外部窗口看门狗</li><li>看门狗超时时间：可配置（默认 100 ms）</li><li>看门狗复位类型：系统复位</li></ul><h4 id=ssr-112来自-tsr-112>SSR-1.1.2（来自 TSR-1.1.2）：<a hidden class=anchor aria-hidden=true href=#ssr-112来自-tsr-112>#</a></h4><blockquote><p>&ldquo;软件应每 10 ms 读取一次压力传感器数据，并执行一致性检查&rdquo;</p></blockquote><p><strong>具体要求</strong>：</p><ul><li>使用硬件定时器中断，周期 10 ms</li><li>一致性检查算法：<ul><li>如果 |P1 - P2| > 阈值，判定为故障</li><li>阈值根据工况动态调整</li></ul></li><li>故障判定逻辑：<ul><li>连续 3 次检测到不一致，判定为传感器故障</li></ul></li></ul><h4 id=ssr-122来自-tsr-122>SSR-1.2.2（来自 TSR-1.2.2）：<a hidden class=anchor aria-hidden=true href=#ssr-122来自-tsr-122>#</a></h4><blockquote><p>&ldquo;软件应实现主/备通道的故障检测和切换逻辑&rdquo;</p></blockquote><p><strong>具体要求</strong>：</p><ul><li>主通道故障检测：<ul><li>MCU1 看门狗超时</li><li>MCU1 压力传感器故障</li><li>MCU1 通信故障</li></ul></li><li>切换逻辑：<ul><li>检测到主通道故障，立即切换到备份通道</li><li>切换时间 &lt; 50 ms</li><li>切换过程中保持制动功能</li></ul></li></ul><h2 id=系统架构设计-1>系统架构设计<a hidden class=anchor aria-hidden=true href=#系统架构设计-1>#</a></h2><h3 id=硬件架构设计>硬件架构设计<a hidden class=anchor aria-hidden=true href=#硬件架构设计>#</a></h3><h4 id=硬件架构的原则>硬件架构的原则<a hidden class=anchor aria-hidden=true href=#硬件架构的原则>#</a></h4><ol><li><strong>独立性原则</strong>：冗余通道之间应该独立，避免共因故障</li><li><strong>多样性原则</strong>：不同通道采用不同的实现方式，避免系统性故障</li><li><strong>诊断性原则</strong>：硬件应具备自诊断能力</li></ol><h4 id=硬件架构的类型>硬件架构的类型<a hidden class=anchor aria-hidden=true href=#硬件架构的类型>#</a></h4><ol><li><p><strong>单通道架构</strong>：</p><ul><li>适用于 ASIL A/B</li><li>成本低</li><li>安全性有限</li></ul></li><li><p><strong>双通道冗余架构</strong>：</p><ul><li>适用于 ASIL C/D</li><li>成本中等</li><li>安全性高</li></ul></li><li><p><strong>三模冗余架构（TMR）</strong>：</p><ul><li>适用于 ASIL D 高要求场景</li><li>成本高</li><li>安全性最高</li></ul></li></ol><h4 id=案例asil-d-系统的三模冗余架构>案例：ASIL D 系统的三模冗余架构<a hidden class=anchor aria-hidden=true href=#案例asil-d-系统的三模冗余架构>#</a></h4><p>对于 ASIL D 的电子驻车制动系统（EPB），采用三模冗余架构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>           传感器
</span></span><span class=line><span class=cl>             │
</span></span><span class=line><span class=cl>    ┌────────┼────────┐
</span></span><span class=line><span class=cl>    │        │        │
</span></span><span class=line><span class=cl>  MCU1     MCU2     MCU3
</span></span><span class=line><span class=cl>    │        │        │
</span></span><span class=line><span class=cl>    └────────┼────────┘
</span></span><span class=line><span class=cl>             │
</span></span><span class=line><span class=cl>         投票器
</span></span><span class=line><span class=cl>             │
</span></span><span class=line><span class=cl>          执行器
</span></span></code></pre></div><p><strong>可靠性计算</strong>：</p><p>假设单个 MCU 的可靠度为 $R = 0.9999$（在任务时间内）。</p><p>系统成功运行的条件是：至少两个 MCU 正常工作。</p><p>$$ R_{\text{system}} = R^3 + 3 \times R^2 \times (1-R) $$</p><p>代入数值：
$$ R_{\text{system}} = 0.9999^3 + 3 \times 0.9999^2 \times 0.0001 $$
$$ R_{\text{system}} = 0.9997 + 0.00029997 $$
$$ R_{\text{system}} = 0.99999997 $$</p><p>可以看到，通过三模冗余，系统可靠度从 99.99% 提升到了 99.999997%。</p><h3 id=软件架构设计>软件架构设计<a hidden class=anchor aria-hidden=true href=#软件架构设计>#</a></h3><h4 id=软件架构的原则>软件架构的原则<a hidden class=anchor aria-hidden=true href=#软件架构的原则>#</a></h4><ol><li><strong>分层原则</strong>：应用层、中间件层、硬件抽象层、硬件层</li><li><strong>模块化原则</strong>：每个模块功能单一，接口清晰</li><li><strong>独立性原则</strong>：安全相关软件与非安全相关软件分离</li></ol><h4 id=软件架构的类型>软件架构的类型<a hidden class=anchor aria-hidden=true href=#软件架构的类型>#</a></h4><ol><li><p><strong>分层架构</strong>：</p><ul><li>优点：模块化、可维护性好</li><li>缺点：性能开销大</li></ul></li><li><p><strong>面向对象架构</strong>：</p><ul><li>优点：灵活性高、可扩展性好</li><li>缺点：资源消耗大</li></ul></li><li><p><strong>事件驱动架构</strong>：</p><ul><li>优点：实时性好、响应快</li><li>缺点：调试困难</li></ul></li></ol><h4 id=案例制动系统的软件架构>案例：制动系统的软件架构<a hidden class=anchor aria-hidden=true href=#案例制动系统的软件架构>#</a></h4><p><strong>分层架构设计</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>应用层（Application Layer）
</span></span><span class=line><span class=cl>    ├── 制动控制模块
</span></span><span class=line><span class=cl>    │   ├── 压力控制算法
</span></span><span class=line><span class=cl>    │   ├── 车轮速度控制
</span></span><span class=line><span class=cl>    │   └── 车辆稳定性控制
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ├── 故障诊断模块
</span></span><span class=line><span class=cl>    │   ├── 传感器故障诊断
</span></span><span class=line><span class=cl>    │   ├── 执行器故障诊断
</span></span><span class=line><span class=cl>    │   └── 系统故障诊断
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ├── 安全管理模块
</span></span><span class=line><span class=cl>    │   ├── 故障处理逻辑
</span></span><span class=line><span class=cl>    │   ├── 安全状态管理
</span></span><span class=line><span class=cl>    │   └── 故障记录
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    └── 通信模块
</span></span><span class=line><span class=cl>        ├── CAN 通信
</span></span><span class=line><span class=cl>        └── 诊断服务
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>中间件层（Middleware Layer）
</span></span><span class=line><span class=cl>    ├── 操作系统抽象层（OSAL）
</span></span><span class=line><span class=cl>    │   ├── 任务调度
</span></span><span class=line><span class=cl>    │   ├── 事件管理
</span></span><span class=line><span class=cl>    │   └── 定时器管理
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ├── 通信层（Communication Layer）
</span></span><span class=line><span class=cl>    │   ├── CAN 驱动
</span></span><span class=line><span class=cl>    │   ├── SPI 驱动
</span></span><span class=line><span class=cl>    │   └── LIN 驱动
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    └── 存储层（Storage Layer）
</span></span><span class=line><span class=cl>        ├── EEPROM 驱动
</span></span><span class=line><span class=cl>        └── Flash 驱动
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>硬件抽象层（HAL）
</span></span><span class=line><span class=cl>    ├── ADC 驱动
</span></span><span class=line><span class=cl>    ├── GPIO 驱动
</span></span><span class=line><span class=cl>    ├── PWM 驱动
</span></span><span class=line><span class=cl>    ├── 定时器驱动
</span></span><span class=line><span class=cl>    └── 看门狗驱动
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>硬件层（Hardware Layer）
</span></span><span class=line><span class=cl>    ├── MCU
</span></span><span class=line><span class=cl>    ├── 传感器
</span></span><span class=line><span class=cl>    ├── 执行器
</span></span><span class=line><span class=cl>    └── 电源管理
</span></span></code></pre></div><p><strong>软件模块接口定义</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 制动控制模块接口
</span></span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>pedal_position</span><span class=p>;</span>      <span class=c1>// 制动踏板位置（0-1）
</span></span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>vehicle_speed</span><span class=p>;</span>       <span class=c1>// 车辆速度（km/h）
</span></span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>wheel_speeds</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>     <span class=c1>// 车轮速度（km/h）
</span></span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>BrakingControlInput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>target_pressure</span><span class=p>;</span>     <span class=c1>// 目标制动压力（bar）
</span></span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>valve_command</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>     <span class=c1>// 阀门控制指令（0-1）
</span></span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>BrakingControlOutput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 函数原型
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>BrakingControl_Init</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>BrakingControl_Run</span><span class=p>(</span><span class=k>const</span> <span class=n>BrakingControlInput</span><span class=o>*</span> <span class=n>input</span><span class=p>,</span> <span class=n>BrakingControlOutput</span><span class=o>*</span> <span class=n>output</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 故障诊断模块接口
</span></span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FAULT_NONE</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FAULT_SENSOR_OPEN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FAULT_SENSOR_SHORT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FAULT_SENSOR_DRIFT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FAULT_ACTUATOR_STUCK</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FAULT_WATCHDOG_TIMEOUT</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>FaultType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FaultType</span> <span class=n>fault_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>component_id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>timestamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>FaultEvent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 函数原型
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FaultDiagnosis_Init</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FaultDiagnosis_Run</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>FaultDiagnosis_GetFault</span><span class=p>(</span><span class=n>FaultEvent</span><span class=o>*</span> <span class=n>event</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=硬件软件集成hsi>硬件/软件集成（HSI）<a hidden class=anchor aria-hidden=true href=#硬件软件集成hsi>#</a></h2><h3 id=hsi-的定义和作用>HSI 的定义和作用<a hidden class=anchor aria-hidden=true href=#hsi-的定义和作用>#</a></h3><p><strong>硬件/软件集成（HSI）</strong> 是定义硬件和软件接口的过程。</p><h3 id=hsi-的内容>HSI 的内容<a hidden class=anchor aria-hidden=true href=#hsi-的内容>#</a></h3><h4 id=1-内存映射>1. 内存映射<a hidden class=anchor aria-hidden=true href=#1-内存映射>#</a></h4><p>定义硬件寄存器的内存地址，软件通过读写这些寄存器来控制硬件。</p><h4 id=2-中断向量表>2. 中断向量表<a hidden class=anchor aria-hidden=true href=#2-中断向量表>#</a></h4><p>定义硬件中断源和软件中断处理程序的对应关系。</p><h4 id=3-数据结构>3. 数据结构<a hidden class=anchor aria-hidden=true href=#3-数据结构>#</a></h4><p>定义硬件和软件之间交换数据的格式。</p><h4 id=4-时序约束>4. 时序约束<a hidden class=anchor aria-hidden=true href=#4-时序约束>#</a></h4><p>定义硬件和软件之间交互的时间要求。</p><h3 id=案例制动系统的-hsi>案例：制动系统的 HSI<a hidden class=anchor aria-hidden=true href=#案例制动系统的-hsi>#</a></h3><h4 id=内存映射>内存映射<a hidden class=anchor aria-hidden=true href=#内存映射>#</a></h4><table><thead><tr><th>寄存器名称</th><th>地址</th><th>访问类型</th><th>描述</th></tr></thead><tbody><tr><td>P1_DATA_REG</td><td>0x4000 0000</td><td>R</td><td>压力传感器1数据寄存器</td></tr><tr><td>P2_DATA_REG</td><td>0x4000 0004</td><td>R</td><td>压力传感器2数据寄存器</td></tr><tr><td>VALVE_CMD_REG</td><td>0x4000 0008</td><td>W</td><td>阀门控制寄存器</td></tr><tr><td>WDT_FEED_REG</td><td>0x4000 000C</td><td>W</td><td>看门狗喂狗寄存器</td></tr><tr><td>STATUS_REG</td><td>0x4000 0010</td><td>R</td><td>状态寄存器</td></tr></tbody></table><h4 id=中断向量表>中断向量表<a hidden class=anchor aria-hidden=true href=#中断向量表>#</a></h4><table><thead><tr><th>中断源</th><th>优先级</th><th>中断处理函数</th><th>描述</th></tr></thead><tbody><tr><td>Timer0</td><td>1</td><td>Timer0_ISR</td><td>10ms 定时中断</td></tr><tr><td>ADC_Conv_Complete</td><td>2</td><td>ADC_ISR</td><td>ADC 转换完成中断</td></tr><tr><td>CAN_Rx</td><td>3</td><td>CAN_Rx_ISR</td><td>CAN 接收中断</td></tr><tr><td>WDT_Timeout</td><td>4</td><td>WDT_ISR</td><td>看门狗超时中断</td></tr></tbody></table><h4 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 硬件寄存器定义
</span></span></span><span class=line><span class=cl><span class=cp>#define P1_DATA_REG   (*(volatile uint32_t*)0x40000000)
</span></span></span><span class=line><span class=cl><span class=cp>#define P2_DATA_REG   (*(volatile uint32_t*)0x40000004)
</span></span></span><span class=line><span class=cl><span class=cp>#define VALVE_CMD_REG (*(volatile uint32_t*)0x40000008)
</span></span></span><span class=line><span class=cl><span class=cp>#define WDT_FEED_REG  (*(volatile uint32_t*)0x4000000C)
</span></span></span><span class=line><span class=cl><span class=cp>#define STATUS_REG    (*(volatile uint32_t*)0x40000010)
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 硬件状态定义
</span></span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>p1_ready</span>      <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// 压力传感器1就绪
</span></span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>p2_ready</span>      <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// 压力传感器2就绪
</span></span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>valve_error</span>   <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// 阀门错误
</span></span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>wdt_timeout</span>   <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// 看门狗超时
</span></span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=nl>reserved</span>      <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>  <span class=c1>// 保留
</span></span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>HardwareStatus</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=时序约束>时序约束<a hidden class=anchor aria-hidden=true href=#时序约束>#</a></h4><table><thead><tr><th>操作</th><th>时间要求</th><th>说明</th></tr></thead><tbody><tr><td>传感器采样</td><td>10 ms</td><td>定期读取传感器数据</td></tr><tr><td>控制算法执行</td><td>&lt; 5 ms</td><td>单次控制算法执行时间</td></tr><tr><td>阀门响应</td><td>&lt; 10 ms</td><td>从发出指令到阀门动作的时间</td></tr><tr><td>故障检测</td><td>&lt; 20 ms</td><td>从故障发生到检测到故障的时间</td></tr><tr><td>安全状态切换</td><td>&lt; 50 ms</td><td>从检测到故障到进入安全状态的时间</td></tr></tbody></table><h2 id=系统集成和测试>系统集成和测试<a hidden class=anchor aria-hidden=true href=#系统集成和测试>#</a></h2><h3 id=系统集成>系统集成<a hidden class=anchor aria-hidden=true href=#系统集成>#</a></h3><p>系统集成的步骤：</p><ol><li><strong>单元测试</strong>：测试每个硬件组件和软件模块</li><li><strong>集成测试</strong>：测试硬件和软件的集成</li><li><strong>系统测试</strong>：测试整个系统的功能</li><li><strong>验收测试</strong>：验证系统满足需求</li></ol><h3 id=系统测试>系统测试<a hidden class=anchor aria-hidden=true href=#系统测试>#</a></h3><h4 id=测试类型>测试类型<a hidden class=anchor aria-hidden=true href=#测试类型>#</a></h4><ol><li><p><strong>功能测试</strong>：</p><ul><li>测试系统是否实现了所有功能</li><li>测试各种正常和异常场景</li></ul></li><li><p><strong>性能测试</strong>：</p><ul><li>测试系统的响应时间</li><li>测试系统的吞吐量</li></ul></li><li><p><strong>安全测试</strong>：</p><ul><li>故障注入测试</li><li>安全状态切换测试</li><li>冗余机制测试</li></ul></li><li><p><strong>可靠性测试</strong>：</p><ul><li>长时间运行测试</li><li>压力测试</li></ul></li></ol><h4 id=案例制动系统的系统测试>案例：制动系统的系统测试<a hidden class=anchor aria-hidden=true href=#案例制动系统的系统测试>#</a></h4><p><strong>测试用例 1：压力传感器故障检测</strong></p><p><strong>测试步骤</strong>：</p><ol><li>系统上电初始化</li><li>模拟压力传感器1开路故障</li><li>等待 30 ms</li><li>检查系统是否检测到故障</li><li>检查系统是否进入安全状态</li></ol><p><strong>预期结果</strong>：</p><ul><li>系统在 30 ms 内检测到传感器1开路故障</li><li>系统切换到传感器2</li><li>系统向驾驶员发出报警</li></ul><p><strong>测试用例 2：主控制器故障检测</strong></p><p><strong>测试步骤</strong>：</p><ol><li>系统上电初始化</li><li>模拟主控制器（MCU1）看门狗超时</li><li>等待 60 ms</li><li>检查系统是否检测到故障</li><li>检查系统是否切换到备份控制器</li></ol><p><strong>预期结果</strong>：</p><ul><li>系统在 60 ms 内检测到主控制器故障</li><li>系统切换到备份控制器</li><li>制动功能保持正常</li></ul><p><strong>测试用例 3：阀门故障容错</strong></p><p><strong>测试步骤</strong>：</p><ol><li>系统上电初始化</li><li>模拟阀门卡死故障</li><li>施加制动踏板</li><li>检查系统是否检测到故障</li><li>检查系统是否进入安全状态</li></ol><p><strong>预期结果</strong>：</p><ul><li>系统检测到阀门卡死故障</li><li>系统进入安全状态（机械制动备份）</li><li>驾驶员可以继续制动</li></ul><h2 id=实战案例自动紧急制动系统aeb的系统级开发>实战案例：自动紧急制动系统（AEB）的系统级开发<a hidden class=anchor aria-hidden=true href=#实战案例自动紧急制动系统aeb的系统级开发>#</a></h2><p>让我们以一个实际项目为例，展示系统级开发的完整流程。</p><h3 id=项目背景>项目背景<a hidden class=anchor aria-hidden=true href=#项目背景>#</a></h3><p>某汽车厂商正在开发 AEB 系统，用于在检测到碰撞风险时自动施加制动，避免或减轻碰撞。</p><h3 id=第一步分析功能安全概念-1>第一步：分析功能安全概念<a hidden class=anchor aria-hidden=true href=#第一步分析功能安全概念-1>#</a></h3><p><strong>来自概念阶段的安全目标（SG）</strong>：</p><blockquote><p>&ldquo;AEB 系统不得在未检测到碰撞风险时误制动，ASIL D&rdquo;</p></blockquote><p><strong>功能安全需求（FSR）</strong>：</p><blockquote><p>&ldquo;AEB 系统应准确检测碰撞风险，误判率 &lt; 0.001%&rdquo;</p></blockquote><h3 id=第二步开发技术安全概念>第二步：开发技术安全概念<a hidden class=anchor aria-hidden=true href=#第二步开发技术安全概念>#</a></h3><p><strong>技术方案选择</strong>：</p><ol><li><strong>传感器融合</strong>：摄像头 + 雷达 + 超声波传感器</li><li><strong>冗余架构</strong>：双通道 ECU 架构</li><li><strong>故障检测</strong>：传感器健康监测、数据一致性检查</li><li><strong>故障容错</strong>：单传感器故障时仍能工作</li></ol><p><strong>系统架构设计</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                    ┌─────────┐
</span></span><span class=line><span class=cl>                    │  摄像头 │
</span></span><span class=line><span class=cl>                    └────┬────┘
</span></span><span class=line><span class=cl>                         │
</span></span><span class=line><span class=cl>                    ┌────▼────┐
</span></span><span class=line><span class=cl>                    │ 前雷达  │
</span></span><span class=line><span class=cl>                    └────┬────┘
</span></span><span class=line><span class=cl>                         │
</span></span><span class=line><span class=cl>                    ┌────▼────┐
</span></span><span class=line><span class=cl>                    │ 超声波  │
</span></span><span class=line><span class=cl>                    └────┬────┘
</span></span><span class=line><span class=cl>                         │
</span></span><span class=line><span class=cl>                    ┌────▼──────────────┐
</span></span><span class=line><span class=cl>                    │   传感器融合单元   │
</span></span><span class=line><span class=cl>                    └────┬──────────────┘
</span></span><span class=line><span class=cl>                         │
</span></span><span class=line><span class=cl>          ┌──────────────┼──────────────┐
</span></span><span class=line><span class=cl>          │              │              │
</span></span><span class=line><span class=cl>    主控制器（ECU1）  备份控制器（ECU2）  安全监控器
</span></span><span class=line><span class=cl>          │              │              │
</span></span><span class=line><span class=cl>          └──────────────┼──────────────┘
</span></span><span class=line><span class=cl>                         │
</span></span><span class=line><span class=cl>                    制动执行器
</span></span></code></pre></div><h3 id=第三步制定系统安全需求>第三步：制定系统安全需求<a hidden class=anchor aria-hidden=true href=#第三步制定系统安全需求>#</a></h3><p><strong>SSyR-1</strong>（来自 FSR）：</p><blockquote><p>&ldquo;AEB 系统应准确检测碰撞风险，误判率 &lt; 0.001%&rdquo;</p></blockquote><p><strong>SSyR-1.1</strong>（功能需求）：</p><blockquote><p>&ldquo;系统应实现多传感器融合算法，综合判断碰撞风险&rdquo;</p></blockquote><p><strong>SSyR-1.2</strong>（性能需求）：</p><blockquote><p>&ldquo;碰撞风险检测时间不得大于 50 ms&rdquo;</p></blockquote><p><strong>SSyR-1.3</strong>（功能需求）：</p><blockquote><p>&ldquo;系统应实现传感器健康监测，检测传感器故障&rdquo;</p></blockquote><p><strong>SSyR-2</strong>（来自 FSR）：</p><blockquote><p>&ldquo;系统在检测到碰撞风险时，应及时施加制动&rdquo;</p></blockquote><p><strong>SSyR-2.1</strong>（性能需求）：</p><blockquote><p>&ldquo;从检测到碰撞风险到施加制动的时间不得大于 150 ms&rdquo;</p></blockquote><h3 id=第四步制定硬件安全需求>第四步：制定硬件安全需求<a hidden class=anchor aria-hidden=true href=#第四步制定硬件安全需求>#</a></h3><p><strong>HSR-1.1.1</strong>（传感器选型）：</p><blockquote><p>&ldquo;摄像头应具备车道检测和障碍物检测功能&rdquo;</p></blockquote><p><strong>具体要求</strong>：</p><ul><li>分辨率：1280 × 720</li><li>帧率：30 fps</li><li>视场角：90°</li></ul><p><strong>HSR-1.1.2</strong>（ECU 选型）：</p><blockquote><p>&ldquo;ECU 应具备双核处理器，分别运行主/备通道&rdquo;</p></blockquote><p><strong>具体要求</strong>：</p><ul><li>CPU：双核 ARM Cortex-A53 @ 1.5GHz</li><li>内存：4GB DDR4</li><li>存储：32GB eMMC</li></ul><h3 id=第五步制定软件安全需求>第五步：制定软件安全需求<a hidden class=anchor aria-hidden=true href=#第五步制定软件安全需求>#</a></h3><p><strong>SSR-1.1.1</strong>（传感器融合算法）：</p><blockquote><p>&ldquo;软件应实现卡尔曼滤波算法，融合多传感器数据&rdquo;</p></blockquote><p><strong>具体要求</strong>：</p><ul><li>算法类型：扩展卡尔曼滤波（EKF）</li><li>更新频率：10 Hz</li><li>预测误差：距离 &lt; 0.5m，速度 &lt; 1km/h</li></ul><p><strong>SSR-1.3.1</strong>（传感器故障诊断）：</p><blockquote><p>&ldquo;软件应实现传感器数据一致性检查&rdquo;</p></blockquote><p><strong>具体要求</strong>：</p><ul><li>检查方法：多传感器数据交叉验证</li><li>故障判定：连续 5 次数据不一致</li><li>故障响应：标记传感器为不可用，并报警</li></ul><h3 id=第六步定义硬件软件接口>第六步：定义硬件/软件接口<a hidden class=anchor aria-hidden=true href=#第六步定义硬件软件接口>#</a></h3><p><strong>内存映射</strong>：</p><table><thead><tr><th>寄存器名称</th><th>地址</th><th>访问类型</th><th>描述</th></tr></thead><tbody><tr><td>CAMERA_DATA_REG</td><td>0x5000 0000</td><td>R</td><td>摄像头数据寄存器</td></tr><tr><td>RADAR_DATA_REG</td><td>0x5000 0100</td><td>R</td><td>雷达数据寄存器</td></tr><tr><td>ULTRASONIC_DATA_REG</td><td>0x5000 0200</td><td>R</td><td>超声波数据寄存器</td></tr><tr><td>BRAKE_CMD_REG</td><td>0x5000 0300</td><td>W</td><td>制动命令寄存器</td></tr><tr><td>STATUS_REG</td><td>0x5000 0400</td><td>R</td><td>状态寄存器</td></tr></tbody></table><p><strong>中断向量表</strong>：</p><table><thead><tr><th>中断源</th><th>优先级</th><th>中断处理函数</th><th>描述</th></tr></thead><tbody><tr><td>Timer0</td><td>1</td><td>Timer0_ISR</td><td>10ms 定时中断（控制循环）</td></tr><tr><td>Camera_Frame</td><td>2</td><td>Camera_ISR</td><td>摄像头帧中断</td></tr><tr><td>Radar_Data</td><td>3</td><td>Radar_ISR</td><td>雷达数据中断</td></tr><tr><td>Ultrasonic_Data</td><td>4</td><td>Ultrasonic_ISR</td><td>超声波数据中断</td></tr><tr><td>CAN_Rx</td><td>5</td><td>CAN_Rx_ISR</td><td>CAN 接收中断</td></tr></tbody></table><h3 id=第七步系统集成和测试>第七步：系统集成和测试<a hidden class=anchor aria-hidden=true href=#第七步系统集成和测试>#</a></h3><p><strong>集成测试计划</strong>：</p><table><thead><tr><th>测试用例</th><th>测试目的</th><th>测试步骤</th><th>预期结果</th></tr></thead><tbody><tr><td>TC-1</td><td>正常制动功能</td><td>模拟障碍物出现，检测AEB是否制动</td><td>AEB及时制动，避免碰撞</td></tr><tr><td>TC-2</td><td>摄像头故障容错</td><td>模拟摄像头故障，检测AEB是否工作</td><td>AEB切换到雷达+超声波，正常工作</td></tr><tr><td>TC-3</td><td>雷达故障容错</td><td>模拟雷达故障，检测AEB是否工作</td><td>AEB切换到摄像头+超声波，正常工作</td></tr><tr><td>TC-4</td><td>误制动测试</td><td>正常驾驶，检测AEB是否误制动</td><td>AEB不误制动</td></tr><tr><td>TC-5</td><td>响应时间测试</td><td>测量从检测障碍物到制动的时间</td><td>响应时间 &lt; 150 ms</td></tr></tbody></table><h2 id=常见错误和最佳实践>常见错误和最佳实践<a hidden class=anchor aria-hidden=true href=#常见错误和最佳实践>#</a></h2><h3 id=常见错误>常见错误<a hidden class=anchor aria-hidden=true href=#常见错误>#</a></h3><ol><li><p><strong>硬件/软件接口定义不清</strong></p><ul><li>内存映射混乱</li><li>中断配置错误</li><li>数据格式不一致</li></ul></li><li><p><strong>架构设计不合理</strong></p><ul><li>模块耦合度过高</li><li>缺乏独立性</li><li>冗余设计不充分</li></ul></li><li><p><strong>需求追溯不完整</strong></p><ul><li>FSR → SSyR → HSR/SSR 追溯断裂</li><li>无法验证是否满足需求</li></ul></li><li><p><strong>集成测试不充分</strong></p><ul><li>只测试正常场景，忽视故障场景</li><li>未进行故障注入测试</li></ul></li></ol><h3 id=最佳实践>最佳实践<a hidden class=anchor aria-hidden=true href=#最佳实践>#</a></h3><ol><li><p><strong>使用 SysML/UML 建模</strong></p><ul><li>清晰地表达系统架构</li><li>建立完整的追溯关系</li></ul></li><li><p><strong>建立需求追溯矩阵</strong></p><ul><li>确保每个需求都有对应的实现和测试</li><li>便于审查和审计</li></ul></li><li><p><strong>采用模块化设计</strong></p><ul><li>高内聚、低耦合</li><li>便于维护和升级</li></ul></li><li><p><strong>充分的测试</strong></p><ul><li>覆盖所有需求和场景</li><li>特别是故障场景</li></ul></li></ol><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>ISO 26262-4 系统级开发是连接概念阶段和具体实现的桥梁。通过本文的深入解读和丰富的案例实践，我们掌握了：</p><ol><li><p><strong>技术安全概念（TSC）的开发</strong>：</p><ul><li>TSC 的定义和作用</li><li>TSC 的开发步骤</li><li>制动系统的 TSC 实践</li></ul></li><li><p><strong>系统安全需求（SSyR）的制定</strong>：</p><ul><li>SSyR 的分类</li><li>SSyR 的制定方法</li><li>制动系统的 SSyR 实例</li></ul></li><li><p><strong>硬件安全需求（HSR）和软件安全需求（SSR）</strong>：</p><ul><li>HSR 和 SSR 的定义和作用</li><li>HSR 和 SSR 的内容</li><li>制动系统的 HSR/SSR 实例</li></ul></li><li><p><strong>系统架构设计</strong>：</p><ul><li>硬件架构设计（单通道、双通道、三模冗余）</li><li>软件架构设计（分层架构）</li><li>三模冗余的可靠性计算</li></ul></li><li><p><strong>硬件/软件集成（HSI）</strong>：</p><ul><li>HSI 的定义和作用</li><li>HSI 的内容（内存映射、中断向量表、数据结构、时序约束）</li><li>制动系统的 HSI 实例</li></ul></li><li><p><strong>系统集成和测试</strong>：</p><ul><li>系统集成的步骤</li><li>系统测试的类型</li><li>制动系统的测试用例</li></ul></li><li><p><strong>实战案例</strong>：</p><ul><li>AEB 系统的系统级开发完整实践</li></ul></li></ol><p><strong>核心要点</strong>：</p><ul><li>系统级开发是将概念阶段的安全需求转化为具体技术实现的关键环节</li><li>TSC 是连接概念阶段和系统级开发的桥梁</li><li>HSR 和 SSR 必须追溯到 SSyR，SSyR 必须追溯到 FSR</li><li>系统架构设计必须考虑独立性、多样性和诊断性</li><li>HSI 是硬件和软件协同工作的基础</li><li>充分的测试是确保系统安全的关键</li></ul><p>在下一篇文章中，我们将深入解读 ISO 26262-5 硬件级开发部分，学习如何设计和开发安全的硬件。</p><h2 id=延伸阅读>延伸阅读<a hidden class=anchor aria-hidden=true href=#延伸阅读>#</a></h2><ul><li><a href=../2026-01-16-iso26262-1-vocabulary>ISO 26262-1: 词汇</a></li><li><a href=../2026-01-16-iso26262-2-management>ISO 26262-2: 功能安全管理</a></li><li><a href=../2026-01-16-iso26262-3-concept>ISO 26262-3: 概念阶段</a></li><li><a href=../2026-01-16-iso26262-5-hardware>ISO 26262-5: 硬件级开发</a></li><li><a href=../2026-01-16-iso26262-overview>ISO 26262 整体综述</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://s-ai-unix.github.io/tags/iso-26262/>ISO 26262</a></li><li><a href=https://s-ai-unix.github.io/tags/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8/>功能安全</a></li><li><a href=https://s-ai-unix.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/>系统管理</a></li></ul><nav class=paginav><a class=prev href=https://s-ai-unix.github.io/posts/2026-01-11-iso26262-3-concept/><span class=title>« Prev</span><br><span>ISO 26262-3 概念阶段：功能安全的基石</span>
</a><a class=next href=https://s-ai-unix.github.io/posts/2026-01-09-iso26262-5-hardware/><span class=title>Next »</span><br><span>ISO 26262-5 硬件级开发：构建安全的硬件基础</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ISO 26262-4 系统级开发：从概念到实现 on x" href="https://x.com/intent/tweet/?text=ISO%2026262-4%20%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%bc%80%e5%8f%91%ef%bc%9a%e4%bb%8e%e6%a6%82%e5%bf%b5%e5%88%b0%e5%ae%9e%e7%8e%b0&amp;url=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-10-iso26262-4-system%2f&amp;hashtags=ISO26262%2c%e5%8a%9f%e8%83%bd%e5%ae%89%e5%85%a8%2c%e7%b3%bb%e7%bb%9f%e7%ae%a1%e7%90%86"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ISO 26262-4 系统级开发：从概念到实现 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-10-iso26262-4-system%2f&amp;title=ISO%2026262-4%20%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%bc%80%e5%8f%91%ef%bc%9a%e4%bb%8e%e6%a6%82%e5%bf%b5%e5%88%b0%e5%ae%9e%e7%8e%b0&amp;summary=ISO%2026262-4%20%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%bc%80%e5%8f%91%ef%bc%9a%e4%bb%8e%e6%a6%82%e5%bf%b5%e5%88%b0%e5%ae%9e%e7%8e%b0&amp;source=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-10-iso26262-4-system%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ISO 26262-4 系统级开发：从概念到实现 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-10-iso26262-4-system%2f&title=ISO%2026262-4%20%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%bc%80%e5%8f%91%ef%bc%9a%e4%bb%8e%e6%a6%82%e5%bf%b5%e5%88%b0%e5%ae%9e%e7%8e%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ISO 26262-4 系统级开发：从概念到实现 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fs-ai-unix.github.io%2fposts%2f2026-01-10-iso26262-4-system%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=s-ai-unix/blog data-repo-id=R_kgDOQ3Njaw data-category=General data-category-id=DIC_kwDOQ3Nja84C0yve data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2026 <a href=https://s-ai-unix.github.io/>s-ai-unix's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script></body></html>