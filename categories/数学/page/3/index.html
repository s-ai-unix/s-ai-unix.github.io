<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数学 | s-ai-unix's Blog</title><meta name=keywords content><meta name=description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta name=author content="s-ai-unix"><link rel=canonical href=https://s-ai-unix.github.io/categories/%E6%95%B0%E5%AD%A6/><link crossorigin=anonymous href=/assets/css/stylesheet.0833aff7e1cf567ecfb9755701ee95a80535f671e2e1a0a770c9bc20a0a7b5bb.css integrity="sha256-CDOv9+HPVn7PuXVXAe6VqAU19nHi4aCncMm8IKCntbs=" rel="preload stylesheet" as=style><link rel=icon href=https://s-ai-unix.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s-ai-unix.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s-ai-unix.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s-ai-unix.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s-ai-unix.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://s-ai-unix.github.io/categories/%E6%95%B0%E5%AD%A6/index.xml title=rss><link rel=alternate hreflang=en href=https://s-ai-unix.github.io/categories/%E6%95%B0%E5%AD%A6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://s-ai-unix.github.io/categories/%E6%95%B0%E5%AD%A6/"><meta property="og:site_name" content="s-ai-unix's Blog"><meta property="og:title" content="数学"><meta property="og:description" content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="数学"><meta name=twitter:description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><link rel=stylesheet href=https://s-ai-unix.github.io/css/classical-quote.css></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://s-ai-unix.github.io/ accesskey=h title="s-ai-unix's Blog (Alt + H)">s-ai-unix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s-ai-unix.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://s-ai-unix.github.io/posts/ title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://s-ai-unix.github.io/archives/ title="📁 归档"><span>📁 归档</span></a></li><li><a href=https://s-ai-unix.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://s-ai-unix.github.io/search/ title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://s-ai-unix.github.io/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://s-ai-unix.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://s-ai-unix.github.io/categories/>Categories</a></div><h1>数学</h1></header><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/fourier-series.jpg alt=傅里叶级数的波形叠加></figure><header class=entry-header><h2 class=entry-hint-parent>傅里叶级数：用正弦波重构世界</h2></header><div class=entry-content><p>引言：1822年的一个大胆断言 想象你站在19世纪初的巴黎，一位头发花白的法国数学家约瑟夫·傅里叶（Joseph Fourier）刚刚完成了一部巨著《热的解析理论》。在这本书中，他提出了一个在当时看来近乎荒谬的断言：
任何周期函数，无论多么复杂，都可以表示为简单的正弦和余弦函数的无穷级数。
这个想法在当时激起了巨大的争议。著名的数学家拉格朗日（Lagrange）甚至认为这是不可能的。但傅里叶坚持自己的观点，并用这个方法成功解决了困扰数学家多年的热传导方程。
为什么这个想法如此重要？因为正弦函数 $\sin(x)$ 和余弦函数 $\cos(x)$ 是我们最理解、最容易处理的函数。如果任何复杂函数都能分解成这些简单函数的叠加，那么我们就可以把复杂问题转化为简单问题来解决。
今天，从你的手机音乐播放器到医学影像设备，从JPEG图像压缩到量子力学计算，傅里叶的思想无处不在。让我们从历史的长河出发，逐步理解这个改变世界的数学工具。
第一章：历史演变——从音乐到数学的千年旅程 1.1 古希腊的发现：音乐是数学 公元前6世纪，毕达哥拉斯（Pythagoras）做了一个著名的实验。他拨动不同长度的琴弦，发现：
当弦长比例为 $2:1$ 时，听起来是八度音 当弦长比例为 $3:2$ 时，听起来是五度音 当弦长比例为 $4:3$ 时，听起来是四度音 这让他意识到：音乐的和谐可以用数学比例来描述。这是人类第一次认识到声音的"频率"概念——琴弦振动越快，音调越高。
更神奇的是，古希腊人还发现：任何复杂的声音都可以分解为多个"纯音"（正弦波）的组合。这其实就是傅里叶级数思想的萌芽！
1.2 18世纪的挑战：弦振动的谜题 时间来到18世纪，物理学家们对弦的振动产生了浓厚兴趣。小提琴、钢琴的弦是如何振动的？如何从数学上描述这种振动？
1747年，达朗贝尔（d’Alembert）得到了弦振动方程： $$ \frac{\partial^2 y}{\partial t^2} = c^2 \frac{\partial^2 y}{\partial x^2} $$
但这个方程的解是什么？欧拉（Euler）和伯努利（Bernoulli）分别给出了不同的解答。伯努利提出：弦的任何运动都可以表示为"固有模式"（正弦波）的叠加。
$$ y(x,t) = \sum_{n=1}^{\infty} A_n \sin\left(\frac{n\pi x}{L}\right)\cos\left(\frac{n\pi c t}{L}\right) $$
但拉格朗日质疑：任意函数真的都能这样分解吗？ 这个争论持续了半个多世纪，直到傅里叶给出答案。
1.3 1807年：傅里叶的革命性论文 1807年，傅里叶向法国科学院提交了一篇关于热传导的论文。在研究金属棒中热量如何传播时，他遇到了一个难题：如何表示初始温度分布？
傅里叶提出：初始温度函数 $f(x)$ 可以表示为
$$ f(x) = a_0 + \sum_{n=1}^{\infty} a_n \cos\left(\frac{n\pi x}{L}\right) + b_n \sin\left(\frac{n\pi x}{L}\right) $$
...</p></div><footer class=entry-footer><span title='2026-01-20 21:00:00 +0800 CST'>January 20, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1285 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 傅里叶级数：用正弦波重构世界" href=https://s-ai-unix.github.io/posts/2026-01-20-fourier-series/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/vector-calculus-geometry.jpg alt=向量场的几何直觉></figure><header class=entry-header><h2 class=entry-hint-parent>微积分的三大公式：格林、高斯与斯托克斯定理的统一视角</h2></header><div class=entry-content><p>想象这样一个场景：你站在河边，看着水流在河道中蜿蜒前行。河水的流速在不同的位置和方向上都不同——有的地方湍急，有的地方平缓。如果你想知道流过一个闭合河岸的净水量，你会怎么做？
直觉告诉你：可以沿着河岸计算流进和流出的差异。但数学告诉你，这等价于计算河岸所包围区域内水源的"产生"或"消失"。这就是格林公式的物理直观。
从二维的河流到三维的空气流动，从平面上的旋转到空间中的曲面，微积分的三大公式——格林公式、高斯公式、斯托克斯公式——都在讲述同一个深刻的思想：边界上的积分与内部的积分可以通过某种微分运算相互转化。
一、预备知识：向量微积分的语言 在深入三大公式之前，让我们先回顾一些必要的基础概念。
1.1 向量场 向量场 $\mathbf{F} : \mathbb{R}^n \to \mathbb{R}^n$ 是一个函数，它给空间中的每个点赋予一个向量。在二维情况下，我们通常写成：
$$ \mathbf{F}(x, y) = P(x, y)\mathbf{i} + Q(x, y)\mathbf{j} $$
物理中常见的向量场包括：
流体的速度场 电磁场的电场或磁场 引力场 1.2 梯度、散度与旋度 假设 $f(x, y, z)$ 是一个标量函数，$\mathbf{F} = (P, Q, R)$ 是一个向量场，我们有三个关键的微分算子：
梯度：标量场的梯度是一个向量，指向函数增长最快的方向。
$$ \nabla f = \left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z}\right) $$
散度：向量场的散度是一个标量，衡量向量场在某点的"发散"程度。
$$ \nabla \cdot \mathbf{F} = \frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z} $$
...</p></div><footer class=entry-footer><span title='2026-01-14 22:14:36 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1167 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 微积分的三大公式：格林、高斯与斯托克斯定理的统一视角" href=https://s-ai-unix.github.io/posts/2026-01-14-greens-gauss-stokes-formulas-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/unsplash-taylor.jpg alt=抽象几何曲线></figure><header class=entry-header><h2 class=entry-hint-parent>泰勒公式：用简单近似复杂的艺术</h2></header><div class=entry-content><p>引言：从曲线到直线 想象你站在一座山上，想知道脚下的山坡有多陡。你不需要知道整个山脉的形状，只需要知道你所在位置的局部斜率。这是微积分最基本的思想——用局部信息推断全局行为。
更进一步，如果山坡弯曲了怎么办？这时不仅需要知道斜率，还需要知道弯曲的程度。这就是泰勒公式的核心思想：用最简单的函数（多项式）来近似复杂的函数，而近似的质量取决于我们使用多少局部信息（导数）。
泰勒公式被誉为"数学家最有力的工具之一"。它不仅连接了离散与连续、局部与整体，更在数值计算、物理建模和现代人工智能中扮演着不可替代的角色。今天，让我们深入探索这个既古老又常新的数学宝藏。
一、历史回顾：从牛顿到泰勒 泰勒公式的思想可以追溯到牛顿和莱布尼茨创立微积分的时期。牛顿在他的《流数术》中已经隐含了将函数展开为无穷级数的想法。
布鲁克·泰勒（Brook Taylor，1685-1731）在1715年发表了他的开创性论文《增量法及其逆运算》，首次系统地阐述了用多项式级数逼近函数的方法。有趣的是，泰勒本人并没有意识到他发现的公式的全部潜力，余项的研究（拉格朗日余项、柯西余项等）是后来由拉格朗日等数学家完善的。
麦克劳林（Colin Maclaurin）发现了泰勒公式在零点展开的特例，即麦克劳林级数。这个形式在实际计算中更为常用，因为计算起来更加方便。
二、一元函数的泰勒公式 基本形式 假设函数 $f(x)$ 在点 $a$ 处足够光滑（即具有各阶导数），那么我们可以构造一个多项式 $P_n(x)$ 来近似 $f(x)$：
$$ P_n(x) = f(a) + f’(a)(x-a) + \frac{f’’(a)}{2!}(x-a)^2 + \cdots + \frac{f^{(n)}(a)}{n!}(x-a)^n $$
泰勒公式告诉我们：
$$ f(x) = P_n(x) + R_n(x) $$
其中 $R_n(x)$ 是余项，表示近似误差。
余项的几种形式 理解余项对于掌握泰勒公式至关重要，因为它告诉我们近似在什么范围内可靠。
拉格朗日余项：
$$ R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-a)^{n+1} $$
其中 $\xi$ 是 $a$ 和 $x$ 之间的某个值。
积分余项：
$$ R_n(x) = \frac{1}{n!} \int_a^x f^{(n+1)}(t)(x-t)^n , dt $$
直观理解 让我们通过一个简单的例子来理解泰勒公式。考虑 $f(x) = e^x$ 在 $a = 0$ 处的泰勒展开（即麦克劳林级数）：
...</p></div><footer class=entry-footer><span title='2026-01-14 22:10:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1110 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 泰勒公式：用简单近似复杂的艺术" href=https://s-ai-unix.github.io/posts/2026-01-14-taylor-series/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1620641788421-7a1c342ea42e.jpg alt=抽象几何空间></figure><header class=entry-header><h2 class=entry-hint-parent>黎曼张量度量：弯曲空间的距离语言</h2></header><div class=entry-content><p>引言：如何测量弯曲的世界？ 想象一下，你生活在一个球面上。如果你想测量两点之间的距离，或者两条线之间的夹角，你会怎么做？
在平坦的欧几里得平面上，这很简单：距离用勾股定理计算，角度用点积定义。但在球面上，直线变成了大圆弧，勾股定理不再成立，角度的计算也变得更加复杂。
问题的关键在于：我们需要一个通用的方法来定义任意空间中的距离和角度。
这个方法就是黎曼度量（Riemannian Metric），或者更准确地说，度量张量（Metric Tensor）。它是黎曼几何的基础，也是广义相对论中描述时空的核心工具。
第一章：从勾股定理到度量张量 欧几里得距离 在二维欧几里得平面上，两点 $(x_1, y_1)$ 和 $(x_2, y_2)$ 之间的距离是：
$$ d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} $$
这个公式源自勾股定理。更一般地，如果我们考虑一个微小的位移 $(dx, dy)$，那么对应的距离是：
$$ ds^2 = dx^2 + dy^2 $$
这个表达式被称为线元素（line element）。它告诉我们：沿 $x$ 方向移动 $dx$，沿 $y$ 方向移动 $dy$，总距离的平方是 $dx^2 + dy^2$。
三维欧几里得空间 在三维欧几里得空间中，线元素是：
$$ ds^2 = dx^2 + dy^2 + dz^2 $$
我们可以把它写成矩阵形式：
$$ ds^2 = \begin{pmatrix} dx & dy & dz \end{pmatrix} \begin{pmatrix} 1 & 0 & 0 \ 0 & 1 & 0 \ 0 & 0 & 1 \end{pmatrix} \begin{pmatrix} dx \ dy \ dz \end{pmatrix} $$
...</p></div><footer class=entry-footer><span title='2026-01-14 21:35:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1144 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 黎曼张量度量：弯曲空间的距离语言" href=https://s-ai-unix.github.io/posts/2026-01-14-riemann-metric-tensor/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1509228468518-180dd4864904.jpg alt=抽象几何空间></figure><header class=entry-header><h2 class=entry-hint-parent>黎曼曲率张量：弯曲时空的数学语言</h2></header><div class=entry-content><p>引言：从二维到无穷维 在我们之前的文章中，我们探索了高斯曲率（Gaussian Curvature），这个概念描述了二维曲面的弯曲程度。高斯的伟大发现是：曲面的弯曲是"内蕴"的，即只依赖于曲面自身的度量，而与曲面在三维空间中的嵌入方式无关。
但是，如果我们生活在四维时空中呢？或者更高维的空间？我们还能用同样的方式描述弯曲吗？
答案是肯定的，但需要更加强大的数学工具。这个工具就是黎曼曲率张量（Riemann Curvature Tensor），由伟大的数学家伯恩哈德·黎曼（Bernhard Riemann）在19世纪中叶提出。
黎曼曲率张量是黎曼几何的核心概念，它不仅推广了高斯曲率，更成为了广义相对论中描述时空弯曲的数学基础。
第一章：回顾高斯的遗产 在深入黎曼曲率张量之前，让我们简要回顾高斯的工作。
高斯曲率与绝妙定理 对于二维曲面，高斯曲率 $K$ 定义为：
$$ K = \frac{LN - M^2}{EG - F^2} $$
其中 $E, F, G$ 是第一基本形式的系数，$L, M, N$ 是第二基本形式的系数。
高斯的绝妙定理告诉我们：$K$ 可以仅用 $E, F, G$ 及其导数表示，因此是曲面的内蕴性质。
这个定理暗示了一个深刻的观点：空间本身可能有内在的几何结构，这种结构不依赖于任何"外部"空间。
从曲面到更高维度 高斯的工作集中在二维曲面上。但问题是：如何将这个思想推广到更高维度？
答案是：我们需要一种能够描述任意维度空间弯曲的数学对象。这个对象必须满足：
在二维情况下，它应该退化到高斯曲率 它应该包含足够的信息来描述任意方向、任意平面上的弯曲 它应该是内蕴的（即只依赖于度量） 黎曼曲率张量正是满足这些要求的数学对象。
第二章：黎曼的远见——1854年的演讲 伯恩哈德·黎曼（1826-1866） 伯恩哈德·黎曼是高斯的学生，也是数学史上最具原创性的思想家之一。他的工作跨越数论、复分析、微分几何等多个领域。
1854年6月10日，黎曼在哥廷根大学做了题为**《论几何基础的假设》**（Über die Hypothesen, welche der Geometrie zu Grunde liegen）的演讲。这篇演讲被认为是微分几何史上最重要的文献之一，也是黎曼几何的奠基之作。
黎曼几何的基本思想 在这次演讲中，黎曼提出了一个革命性的想法：几何不一定是三维欧几里得空间的子集，它可以是任意维度的"流形"（manifold）。
黎曼定义：
流形（Manifold）：局部看起来像欧几里得空间的几何对象 度量（Metric）：定义流形上两点之间的距离和角度 曲率（Curvature）：描述流形的弯曲程度 黎曼意识到：如果我们有一个度量 $g_{ij}$，我们可以计算各种几何量，包括曲率。但这个曲率在高维情况下应该是什么样的？
黎曼的原始定义 黎曼在演讲中给出了曲率的原始定义（与现代形式略有不同）：
考虑流形上一点 $P$，取两个切向量 $X, Y$。沿着由 $X$ 和 $Y$ 张成的二维平面，我们可以构建一个"测地三角形"。这个三角形在流形上沿着测地线（最短路径）连接三点。
...</p></div><footer class=entry-footer><span title='2026-01-14 21:28:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>858 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 黎曼曲率张量：弯曲时空的数学语言" href=https://s-ai-unix.github.io/posts/2026-01-14-riemann-curvature-tensor/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1635070041078-e363dbe005cb.jpg alt=抽象几何图形></figure><header class=entry-header><h2 class=entry-hint-parent>高斯曲率：弯曲世界的数学语言</h2></header><div class=entry-content><p>引言：弯曲的世界 想象一下，你是一只蚂蚁，生活在一个巨大的球面上。对于这只蚂蚁来说，这个世界看起来是什么样子的？如果你问它：“这个世界是平的还是弯曲的？“它会怎么回答？
这个问题看似简单，却蕴含着深刻的数学思想。古希腊的欧几里得用五条公理构建了完美的平面几何学，但现实世界中的曲面——球面、马鞍面、波浪形的海浪——让数学家们不得不思考：如何描述这些弯曲的几何形状？
答案就是曲率，特别是高斯曲率（Gaussian Curvature）。这个概念不仅改变了我们对几何的理解，更成为了现代物理的基石。
第一章：曲率的直观理解 在深入数学之前，让我们先从直觉出发，理解什么是"弯曲”。
直线的曲率 一条直线没有弯曲，我们说它的曲率为零。这一点很直观——直线上任意一点都朝同一个方向延伸，没有"拐弯”。
圆的曲率呢？如果一个圆的半径是 $R$，那么它的曲率定义为：
$$ \kappa = \frac{1}{R} $$
这个定义很合理：圆越小（半径越小），弯曲得越厉害，曲率越大；圆越大（半径越大），弯曲越不明显，曲率越小；当半径趋于无穷大时，圆就变成了直线，曲率趋于零。
平面曲线的曲率 对于任意一条平面曲线，我们可以这样定义曲率：在某一点处，找一个最接近该曲线的圆（称为"密切圆"），这个圆的曲率就是曲线在该点的曲率。
数学上，如果曲线由参数方程 $(x(t), y(t))$ 给出，曲率的公式是：
$$ \kappa = \frac{|x’(t)y’’(t) - y’(t)x’’(t)|}{(x’(t)^2 + y’(t)^2)^{3/2}} $$
这个公式看起来有点复杂，但本质上就是用曲线的二阶导数（加速度）来描述弯曲程度。
从曲线到曲面 现在我们要迈出关键的一步：从曲线到曲面。球面是弯曲的，马鞍面也是弯曲的，但它们"弯曲"的方式不同。这种差异，正是高斯曲率要捕捉的。
第二章：从平面到曲面——数学家的探索 古希腊的遗产 古希腊几何学以欧几里得的《几何原本》为代表，建立在五条公理之上。其中最著名的是第五公理（平行公理）：“过直线外一点，有且只有一条直线与该直线平行。”
这条公理在平面上成立，但在曲面上却不一定成立。这暗示着，曲面的几何可能与平面有本质区别。
黎曼前的探索 在19世纪初，数学家们开始思考更一般的几何学。Gauss（高斯）之前的一些数学家，如Monge和Euler，已经研究过曲面的某些性质。
莱昂哈德·欧拉（Leonhard Euler）在1760年给出了一个重要发现：对于曲面上的任意一点，存在两个特殊的方向，沿着这两个方向的法曲率分别取得最大值和最小值。这两个值被称为主曲率，记为 $\kappa_1$ 和 $\kappa_2$。
欧拉还发现了一个重要公式：如果两个主方向之间的夹角是 $\theta$，那么沿着与第一个主方向夹角为 $\phi$ 的方向的法曲率是：
$$ \kappa_n(\phi) = \kappa_1 \cos^2 \phi + \kappa_2 \sin^2 \phi $$
这个公式被称为欧拉曲率公式，它告诉我们，如果知道了两个主曲率，就知道了一切方向的法曲率。
但欧拉的研究有一个局限：他只考虑了法曲率，即沿着某个方向在法平面内的曲率。这种曲率依赖于曲面在空间中的"嵌入方式"，被称为"外蕴曲率"（extrinsic curvature）。
卡尔·弗里德里希·高斯的登场 卡尔·弗里德里希·高斯（Carl Friedrich Gauss, 1777-1855）是数学史上最伟大的数学家之一。他在1827年发表了一篇里程碑式的论文：《关于曲面的一般研究》（Disquisitiones Generales Circa Superficies Curvas）。
...</p></div><footer class=entry-footer><span title='2026-01-14 21:16:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1121 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 高斯曲率：弯曲世界的数学语言" href=https://s-ai-unix.github.io/posts/2026-01-14-gaussian-curvature/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/geometry-curves.jpg alt=几何曲线的抽象艺术图></figure><header class=entry-header><h2 class=entry-hint-parent>Frenet标架：微分几何的优雅语言与工程实践</h2></header><div class=entry-content><p>引言：从高速公路的弯道说起 想象一下，你正驾驶着汽车行驶在高速公路上，前方出现一个弯道。作为驾驶员，你会下意识地做几件事：判断弯道的急缓程度（曲率）、调整方向盘的角度（切向量）、控制车速，甚至在复杂的弯道上，你会感受到车身有轻微的侧倾或仰俯（挠率）。
这些看似简单的驾驶行为背后，隐藏着深刻的数学原理：如何在任意一点附近，用最简洁的方式描述一条空间曲线的几何性质？
这就是19世纪数学家们面临的核心问题。而他们的答案——Frenet标架（Frenet Frame），不仅成为了微分几何的基石，更在今天的自动驾驶和机器人工程中扮演着不可或缺的角色。
让我们从这段跨越170年的数学之旅开始，逐步揭开Frenet标架的神秘面纱。
第一章：19世纪的几何革命 在19世纪中叶，微分几何正处于一个激动人心的时期。传统的欧几里得几何关注的是静态的图形性质——三角形的内角和、圆的面积等等。但数学家们开始思考一个更动态的问题：如何研究"弯曲"的对象？
这个问题的种子早在17世纪就由牛顿和莱布尼茨播下——微积分的发明让人们能够描述变化的速率。到了19世纪，数学家们意识到，微积分可以用来研究曲线和曲面的局部性质，而不只是全局性质。
Frenet的突破 1847年，法国数学家Jean Frédéric Frenet在他的博士论文中提出了一个革命性的想法：在空间曲线上的每一点，我们可以建立一个自然的局部坐标系。这个坐标系不是任意选择的，而是由曲线本身的几何性质唯一确定的。
Serret的独立发现 几乎在同一时间，另一位法国数学家Joseph Alfred Serret也独立地发现了同样的结果。这就是为什么这个框架被称为"Frenet-Serret公式"。今天，我们更常称之为"Frenet标架"，以纪念Frenet率先发表的贡献。
这个发现的巧妙之处在于：它用三个相互正交的向量，完整地刻画了曲线在任意点的局部几何。这三个向量——切向量、法向量和副法向量——构成了一个"移动标架"，随着我们在曲线上移动而不断变化。
第二章：构建Frenet标架——从直觉到严谨 让我们从直观到严谨，一步步构建Frenet标架。
第一步：切向量（Tangent Vector） 想象一辆小车沿着一条空间曲线行驶。在任意时刻，小车都有一个瞬时速度向量，指向它运动的方向。这个方向就是曲线在该点的切线方向。
假设曲线由参数方程 $\mathbf{r}(t) = (x(t), y(t), z(t))$ 描述，其中 $t$ 是参数（可以想象成时间）。那么切向量就是速度向量：
$$ \mathbf{v}(t) = \frac{d\mathbf{r}}{dt} = \left(\frac{dx}{dt}, \frac{dy}{dt}, \frac{dz}{dt}\right) $$
这个向量的大小代表了运动的快慢，但作为几何性质，我们更关注方向。因此，我们将切向量标准化为单位向量：
$$ \mathbf{T}(t) = \frac{\mathbf{v}(t)}{|\mathbf{v}(t)|} = \frac{\frac{d\mathbf{r}}{dt}}{\left|\frac{d\mathbf{r}}{dt}\right|} $$
直觉理解：$\mathbf{T}$ 指向曲线"前方"，代表运动的方向。
第二步：主法向量（Principal Normal Vector） 接下来，我们考虑切向量的变化率。$\mathbf{T}$ 的方向会随着曲线弯曲而改变，这种改变的方向如何描述？
对 $\mathbf{T}$ 求导：
$$ \frac{d\mathbf{T}}{ds} $$
这里我们用弧长 $s$ 作为参数（稍后解释为什么）。由于 $\mathbf{T}$ 是单位向量，$\mathbf{T} \cdot \mathbf{T} = 1$，对其求导得到：
...</p></div><footer class=entry-footer><span title='2026-01-14 20:35:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1243 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to Frenet标架：微分几何的优雅语言与工程实践" href=https://s-ai-unix.github.io/posts/2026-01-14-frenet-frame-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/darboux-theory-of-surfaces.jpg alt=经典数学著作></figure><header class=entry-header><h2 class=entry-hint-parent>达布《曲面通论教程》：微分几何的里程碑式巨著</h2></header><div class=entry-content><p>系统介绍法国数学家加斯东·达布（Gaston Darboux）的四卷本《曲面通论教程》，阐述各卷内容与主要贡献</p></div><footer class=entry-footer><span title='2026-01-14 16:00:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>378 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 达布《曲面通论教程》：微分几何的里程碑式巨著" href=https://s-ai-unix.github.io/posts/2026-01-14-darboux-theory-of-surfaces/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/wisconsin-geese-4602386.jpg alt=抽象的几何图案></figure><header class=entry-header><h2 class=entry-hint-parent>梯度、梯度下降与反向传播：从最优化到深度学习的数学引擎</h2></header><div class=entry-content><p>引言：从山路说起 想象你是一名登山者，被困在浓雾笼罩的山坡上，四周一片白茫茫。你手里只有一个指南针，它指向的似乎是你所在位置海拔下降最快的方向。这是你最希望知道的：该往哪个方向迈出第一步，才能尽快走出这座山？
这就是梯度下降算法最直观的物理类比。你所在的位置，是一个函数在某点的值；你想要的，是找到函数的最小值（山谷的最低点）；而那个指南针，就是梯度——告诉你哪个方向上升最快的向量。
这个看似简单的思想，却成为了现代人工智能的数学引擎。从AlphaGo击败李世石，到ChatGPT生成流畅的文字，再到自动驾驶汽车的感知系统，背后都依赖着梯度、梯度下降和反向传播这三个核心概念的精密协作。
但在深入这些概念之前，我们需要先理解一个更基础的数学对象：梯度。
梯度：地形的最陡方向 历史背景：从Hamilton到向量微积分 梯度的概念并非一蹴而就。它的起源可以追溯到19世纪中叶，那个数学物理大爆发的时代。
1843年，爱尔兰数学家William Rowan Hamilton（哈密顿）在研究四元数时，引入了一个算子符号$\nabla$，他称之为"nabla"（源自希腊语，意为一种竖琴）。这个倒三角符号后来成为了梯度、散度和旋度的统一表示。
1850年代，苏格兰数学家James Clerk Maxwell（麦克斯韦）进一步发展了向量微积分理论，他将$\nabla$算子应用于不同的运算：$\nabla \phi$表示梯度，$\nabla \cdot \mathbf{F}$表示散度，$\nabla \times \mathbf{F}$表示旋度。这三大运算构成了现代电磁学理论的数学语言。
更早之前，法国数学家Augustin-Louis Cauchy（柯西）在1847年就提出了梯度下降算法的雏形，这是最古老的优化算法之一。
数学定义：偏导数的向量 给定一个多元标量函数 $f: \mathbb{R}^n \rightarrow \mathbb{R}$，它的梯度 $\nabla f$（读作"del f"或"grad f"）定义为：
$$ \nabla f = \left(\frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2}, \ldots, \frac{\partial f}{\partial x_n}\right)^T $$
这是一个向量，每个分量是函数对相应变量的偏导数。
具体计算示例 考虑一个简单的二次函数：$f(x, y) = x^2 + 2y^2 - 4x - 8y + 17$
计算梯度：
$$ \frac{\partial f}{\partial x} = 2x - 4, \quad \frac{\partial f}{\partial y} = 4y - 8 $$
...</p></div><footer class=entry-footer><span title='2026-01-14 08:34:44 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>2040 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 梯度、梯度下降与反向传播：从最优化到深度学习的数学引擎" href=https://s-ai-unix.github.io/posts/2026-01-14-gradient-descent-backpropagation-overview/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1509228468518-180dd4864904.jpg alt=抽象几何图形></figure><header class=entry-header><h2 class=entry-hint-parent>传统机器学习与统计学习算法：从理论到实践的完整指南</h2></header><div class=entry-content><p>引言：从统计学到机器学习 1956年，达特茅斯会议上正式提出了"人工智能"这个词。但在那之前的一百年里，统计学家们已经在用数学工具从数据中提取规律。高斯在1809年就用最小二乘法解决了天文学中的观测数据拟合问题，这可以看作是最早的机器学习算法。
机器学习和统计学习，本质上是一回事：从数据中学习规律，并用这些规律做出预测。只是出发点略有不同——统计学家关注估计的可靠性和显著性检验，而计算机科学家更关心算法的计算效率和泛化能力。
当我们说"传统机器学习"时，指的是深度学习时代之前的那些经典算法。这些算法虽然不像神经网络那样"万能"，但在数据量有限、需要可解释性的场景下，依然发挥着不可替代的作用。
第一章：统计学习的理论基础 1.1 学习问题的数学框架 假设我们有一个数据集 $D = {(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)}$，其中 $x_i \in \mathcal{X}$ 是输入（特征），$y_i \in \mathcal{Y}$ 是输出（标签）。我们的目标是找到一个函数 $f: \mathcal{X} \to \mathcal{Y}$，使得对于新的输入 $x$，$f(x)$ 能准确预测对应的 $y$。
但在统计学习的框架下，我们还需要引入概率论的概念。假设数据是按照某个未知的联合分布 $P(X,Y)$ 生成的，我们的目标是学习一个决策函数 $f$，使得期望风险最小化：
$$R(f) = \mathbb{E}_{(X,Y) \sim P}[L(Y, f(X))]$$
其中 $L$ 是损失函数。对于回归问题，常用平方损失；对于分类问题，常用0-1损失或交叉熵损失。
问题在于：我们不知道 $P(X,Y)$，无法直接计算 $R(f)$。我们只能用经验风险（Empirical Risk）来近似：
$$\hat{R}(f) = \frac{1}{n}\sum_{i=1}^n L(y_i, f(x_i))$$
这就是经验风险最小化（ERM）的基本思想。但直接最小化经验风险会导致过拟合（overfitting）。
1.2 偏差-方差权衡 这是统计学习中最重要的概念之一。模型的预测误差可以分解为三个部分：
$$\mathbb{E}[(y - \hat{f}(x))^2] = \text{Bias}[\hat{f}(x)]^2 + \text{Var}[\hat{f}(x)] + \sigma^2$$
其中：
$\text{Bias}[\hat{f}(x)] = \mathbb{E}[\hat{f}(x)] - f^*(x)$：模型预测的期望与真实值的差距 $\text{Var}[\hat{f}(x)] = \mathbb{E}[(\hat{f}(x) - \mathbb{E}[\hat{f}(x)])^2]$：模型预测的方差 $\sigma^2$：不可约误差（数据本身的噪声） 偏差反映了模型的"假设强度"。如果模型过于简单（比如用线性模型拟合高度非线性的数据），会产生高偏差，导致欠拟合。
...</p></div><footer class=entry-footer><span title='2026-01-14 08:18:25 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>2161 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 传统机器学习与统计学习算法：从理论到实践的完整指南" href=https://s-ai-unix.github.io/posts/2026-01-14-traditional-ml-algorithms-comprehensive-guide/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://s-ai-unix.github.io/categories/%E6%95%B0%E5%AD%A6/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://s-ai-unix.github.io/categories/%E6%95%B0%E5%AD%A6/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://s-ai-unix.github.io/>s-ai-unix's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var n,t=e.innerHTML,s=!1;for(t.indexOf("<em>")!==-1&&(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("</em>")!==-1&&(n=t.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),n=n.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("<em>$")!==-1&&(n=t.replace(/<em>\$/g,"$"),n!==t&&(t=n,s=!0)),t.indexOf("</em>$")!==-1&&(n=t.replace(/<\/em>\$/g,"$"),n!==t&&(t=n,s=!0));t.indexOf("<em>")!==-1&&t.indexOf("</em>")!==-1;){if(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n===t)break;t=n,s=!0}t.indexOf("_{")!==-1&&(n=t.replace(/_{/g,"_{"),n!==t&&(t=n,s=!0)),t.indexOf("}_")!==-1&&(n=t.replace(/}_/g,"}"),n!==t&&(t=n,s=!0)),t.indexOf("\\\\")!==-1&&(n=t.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),n!==t&&(t=n,s=!0)),s&&(e.innerHTML=t)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var n,t=e.innerHTML,s=!1;for(t.indexOf("<em>")!==-1&&(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("</em>")!==-1&&(n=t.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),n=n.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("<em>$")!==-1&&(n=t.replace(/<em>\$/g,"$"),n!==t&&(t=n,s=!0)),t.indexOf("</em>$")!==-1&&(n=t.replace(/<\/em>\$/g,"$"),n!==t&&(t=n,s=!0));t.indexOf("<em>")!==-1&&t.indexOf("</em>")!==-1;){if(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n===t)break;t=n,s=!0}t.indexOf("_{")!==-1&&(n=t.replace(/_{/g,"_{"),n!==t&&(t=n,s=!0)),t.indexOf("}_")!==-1&&(n=t.replace(/}_/g,"}"),n!==t&&(t=n,s=!0)),t.indexOf("\\\\")!==-1&&(n=t.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),n!==t&&(t=n,s=!0)),s&&(e.innerHTML=t)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script></body></html>