<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>综述 | s-ai-unix's Blog</title><meta name=keywords content><meta name=description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta name=author content="s-ai-unix"><link rel=canonical href=https://s-ai-unix.github.io/tags/%E7%BB%BC%E8%BF%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.0833aff7e1cf567ecfb9755701ee95a80535f671e2e1a0a770c9bc20a0a7b5bb.css integrity="sha256-CDOv9+HPVn7PuXVXAe6VqAU19nHi4aCncMm8IKCntbs=" rel="preload stylesheet" as=style><link rel=icon href=https://s-ai-unix.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s-ai-unix.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s-ai-unix.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s-ai-unix.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s-ai-unix.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://s-ai-unix.github.io/tags/%E7%BB%BC%E8%BF%B0/index.xml title=rss><link rel=alternate hreflang=en href=https://s-ai-unix.github.io/tags/%E7%BB%BC%E8%BF%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://s-ai-unix.github.io/tags/%E7%BB%BC%E8%BF%B0/"><meta property="og:site_name" content="s-ai-unix's Blog"><meta property="og:title" content="综述"><meta property="og:description" content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="综述"><meta name=twitter:description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><link rel=stylesheet href=https://s-ai-unix.github.io/css/classical-quote.css></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://s-ai-unix.github.io/ accesskey=h title="s-ai-unix's Blog (Alt + H)">s-ai-unix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s-ai-unix.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://s-ai-unix.github.io/posts/ title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://s-ai-unix.github.io/archives/ title="📁 归档"><span>📁 归档</span></a></li><li><a href=https://s-ai-unix.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://s-ai-unix.github.io/search/ title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://s-ai-unix.github.io/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://s-ai-unix.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://s-ai-unix.github.io/tags/>Tags</a></div><h1>综述</h1></header><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/monte-carlo-method.jpg alt=蒙特卡罗方法的随机性可视化></figure><header class=entry-header><h2 class=entry-hint-parent>蒙特卡罗算法：从原子弹到人工智能的随机之旅</h2></header><div class=entry-content><p>引言：掷骰子解方程 想象一下，有人告诉你：要计算一个复杂的定积分，不需要微积分，只需要掷足够多的骰子。你大概会觉得这个人疯了。然而，这正是二十世纪最伟大的计算方法之一——蒙特卡罗方法（Monte Carlo Method）的核心思想。
当我们面对那些传统方法难以处理的高维积分、复杂系统的模拟或者无法解析求解的概率问题时，蒙特卡罗方法给出了一个看似简单却深刻的答案：用随机性来求解确定性问题。这种方法已经深入到科学的方方面面——从核物理到金融工程，从生物进化到人工智能，无处不见它的身影。
让我们从一个最经典的例子开始：如何用"扔针"来计算 $\pi$ 的值。
第一章：蒙特卡罗的诞生——曼哈顿计划的秘密代号 1.1 摩纳哥的赌场与原子弹的秘密 “蒙特卡罗"这个名字，源自摩纳哥著名的赌城。1940 年代，在洛斯阿拉莫斯实验室，一群顶尖的科学家正在紧锣密鼓地研制世界上第一颗原子弹。在这个属于"曼哈顿计划"的绝密基地里，数学家约翰·冯·诺伊曼（John von Neumann）和斯坦尼斯拉夫·乌拉姆（Stanislaw Ulam）正在研究核裂变中的中子扩散问题。
这个问题极其复杂：中子在原子弹内部的行为是随机的，它们可能被原子核捕获，可能引发新的裂变，也可能逃逸出去。传统的方法根本无法处理这种复杂的随机过程。
乌拉姆后来回忆起他是如何产生这个想法的：
“当时我正因病康复，在玩纸牌接龙。我开始思考：如果把牌随机排列一百次，大概有多少次能成功接龙？相比于把所有可能的情况都计算出来，直接实验似乎更容易…”
这个看似简单的想法，孕育了一个全新的计算方法。由于这种方法涉及随机性，而蒙特卡罗又以赌场闻名，冯·诺伊曼就给它起了"蒙特卡罗"这个代号——既是保密的需要，也恰如其分地描述了方法的本质。
1.2 早期的思想萌芽 虽然蒙特卡罗方法在1940年代才正式命名，但用随机性来解决确定性问题的思想古已有之。
1777年，布丰投针实验
法国数学家乔治-路易·勒克莱尔，布丰伯爵（Georges-Louis Leclerc, Comte de Buffon）提出了第一个著名的随机实验：
在一张画满平行线的纸（线间距为 $d$）上随机投掷一根长度为 $l$ 的针（$l &lt; d$），针与任意一条平行线相交的概率是多少？
布丰证明了，这个概率是：
$$ P = \frac{2l}{\pi d} $$
这给出了一个计算 $\pi$ 的方法：如果我们投掷针 $N$ 次，其中 $n$ 次与线相交，那么：
$$ \frac{n}{N} \approx \frac{2l}{\pi d} \implies \pi \approx \frac{2lN}{nd} $$
这个实验被多次验证：1850年，沃尔夫在苏黎世投掷了5000次，得到 $\pi \approx 3.1596$；1901年，拉泽里尼投掷3408次，甚至得到了精确到小数点后6位的 $\pi$ 值（虽然有人怀疑他可能"选择性记录"了结果）。
19世纪末的统计学革命
随着统计学的发展，卡尔·皮尔逊（Karl Pearson）等人开始使用随机抽样来解决统计问题。但这些方法仍然主要用于验证已知的结果，而不是作为通用的计算工具。
第二章：数学基础——为什么随机性有效？ 要理解蒙特卡罗方法，我们需要先理解它的数学基础。这一切都建立在大数定律和中心极限定理这两大概率论支柱之上。
...</p></div><footer class=entry-footer><span title='2026-01-21 23:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1171 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 蒙特卡罗算法：从原子弹到人工智能的随机之旅" href=https://s-ai-unix.github.io/posts/2026-01-21-monte-carlo-method/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/laplace-transform.jpg alt=拉普拉斯变换概念图></figure><header class=entry-header><h2 class=entry-hint-parent>拉普拉斯变换：从概率论到工程数学的百年旅程</h2></header><div class=entry-content><p>引言：一个被遗忘又重新发现的数学工具 如果你学过信号与系统或者控制理论，你一定见过拉普拉斯变换。它像是一把魔法钥匙，能将复杂的微分方程变成简单的代数方程。但你知道吗？这个以拉普拉斯命名的工具，在拉普拉斯生前几乎无人问津，甚至被遗忘了整整一个世纪。
今天，拉普拉斯变换是工程数学中最基础的工具之一。它的故事不仅关于一个数学公式的诞生，更关于纯粹数学与应用数学之间曲折的关系——有时候，最实用的数学发现并不是由应用驱动的，而最深刻的应用也往往来自于那些最初看起来"毫无用处"的理论工作。
让我们回到18世纪末，从一切开始的地方说起。
第一章：前传——微积分时代的挑战 欧拉的先声 在拉普拉斯之前，莱昂哈德·欧拉（Leonhard Euler）就已经在思考类似的问题。1739年，欧拉在研究微分方程时，引入了一种后来被称为"生成函数"的方法。他的想法很巧妙：如果你有一个数列 $a_0, a_1, a_2, \ldots$，你可以把它"包装"成一个幂级数
$$ A(z) = \sum_{n=0}^{\infty} a_n z^n $$
然后，通过对 $A(z)$ 进行运算，你就可以间接地操作整个数列。这就像是把一堆散乱的珍珠串成一条项链，然后通过移动整条项链来调整每颗珍珠的位置。
欧拉用这种方法解决了一些差分方程。差分方程是微分方程的"离散版"，描述的是数列之间的关系，而不是连续函数之间的关系。但欧拉可能没有意识到，这个思想可以推广到连续世界。
拉格朗日的尝试 约瑟夫·路易·拉格朗日（Joseph-Louis Lagrange）在1770年代进一步发展了这个思想。他研究的不是差分方程，而是真正的微分方程。拉格朗日发现，某些类型的微分方程可以通过"变量替换"的方法简化。
想象一下，你有一个复杂的机器，操作起来很困难。但如果你换一个视角——比如把机器拆开，从另一个角度观察——可能会发现原来复杂的操作变得简单了。拉格朗日的变量替换就是这种"换个视角"的方法。
但真正系统化这个想法的人，是皮埃尔-西蒙·拉普拉斯。
第二章：拉普拉斯的登场——从概率论开始 1782年的论文 1782年，年轻的拉普拉斯发表了一篇关于概率论的论文。这篇论文的标题很长，但核心思想很清晰：他想研究如何从有限的观察中推断出背后的规律。
在概率论中，一个核心问题是：如果你知道一个随机变量服从某种分布，但不知道分布的参数，你应该如何从观测数据中推断这些参数？拉普拉斯意识到，这个问题可以转化成一个积分方程的问题。
他考虑这样一个积分：
$$ F(s) = \int_0^{\infty} f(t) e^{-st} , dt $$
这里的 $f(t)$ 是某个概率密度函数，而 $F(s)$ 是它的"像函数"。拉普拉斯发现，通过这个变换，原来关于 $f(t)$ 的复杂运算可以转化成关于 $F(s)$ 的简单运算。
为什么是 $e^{-st}$？ 你可能会问：为什么拉普拉斯选择了 $e^{-st}$ 这个核函数？这不是凭空的选择，而是有深刻的原因。
首先，指数函数 $e^{-st}$ 有一个美妙的性质：它的导数和它自己成比例
$$ \frac{d}{dt} e^{-st} = -s e^{-st} $$
这意味着，如果你对 $e^{-st}$ 乘以 $f(t)$ 然后积分，再对 $s$ 求导，你得到的会是 $t$ 乘以原函数的某种变换。具体来说：
...</p></div><footer class=entry-footer><span title='2026-01-21 10:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>640 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 拉普拉斯变换：从概率论到工程数学的百年旅程" href=https://s-ai-unix.github.io/posts/2026-01-21-laplace-transform-history/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/gaussian-distribution.jpg alt=正态分布钟形曲线></figure><header class=entry-header><h2 class=entry-hint-parent>正态分布：从赌桌到宇宙的完美曲线</h2></header><div class=entry-content><p>引言：钟声隐隐 如果你走进一个 crowded 的教室，测量每个人的身高；或者在同一条件下反复测量一个物理量；又或者在工厂里统计成千上万件产品的尺寸——你会发现，这些数据总是呈现出一种奇特的规律：大部分数值聚集在中间，越往两端越少。
画出分布图，你会看到一条优雅的曲线——中间隆起如钟，两侧缓缓下降，渐近于零却永不触及。这就是正态分布（Normal Distribution），也叫高斯分布（Gaussian Distribution）或钟形曲线（Bell Curve）。
它是概率论中最重要、最自然的分布。从气体分子的运动到股票价格的波动，从人类的身高到测量的误差，正态分布无处不在。
但你是否想过：为什么大自然偏爱这种分布？这条曲线是如何被人类发现的？它背后隐藏着怎样的数学之美？
让我们穿越回17、18世纪，去看看这条曲线是如何在历史的迷雾中逐渐浮现的。
第一章：前史——测量与误差的困惑 伽利略的洞见 早在1632年，伽利略在他的《关于两大世界体系的对话》中就观察到了一个有趣的现象：当你反复测量某个物理量时，误差总是呈现出一种规律——小的误差比大的误差更常见，正误差和负误差出现的频率大致相等。
这是人类对"误差分布"最早的直觉认知之一。伽利略并没有给出数学公式，但他敏锐地察觉到：观测误差并非杂乱无章，而是遵循某种规律。
早期天文学家的困扰 17、18世纪的天文学家面临着一个实际问题：同一颗行星或恒星，不同观测者得到的数据总有微小差异。如何从这些"有误差"的观测值中推断出真实值？
当时流行的方法是取平均值，但没有人能从理论上解释为什么这样做是合理的。一个困扰着那个时代科学家的问题是：是否存在一种"最优"的估计方法？
这些朴素的问题和观察，为正态分布的发现埋下了种子。
第二章：意外发现——棣莫弗与二项分布的极限 正态分布的第一次正式登场，来自一个看似毫不相关的问题：赌博。
亚伯拉罕·棣莫弗 亚伯拉罕·棣莫弗（Abraham de Moivre, 1667-1754）是一位法国-英国数学家。他年轻时因宗教迫害流亡英国，在伦敦靠当家庭教师和赌博顾问维生。
1733年，棣莫弗在研究一个具体问题时做出了一个重大发现：当伯努利试验的次数 $n$ 很大时，二项分布可以用一条光滑的曲线来近似。
这个发现最初只是他一本小册子中的一段内容，后来被收录进1738年出版的《机遇原理》（The Doctrine of Chances）第二版中。
从二项分布到正态曲线 考虑抛硬币的问题：抛 $n$ 次硬币，出现 $k$ 次正面的概率由二项分布给出：
$$P(X = k) = \binom{n}{k}p^k(1-p)^{n-k}$$
当 $n$ 很大时，直接计算这个公式非常困难——阶乘会变得极其巨大。棣莫弗想知道：能否找到一个近似公式？
通过巧妙的数学技巧（斯特林公式的早期版本），棣莫弗发现：当 $n \to \infty$ 时，标准化的二项分布收敛到：
$$f(x) = \frac{1}{\sqrt{2\pi}}e^{-x^2/2}$$
这就是标准正态分布的概率密度函数！
图1：棣莫弗-拉普拉斯极限定理。当二项分布的试验次数 $n$ 增大时，标准化后的分布逐渐逼近标准正态分布（红色曲线）。
历史的遗憾 有趣的是，棣莫弗并不知道自己发现了一个"普适"的分布。他只是把它当作计算二项分布的一个实用技巧。他的工作也没有引起当时学术界的广泛关注。
直到多年后，这条曲线才被拉普拉斯和高斯重新发掘，并赋予其更深刻的意义。
flowchart LR A["1632伽利略观测误差规律"] --> B["1733棣莫弗二项分布极限"] B --> C["1809高斯误差理论"] C --> D["1810拉普拉斯中心极限定理"] D --> E["1860麦克斯韦对称性推导"] style A fill:#FF9500,color:#fff,stroke-width:2px style B fill:#FF9500,color:#fff,stroke-width:2px style C fill:#007AFF,color:#fff,stroke-width:3px style D fill:#34C759,color:#fff,stroke-width:2px style E fill:#34C759,color:#fff,stroke-width:2px 第三章：高斯的革命——误差理论与最小二乘法 正态分布真正成为概率论的核心，要归功于卡尔·弗里德里希·高斯（Carl Friedrich Gauss, 1777-1855）。
...</p></div><footer class=entry-footer><span title='2026-01-21 10:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>520 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 正态分布：从赌桌到宇宙的完美曲线" href=https://s-ai-unix.github.io/posts/2026-01-21-gaussian-distribution-history/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/shannon-entropy.jpg alt=信息熵与通信理论></figure><header class=entry-header><h2 class=entry-hint-parent>香农信息熵：不确定性的数学刻度</h2></header><div class=entry-content><p>引言：一条电报引发的思考 信息是什么？ 1844年5月24日，萨缪尔·摩斯（Samuel Morse）从华盛顿向巴尔的摩发出了人类历史上第一条电报：
“What hath God wrought!”
这四个单词穿越了64公里的铜线，开启了电信时代。但在庆祝之余，一个问题逐渐浮现：这条消息究竟包含了多少"信息"？
这个问题看似简单，实则深奥。“信息"是一个抽象的概念，如何用数学来量化它？一封情书和一份天气预报，哪一份包含更多"信息”？一条加密后的消息和原始消息，信息量是否相同？
这些问题的答案，隐藏在一位贝尔实验室工程师的伟大发现中。
香农的登场 1948年，克劳德·香农（Claude Shannon）发表了题为《通信的数学理论》的论文。这篇32页的论文，被誉为"数字时代的创世大宪章"。
在论文中，香农给出了"信息"的精确定义，并引入了一个核心概念——信息熵。这个名字借用了热力学中的"熵"，暗示了两者之间深刻的联系。
本文将带你踏上一段历史与数学交织的旅程，从电报时代的实际问题出发，逐步揭示信息熵的诞生、内涵及其深远影响。
第一章：信息时代的黎明——通信效率的困惑 1.1 摩斯电码中的智慧 在香农之前，通信工程师们已经面临着一个实际问题：如何用最少的符号传输最多的信息？
摩斯电码给出了一个直观的答案。观察摩斯电码的设计：
E: . (最常用) T: - (第二常用) A: .- Q: --.- (很少使用) Z: --.. 摩斯天才地意识到：常用的字母应该用较短的编码，不常用的字母可以用较长的编码。这个设计原则在今天看来理所当然，但在当时是革命性的。
但这引发了更深层的思考：如何精确衡量一个字母的"常用程度"？如何计算整个编码系统的效率？这些问题需要数学语言的精确描述。
1.2 电报的经济学问题 19世纪的电报按字收费，一条消息的成本与其长度直接相关。因此，压缩信息不仅是技术问题，更是经济问题。
工程师们开始思考：
如果我们能知道每个字母出现的概率，能否设计出最优的编码？ 通信线路的"容量"有没有理论极限？ 噪声（干扰）对信息传输的影响有多大？ 这些问题的答案，要等到20世纪才逐渐浮现。
flowchart LR subgraph A["19世纪通信挑战"] A1["摩斯电码1837"] A2["电报经济学按长度收费"] end subgraph B["20世纪理论突破"] B1["奈奎斯特1924"] B2["哈特利1928"] B3["香农1948"] end subgraph C["现代信息时代"] C1["数字通信"] C2["数据压缩"] C3["机器学习"] end A1 --> B1 A2 --> B2 B1 --> B3 B2 --> B3 B3 --> C1 B3 --> C2 B3 --> C3 style A1 fill:#34C759,color:#ffffff,stroke-width:2px style A2 fill:#34C759,color:#ffffff,stroke-width:2px style B1 fill:#007AFF,color:#ffffff,stroke-width:2px style B2 fill:#007AFF,color:#ffffff,stroke-width:2px style B3 fill:#007AFF,color:#ffffff,stroke-width:3px style C1 fill:#34C759,color:#ffffff,stroke-width:2px style C2 fill:#34C759,color:#ffffff,stroke-width:2px style C3 fill:#34C759,color:#ffffff,stroke-width:2px 第二章：先驱的脚步——奈奎斯特与哈特利 2.1 奈奎斯特的发现 1924年，贝尔实验室的哈里·奈奎斯特（Harry Nyquist）在研究电报传输时，做出了一个重要发现。
...</p></div><footer class=entry-footer><span title='2026-01-21 10:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>891 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 香农信息熵：不确定性的数学刻度" href=https://s-ai-unix.github.io/posts/2026-01-21-shannon-entropy-comprehensive-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/perceptron-history.jpg alt=感知机发展历程></figure><header class=entry-header><h2 class=entry-hint-parent>感知机的完整发展历程：从线性分类到深度学习的基石</h2></header><div class=entry-content><p>引言：人工智能的原点 在人工智能的发展历程中，感知机（Perceptron）是一个具有里程碑意义的概念。它不仅是最早的机器学习算法之一，也是现代深度学习和神经网络的基础。
感知机的故事开始于 20 世纪中叶，当时计算机科学刚刚萌芽，科学家们开始探索如何让机器具备"学习"的能力。
第一章：感知机的诞生背景 1.1 早期人工智能研究的梦想 20 世纪 40 年代末到 50 年代初，随着计算机的诞生，科学家们开始思考：机器能否像人一样思考和学习？
图灵测试：1950 年，艾伦·图灵提出了著名的图灵测试，为人工智能的发展奠定了理论基础。 神经网络的早期构想：1943 年，麦卡洛克和皮茨提出了第一个人工神经网络模型，称为麦卡洛克-皮茨神经元。 1.2 罗森布拉特的突破 1957 年，美国心理学家弗兰克·罗森布拉特（Frank Rosenblatt）在康奈尔航空实验室提出了感知机模型。他将感知机描述为"能够通过经验自动学习的机器"。
罗森布拉特的工作受到了神经科学的启发，他试图模拟人类大脑中神经元的工作方式。
第二章：感知机的核心原理 2.1 感知机的基本结构 感知机是一个简单的线性分类器，它的结构非常简单：
graph TD A[输入] --> B[权重] C[偏置] --> D[求和] B --> D D --> E[激活函数] E --> F[输出] style A color:#ffffff,fill:#007AFF,stroke:#007AFF,stroke-width:3px style B color:#ffffff,fill:#34C759,stroke:#34C759,stroke-width:2px style C color:#ffffff,fill:#34C759,stroke:#34C759,stroke-width:2px style D color:#ffffff,fill:#007AFF,stroke:#007AFF,stroke-width:3px style E color:#ffffff,fill:#007AFF,stroke:#007AFF,stroke-width:3px style F color:#ffffff,fill:#007AFF,stroke:#007AFF,stroke-width:3px 2.2 感知机的工作原理 感知机的工作原理可以用以下公式表示：
...</p></div><footer class=entry-footer><span title='2026-01-21 08:00:00 +0800 CST'>January 21, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>749 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 感知机的完整发展历程：从线性分类到深度学习的基石" href=https://s-ai-unix.github.io/posts/2026-01-21-perceptron-development-history/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/dirac-equation-cover.jpg alt=狄拉克方程的数学之美></figure><header class=entry-header><h2 class=entry-hint-parent>狄拉克方程：相对论量子力学的诞生</h2></header><div class=entry-content><p>引言:1928年的物理学困境 1928年的秋天,剑桥大学。一位26岁的年轻物理学家保罗·狄拉克(Paul Dirac)正面临着物理学界最根本的问题之一:如何将量子力学与狭义相对论统一起来?
当时的物理学界似乎被分裂成两个不相容的世界。一边是薛定谔方程,它在描述原子中的电子行为时取得了巨大成功,但只在低速情况下有效;另一边是爱因斯坦的狭义相对论,它精确地描述了高速运动物体的行为。问题是——这两个理论在数学结构上似乎根本无法协调。
让我们从这个困境出发,一步步理解狄拉克是如何通过数学的纯粹美感,找到了连接这两个世界的桥梁。
第一章:薛定谔方程的困境 1.1 非相对论量子力学的成功 1926年,奥地利物理学家埃尔温·薛定谔提出了著名的波动方程:
$$ i\hbar\frac{\partial}{\partial t}\psi(\mathbf{r},t) = \hat{H}\psi(\mathbf{r},t) $$
对于自由粒子(没有外力作用),哈密顿量是:
$$ \hat{H} = \frac{\hat{\mathbf{p}}^2}{2m} = -\frac{\hbar^2}{2m}\nabla^2 $$
这个方程在描述氢原子等低速系统时非常成功。它精确地预言了氢原子的能级,解释了原子光谱的规律。但是,如果你仔细观察这个方程的数学结构,会发现一个根本性的不对称性:
时间导数是一阶的: $\frac{\partial}{\partial t}$ 空间导数是二阶的: $\nabla^2 = \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2} + \frac{\partial^2}{\partial z^2}$ 这种不对称性意味着这个方程在洛伦兹变换下不会保持不变——换句话说,它不符合狭义相对论。
graph LR A[薛定谔方程非相对论量子力学] --> B[时间导数: 一阶空间导数: 二阶] B --> C[洛伦兹协变性破缺不符合狭义相对论] style A fill:#FF9500,stroke:#FF9500,stroke-width:2px,color:#ffffff style B fill:#AF52DE,stroke:#AF52DE,stroke-width:2px,color:#ffffff style C fill:#FF3B30,stroke:#FF3B30,stroke-width:3px,color:#ffffff 1.2 相对论的能量-动量关系 在狭义相对论中,自由粒子的能量和动量满足一个简单而优雅的关系:
...</p></div><footer class=entry-footer><span title='2026-01-20 20:00:00 +0800 CST'>January 20, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1485 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 狄拉克方程：相对论量子力学的诞生" href=https://s-ai-unix.github.io/posts/2026-01-20-dirac-equation-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1620712943543-bcc4688e7485.jpg alt=神经网络连接></figure><header class=entry-header><h2 class=entry-hint-parent>基于神经网络的深度学习算法：从感知机到Transformer的完整指南</h2></header><div class=entry-content><p>引言：从生物启发到智能革命 1943年，Warren McCulloch和Walter Pitts提出了第一个神经元数学模型。他们用一个简单的数学公式模拟了生物神经元的工作方式：接收输入、加权求和、激活输出。这个看似简单的想法，却孕育了后来改变世界的人工智能技术。
1958年，Frank Rosenblatt发明了感知机（Perceptron），这是第一个可以学习的神经网络。但1969年，Minsky和Papert在《Perceptrons》一书中证明了单层感知机无法解决异或（XOR）问题，这个致命缺陷导致了神经网络研究的第一次寒冬。
1986年，David Rumelhart、Geoffrey Hinton和Ronald Williams重新发现了反向传播算法，解决了多层网络的训练问题。神经网络迎来了短暂的春天。
但在90年代到2000年代初，支持向量机（SVM）等传统机器学习算法统治了学术界。神经网络因为数据量不足、计算能力有限、缺乏有效的训练技巧，再次陷入沉寂。
2012年，ImageNet竞赛上，Hinton的学生Alex Krizhevsky使用深度卷积神经网络AlexNet，以压倒性优势击败了传统方法，分类错误率从26%降低到15.3%。这一年，深度学习时代正式开启。
从此，深度学习以惊人的速度发展：2014年的VGG、GoogLeNet，2015年的ResNet解决深度退化问题，2017年的Transformer彻底改变自然语言处理，2022年的ChatGPT让全世界见识到大模型的力量。
本文将从数学原理出发，系统讲解深度学习的核心算法：从基础神经网络到卷积神经网络（CNN），从循环神经网络（RNN）到Transformer，最后探讨未来发展趋势。
第一章：神经网络的数学基础 1.1 单神经元：感知机的数学模型 1.1.1 前向传播 感知机是最基础的神经网络单元，模拟生物神经元的工作原理。给定输入向量 $x \in \mathbb{R}^d$，权重向量 $w \in \mathbb{R}^d$，偏置 $b \in \mathbb{R}$：
$$z = w^Tx + b = \sum_{i=1}^d w_i x_i + b$$
激活函数 $\sigma(z)$ 决定神经元的输出：
$$a = \sigma(z)$$
1.1.2 常用激活函数 Sigmoid函数： $$\sigma(z) = \frac{1}{1 + e^{-z}}$$
导数： $$\sigma’(z) = \sigma(z)(1 - \sigma(z))$$
性质：
输出范围：$(0, 1)$ S型曲线，可微 缺点：梯度消失（$| \sigma’(z) | \leq 0.25$），输出不以零为中心 Tanh函数： $$\tanh(z) = \frac{e^z - e^{-z}}{e^z + e^{-z}}$$
...</p></div><footer class=entry-footer><span title='2026-01-14 08:30:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>2188 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 基于神经网络的深度学习算法：从感知机到Transformer的完整指南" href=https://s-ai-unix.github.io/posts/2026-01-14-deep-learning-algorithms-comprehensive-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1509228468518-180dd4864904.jpg alt=抽象几何图形></figure><header class=entry-header><h2 class=entry-hint-parent>传统机器学习与统计学习算法：从理论到实践的完整指南</h2></header><div class=entry-content><p>引言：从统计学到机器学习 1956年，达特茅斯会议上正式提出了"人工智能"这个词。但在那之前的一百年里，统计学家们已经在用数学工具从数据中提取规律。高斯在1809年就用最小二乘法解决了天文学中的观测数据拟合问题，这可以看作是最早的机器学习算法。
机器学习和统计学习，本质上是一回事：从数据中学习规律，并用这些规律做出预测。只是出发点略有不同——统计学家关注估计的可靠性和显著性检验，而计算机科学家更关心算法的计算效率和泛化能力。
当我们说"传统机器学习"时，指的是深度学习时代之前的那些经典算法。这些算法虽然不像神经网络那样"万能"，但在数据量有限、需要可解释性的场景下，依然发挥着不可替代的作用。
第一章：统计学习的理论基础 1.1 学习问题的数学框架 假设我们有一个数据集 $D = {(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)}$，其中 $x_i \in \mathcal{X}$ 是输入（特征），$y_i \in \mathcal{Y}$ 是输出（标签）。我们的目标是找到一个函数 $f: \mathcal{X} \to \mathcal{Y}$，使得对于新的输入 $x$，$f(x)$ 能准确预测对应的 $y$。
但在统计学习的框架下，我们还需要引入概率论的概念。假设数据是按照某个未知的联合分布 $P(X,Y)$ 生成的，我们的目标是学习一个决策函数 $f$，使得期望风险最小化：
$$R(f) = \mathbb{E}_{(X,Y) \sim P}[L(Y, f(X))]$$
其中 $L$ 是损失函数。对于回归问题，常用平方损失；对于分类问题，常用0-1损失或交叉熵损失。
问题在于：我们不知道 $P(X,Y)$，无法直接计算 $R(f)$。我们只能用经验风险（Empirical Risk）来近似：
$$\hat{R}(f) = \frac{1}{n}\sum_{i=1}^n L(y_i, f(x_i))$$
这就是经验风险最小化（ERM）的基本思想。但直接最小化经验风险会导致过拟合（overfitting）。
1.2 偏差-方差权衡 这是统计学习中最重要的概念之一。模型的预测误差可以分解为三个部分：
$$\mathbb{E}[(y - \hat{f}(x))^2] = \text{Bias}[\hat{f}(x)]^2 + \text{Var}[\hat{f}(x)] + \sigma^2$$
其中：
$\text{Bias}[\hat{f}(x)] = \mathbb{E}[\hat{f}(x)] - f^{\ast}(x)$：模型预测的期望与真实值的差距 $\text{Var}[\hat{f}(x)] = \mathbb{E}[(\hat{f}(x) - \mathbb{E}[\hat{f}(x)])^2]$：模型预测的方差 $\sigma^2$：不可约误差（数据本身的噪声） 偏差反映了模型的"假设强度"。如果模型过于简单（比如用线性模型拟合高度非线性的数据），会产生高偏差，导致欠拟合。
...</p></div><footer class=entry-footer><span title='2026-01-14 08:18:25 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>2161 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 传统机器学习与统计学习算法：从理论到实践的完整指南" href=https://s-ai-unix.github.io/posts/2026-01-14-traditional-ml-algorithms-comprehensive-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/iso26262-10-guideline.jpg alt="ISO 26262 指南"></figure><header class=entry-header><h2 class=entry-hint-parent>ISO 26262-10 指南：标准实施的实践指南</h2></header><div class=entry-content><p>引言 ISO 26262 标准提供了完整的汽车功能安全要求，但在实际应用中，如何正确理解和应用这些要求是一个挑战。ISO 26262-10 指南部分正是为了解决这个问题而设计的，它提供了详细的解释、示例和最佳实践。
想象一个真实场景：某汽车电子公司的工程师在实施 ASIL D 项目时，对于如何确定硬件架构指标（SPFM、LFM）存在困惑。不同的工程师有不同的理解，导致项目进展缓慢。
这个案例告诉我们：**需要详细的指南和示例来帮助正确理解和应用 ISO 26262 标准。**这正是 ISO 26262-10 指南部分的核心使命。
指南的结构和内容 指南的目的 ISO 26262-10 的主要目的是：
解释标准要求：详细解释 ISO 26262 各部分的要求 提供示例：提供实际应用的示例 分享最佳实践：分享行业最佳实践 解决常见问题：解决常见的问题和困惑 指南的内容 ISO 26262-10 包含以下内容：
概念阶段的指南
危害分析（HARA）的示例 ASIL 确定的示例 功能安全概念的示例 系统级开发的指南
系统架构设计的示例 技术 安全概念的示例 系统集成和测试的示例 硬件级开发的指南
硬件架构设计的示例 FMEDA 分析的示例 硬件架构指标计算的示例 软件级开发的指南
软件架构设计的示例 软件单元测试的示例 软件集成和测试的示例 生产和运行的指南
生产一致性的示例 服务和维护的示例 支持过程的指南
配置管理的示例 文档管理的示例 工具置信度评估的示例 ASIL 导向分析的指南
FMEA 的示例 FTA 的示例 STPA 的示例 概念阶段的指南 危害分析（HARA）的示例 示例 1：制动系统的 HARA 系统功能：电子液压制动系统（EHB）
...</p></div><footer class=entry-footer><span title='2026-01-04 00:00:00 +0000 UTC'>January 4, 2026</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>1596 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to ISO 26262-10 指南：标准实施的实践指南" href=https://s-ai-unix.github.io/posts/2026-01-04-iso26262-10-guideline/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/iso26262-overview.jpg alt="ISO 26262 功能安全整体框架"></figure><header class=entry-header><h2 class=entry-hint-parent>ISO 26262 整体综述：汽车功能安全的完整体系</h2></header><div class=entry-content><p>引言 在汽车电子化、智能化迅猛发展的今天，一辆现代汽车可能包含上百个电子控制单元（ECU），数千行软件代码，以及复杂的传感器和执行器网络。当这些系统失效时，后果可能是灾难性的。这就是为什么 ISO 26262——道路车辆功能安全标准——成为汽车行业的圣经。
ISO 26262 不是一本简单的操作手册，而是一个完整的体系，包含 12 个相互关联的标准文件。这 12 个文件就像乐高积木，每个都有其特定的功能和位置，只有将它们正确地组合在一起，才能构建出功能安全的汽车电子系统。
在本系列文章中，我们已经深入解读了 ISO 26262 的每一个部分。在本文中，我们将从整体视角审视这个标准，理解它们如何协同工作，形成一个完整的汽车功能安全体系。
ISO 26262 的诞生与演进 为什么需要功能安全标准？ 在 ISO 26262 诞生之前，汽车行业使用的是 IEC 61508——通用的功能安全标准。然而，汽车电子有其特殊性：
安全性要求高：汽车故障可能导致人员伤亡 成本敏感：汽车是大宗消费品，必须控制成本 供应链复杂：涉及 OEM、Tier 1、Tier 2、半导体供应商等多方 使用环境苛刻：温度、湿度、振动、电磁干扰等 因此，ISO 于 2011 年发布了专门针对道路车辆的 ISO 26262 标准，并于 2018 年进行了全面更新（第二版）。
标准的总体目标 ISO 26262 的核心目标可以用一句话概括：
确保电子电气系统在发生故障时，不会导致不合理的安全风险
这个目标分解为三个关键要素：
预防性开发：通过系统化的开发过程，预防系统性故障 故障控制：通过安全机制，检测和控制随机硬件故障 全生命周期管理：从概念到报废的全程安全管理 与 IEC 61508 的关系 ISO 26262 是 IEC 61508 在汽车领域的应用和裁剪，两者关系如下：
特性 IEC 61508 ISO 26262 应用领域 所有行业 道路车辆 SIL 等级 SIL 1-4 ASIL A-D (汽车) / MSIL (摩托车) 特化程度 通用 汽车特定 复杂度 高 中等（更易理解） ISO 26262 的 12 个部分：全景图 ISO 26262 分为 12 个部分，每个部分都有其特定的职责和范围：
...</p></div><footer class=entry-footer><span title='2026-01-01 00:00:00 +0000 UTC'>January 1, 2026</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>1498 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to ISO 26262 整体综述：汽车功能安全的完整体系" href=https://s-ai-unix.github.io/posts/2026-01-01-iso26262-overview/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://s-ai-unix.github.io/tags/%E7%BB%BC%E8%BF%B0/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://s-ai-unix.github.io/tags/%E7%BB%BC%E8%BF%B0/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://s-ai-unix.github.io/>s-ai-unix's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var t,n=e.innerHTML,s=!1;for(n.indexOf("<em>")!==-1&&(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("</em>")!==-1&&(t=n.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),t=t.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),t!==n&&(n=t,s=!0)),n.indexOf("<em>$")!==-1&&(t=n.replace(/<em>\$/g,"$"),t!==n&&(n=t,s=!0)),n.indexOf("</em>$")!==-1&&(t=n.replace(/<\/em>\$/g,"$"),t!==n&&(n=t,s=!0));n.indexOf("<em>")!==-1&&n.indexOf("</em>")!==-1;){if(t=n.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),t=t.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),t===n)break;n=t,s=!0}n.indexOf("_{")!==-1&&(t=n.replace(/_{/g,"_{"),t!==n&&(n=t,s=!0)),n.indexOf("}_")!==-1&&(t=n.replace(/}_/g,"}"),t!==n&&(n=t,s=!0)),n.includes("</em>{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<\/em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),n.includes("<em>{\\mathrm{")&&(t=n.replace(/\\mathbf\{(W|x|y|z)\}<em>\{\\mathrm\{([a-z]+)\}\}/g,"\\mathbf{$1}_{\\mathrm{$2}}"),t=t.replace(/([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t=t.replace(/\\nabla ([LHf])<em>\{\\mathrm\{([a-z]+)\}\}/g,`\\nabla $1_{\\mathrm{$2}}`),t=t.replace(/([A-Z])<em>\{\\mathrm\{([a-z]+)\}\}/g,"$1_{\\mathrm{$2}}"),t!==n&&(n=t,s=!0)),(n.includes("</em>")||n.includes("<em>"))&&(t=n.replace(/(\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$\$[^$]*?)<em>([^$]*?)<\/em>/g,"$1_{$2}"),t=t.replace(/(\$[^$]*?)<em>/g,"$1"),t=t.replace(/<em>([^$]*?\$)/g,"$1"),t=t.replace(/(\$[^$]*?)<\/em>/g,"$1"),t=t.replace(/<\/em>([^$]*?\$)/g,"$1"),t!==n&&(n=t,s=!0)),n.indexOf("\\\\")!==-1&&(t=n.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),t!==n&&(n=t,s=!0)),s&&(e.innerHTML=n)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",packages:{"[+]":["noerrors","noundefined","boldsymbol"]},macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script></body></html>