<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数学史 | s-ai-unix's Blog</title><meta name=keywords content><meta name=description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta name=author content="s-ai-unix"><link rel=canonical href=https://s-ai-unix.github.io/tags/%E6%95%B0%E5%AD%A6%E5%8F%B2/><link crossorigin=anonymous href=/assets/css/stylesheet.0833aff7e1cf567ecfb9755701ee95a80535f671e2e1a0a770c9bc20a0a7b5bb.css integrity="sha256-CDOv9+HPVn7PuXVXAe6VqAU19nHi4aCncMm8IKCntbs=" rel="preload stylesheet" as=style><link rel=icon href=https://s-ai-unix.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s-ai-unix.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s-ai-unix.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s-ai-unix.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s-ai-unix.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://s-ai-unix.github.io/tags/%E6%95%B0%E5%AD%A6%E5%8F%B2/index.xml title=rss><link rel=alternate hreflang=en href=https://s-ai-unix.github.io/tags/%E6%95%B0%E5%AD%A6%E5%8F%B2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://s-ai-unix.github.io/tags/%E6%95%B0%E5%AD%A6%E5%8F%B2/"><meta property="og:site_name" content="s-ai-unix's Blog"><meta property="og:title" content="数学史"><meta property="og:description" content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="数学史"><meta name=twitter:description content="s-ai-unix 的个人技术博客，分享数学、AI、产品设计、数据科学、智能汽车(设计、研发、质量、合规)、历史等领域的知识和思考"><link rel=stylesheet href=https://s-ai-unix.github.io/css/classical-quote.css></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://s-ai-unix.github.io/ accesskey=h title="s-ai-unix's Blog (Alt + H)">s-ai-unix's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s-ai-unix.github.io/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://s-ai-unix.github.io/posts/ title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://s-ai-unix.github.io/archives/ title="📁 归档"><span>📁 归档</span></a></li><li><a href=https://s-ai-unix.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://s-ai-unix.github.io/search/ title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://s-ai-unix.github.io/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://s-ai-unix.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://s-ai-unix.github.io/tags/>Tags</a></div><h1>数学史</h1></header><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/unsplash-taylor.jpg alt=抽象几何曲线></figure><header class=entry-header><h2 class=entry-hint-parent>泰勒公式：用简单近似复杂的艺术</h2></header><div class=entry-content><p>引言：从曲线到直线 想象你站在一座山上，想知道脚下的山坡有多陡。你不需要知道整个山脉的形状，只需要知道你所在位置的局部斜率。这是微积分最基本的思想——用局部信息推断全局行为。
更进一步，如果山坡弯曲了怎么办？这时不仅需要知道斜率，还需要知道弯曲的程度。这就是泰勒公式的核心思想：用最简单的函数（多项式）来近似复杂的函数，而近似的质量取决于我们使用多少局部信息（导数）。
泰勒公式被誉为"数学家最有力的工具之一"。它不仅连接了离散与连续、局部与整体，更在数值计算、物理建模和现代人工智能中扮演着不可替代的角色。今天，让我们深入探索这个既古老又常新的数学宝藏。
一、历史回顾：从牛顿到泰勒 泰勒公式的思想可以追溯到牛顿和莱布尼茨创立微积分的时期。牛顿在他的《流数术》中已经隐含了将函数展开为无穷级数的想法。
布鲁克·泰勒（Brook Taylor，1685-1731）在1715年发表了他的开创性论文《增量法及其逆运算》，首次系统地阐述了用多项式级数逼近函数的方法。有趣的是，泰勒本人并没有意识到他发现的公式的全部潜力，余项的研究（拉格朗日余项、柯西余项等）是后来由拉格朗日等数学家完善的。
麦克劳林（Colin Maclaurin）发现了泰勒公式在零点展开的特例，即麦克劳林级数。这个形式在实际计算中更为常用，因为计算起来更加方便。
二、一元函数的泰勒公式 基本形式 假设函数 $f(x)$ 在点 $a$ 处足够光滑（即具有各阶导数），那么我们可以构造一个多项式 $P_n(x)$ 来近似 $f(x)$：
$$ P_n(x) = f(a) + f’(a)(x-a) + \frac{f’’(a)}{2!}(x-a)^2 + \cdots + \frac{f^{(n)}(a)}{n!}(x-a)^n $$
泰勒公式告诉我们：
$$ f(x) = P_n(x) + R_n(x) $$
其中 $R_n(x)$ 是余项，表示近似误差。
余项的几种形式 理解余项对于掌握泰勒公式至关重要，因为它告诉我们近似在什么范围内可靠。
拉格朗日余项：
$$ R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-a)^{n+1} $$
其中 $\xi$ 是 $a$ 和 $x$ 之间的某个值。
积分余项：
$$ R_n(x) = \frac{1}{n!} \int_a^x f^{(n+1)}(t)(x-t)^n , dt $$
直观理解 让我们通过一个简单的例子来理解泰勒公式。考虑 $f(x) = e^x$ 在 $a = 0$ 处的泰勒展开（即麦克劳林级数）：
...</p></div><footer class=entry-footer><span title='2026-01-14 22:10:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1110 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 泰勒公式：用简单近似复杂的艺术" href=https://s-ai-unix.github.io/posts/2026-01-14-taylor-series/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/unsplash-laplacian.jpg alt=抽象几何图形></figure><header class=entry-header><h2 class=entry-hint-parent>拉普拉斯方程：数学物理中的优雅平衡</h2></header><div class=entry-content><p>引言：一片平静的水面 想象一个平静的水面，没有风，没有涟漪。如果我们在水面上轻轻滴一滴墨水，墨水会如何扩散？这背后隐藏着一个深刻的数学原理。
再想象一个均匀导热的金属板，边缘保持恒定温度。时间足够长后，板内部的温度分布会达到一种稳定状态。有趣的是，这种稳定状态有一个共同的数学描述。
这就是拉普拉斯方程的魔法所在。它描述的是一种完美的"平衡"状态——系统中每一点的数值都与其周围邻居的平均值相等。这个简单的条件，却蕴含着自然界中无数现象的精髓。
一、历史的足迹 皮埃尔-西蒙·拉普拉斯（Pierre-Simon Laplace，1749-1827）是法国数学家、天文学家和物理学家。他在研究天体力学和引力问题时，首次系统地研究了这个以他名字命名的方程。
但拉普拉斯方程的发现并非孤立的。在此之前，欧拉（Euler）和达朗贝尔（d’Alembert）已经在流体力学和波动方程的研究中涉及了类似的思想。拉普拉斯的贡献在于他系统性地研究了这个方程，并将其推广到多个变量，使其成为研究各种物理现象的统一框架。
二、从一维开始：最简单的平衡 让我们从最简单的一维情况开始理解拉普拉斯方程。
一维拉普拉斯方程 在一维情况下，拉普拉斯方程的形式异常简洁：
$$ \frac{d^2 u}{dx^2} = 0 $$
其中 $u(x)$ 是我们要找的函数。
这个方程说的是什么呢？它的意思是函数的二阶导数为零。在微积分中我们知道，如果二阶导数为零，那么一阶导数必须是常数：
$$ \frac{du}{dx} = C_1 $$
再积分一次，我们得到：
$$ u(x) = C_1 x + C_2 $$
这告诉我们，在一维情况下，满足拉普拉斯方程的函数只能是线性函数（直线）。
物理意义 想象一根均匀的导热棒，两端分别保持不同的温度。当热传导达到稳定状态时，温度分布会是怎样的？
如果棒长为 $L$，左端温度为 $T_1$，右端温度为 $T_2$，那么温度分布 $u(x)$ 满足：
$$ \frac{d^2 u}{dx^2} = 0, \quad u(0) = T_1, \quad u(L) = T_2 $$
解这个方程，我们得到：
$$ u(x) = T_1 + \frac{T_2 - T_1}{L} x $$
...</p></div><footer class=entry-footer><span title='2026-01-14 22:04:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>665 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 拉普拉斯方程：数学物理中的优雅平衡" href=https://s-ai-unix.github.io/posts/2026-01-14-laplace-equation/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/wave-equation.jpg alt=波动的抽象可视化></figure><header class=entry-header><h2 class=entry-hint-parent>波动方程：从弦振动到宇宙的波动</h2></header><div class=entry-content><p>引言：从一根振动的吉他弦开始 想象一下，你拨动吉他的一根弦。弦开始振动，发出优美的声音。如果你用高速摄像机拍摄这个过程，会看到弦的形状随时间不断变化：向上弯曲，向下弯曲，再向上弯曲……这种运动有什么规律？
更具体地说，如果已知某个时刻弦的形状，你能预测下一时刻它的形状吗？这个问题看似简单，但它引领我们走向数学物理中最重要的方程之一——波动方程。
在 18 世纪，几位伟大的数学家——达朗贝尔（d’Alembert）、欧拉（Euler）和伯努利（Bernoulli）——都在思考这个问题。他们的答案不仅解释了弦振动，还为声学、光学、地震学甚至量子力学奠定了基础。
让我们从这根弦开始，一步步揭开波动方程的面纱。
第一章：波动的物理本质 什么是波？ 在开始推导方程之前，我们需要明确：什么是波？
波是振动在空间中的传播。当某个点的物理量（如位移、压力、电场等）随时间振动时，这种振动会影响周围的点，并传播出去。波不需要物质的长距离移动，它传播的是能量和信息。
想象一下水面上的波纹。当你往平静的水面投一块石子，水并没有整体移动，但波纹会一圈圈扩散开来——这就是波的传播。
波的分类 波可以分为两大类：
横波（Transverse Wave）：振动方向与传播方向垂直
例子：吉他弦振动、光波 特点：弦上下的振动，波沿弦的方向传播 纵波（Longitudinal Wave）：振动方向与传播方向平行
例子：声波（空气分子的振动） 特点：空气分子沿声音传播方向前后振动 波的基本性质 描述波的几个关键参数：
频率 $f$：单位时间内振动的次数（单位：赫兹 Hz） 周期 $T = \frac{1}{f}$：完成一次振动所需的时间 波长 $\lambda$：波完成一个周期在空间中传播的距离 波速 $c$：波传播的速度，满足 $c = f\lambda$ 振幅 $A$：波偏离平衡位置的最大值 这些参数不是孤立的，它们通过波动方程联系在一起。
第二章：一维波动方程的诞生 牛顿第二定律与弦的振动 考虑一根均匀的弦，两端固定（比如吉他弦）。设弦的线密度（单位长度的质量）为 $\rho$，张力为 $T_0$。弦在平衡时是一条直线。
当弦发生微小振动时，设弦上位置 $x$、时间 $t$ 的横向位移为 $u(x, t)$。我们的目标是推导 $u(x, t)$ 满足的方程。
取弦上从 $x$ 到 $x + \Delta x$ 的一小段。这一段的长度约为 $\Delta x$，质量为 $\rho \Delta x$。
根据牛顿第二定律（$F = ma$），这一小段的运动方程为：
...</p></div><footer class=entry-footer><span title='2026-01-14 22:04:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1173 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 波动方程：从弦振动到宇宙的波动" href=https://s-ai-unix.github.io/posts/2026-01-14-wave-equation/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1620641788421-7a1c342ea42e.jpg alt=抽象几何空间></figure><header class=entry-header><h2 class=entry-hint-parent>黎曼张量度量：弯曲空间的距离语言</h2></header><div class=entry-content><p>引言：如何测量弯曲的世界？ 想象一下，你生活在一个球面上。如果你想测量两点之间的距离，或者两条线之间的夹角，你会怎么做？
在平坦的欧几里得平面上，这很简单：距离用勾股定理计算，角度用点积定义。但在球面上，直线变成了大圆弧，勾股定理不再成立，角度的计算也变得更加复杂。
问题的关键在于：我们需要一个通用的方法来定义任意空间中的距离和角度。
这个方法就是黎曼度量（Riemannian Metric），或者更准确地说，度量张量（Metric Tensor）。它是黎曼几何的基础，也是广义相对论中描述时空的核心工具。
第一章：从勾股定理到度量张量 欧几里得距离 在二维欧几里得平面上，两点 $(x_1, y_1)$ 和 $(x_2, y_2)$ 之间的距离是：
$$ d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} $$
这个公式源自勾股定理。更一般地，如果我们考虑一个微小的位移 $(dx, dy)$，那么对应的距离是：
$$ ds^2 = dx^2 + dy^2 $$
这个表达式被称为线元素（line element）。它告诉我们：沿 $x$ 方向移动 $dx$，沿 $y$ 方向移动 $dy$，总距离的平方是 $dx^2 + dy^2$。
三维欧几里得空间 在三维欧几里得空间中，线元素是：
$$ ds^2 = dx^2 + dy^2 + dz^2 $$
我们可以把它写成矩阵形式：
$$ ds^2 = \begin{pmatrix} dx & dy & dz \end{pmatrix} \begin{pmatrix} 1 & 0 & 0 \ 0 & 1 & 0 \ 0 & 0 & 1 \end{pmatrix} \begin{pmatrix} dx \ dy \ dz \end{pmatrix} $$
...</p></div><footer class=entry-footer><span title='2026-01-14 21:35:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1144 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 黎曼张量度量：弯曲空间的距离语言" href=https://s-ai-unix.github.io/posts/2026-01-14-riemann-metric-tensor/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1509228468518-180dd4864904.jpg alt=抽象几何空间></figure><header class=entry-header><h2 class=entry-hint-parent>黎曼曲率张量：弯曲时空的数学语言</h2></header><div class=entry-content><p>引言：从二维到无穷维 在我们之前的文章中，我们探索了高斯曲率（Gaussian Curvature），这个概念描述了二维曲面的弯曲程度。高斯的伟大发现是：曲面的弯曲是"内蕴"的，即只依赖于曲面自身的度量，而与曲面在三维空间中的嵌入方式无关。
但是，如果我们生活在四维时空中呢？或者更高维的空间？我们还能用同样的方式描述弯曲吗？
答案是肯定的，但需要更加强大的数学工具。这个工具就是黎曼曲率张量（Riemann Curvature Tensor），由伟大的数学家伯恩哈德·黎曼（Bernhard Riemann）在19世纪中叶提出。
黎曼曲率张量是黎曼几何的核心概念，它不仅推广了高斯曲率，更成为了广义相对论中描述时空弯曲的数学基础。
第一章：回顾高斯的遗产 在深入黎曼曲率张量之前，让我们简要回顾高斯的工作。
高斯曲率与绝妙定理 对于二维曲面，高斯曲率 $K$ 定义为：
$$ K = \frac{LN - M^2}{EG - F^2} $$
其中 $E, F, G$ 是第一基本形式的系数，$L, M, N$ 是第二基本形式的系数。
高斯的绝妙定理告诉我们：$K$ 可以仅用 $E, F, G$ 及其导数表示，因此是曲面的内蕴性质。
这个定理暗示了一个深刻的观点：空间本身可能有内在的几何结构，这种结构不依赖于任何"外部"空间。
从曲面到更高维度 高斯的工作集中在二维曲面上。但问题是：如何将这个思想推广到更高维度？
答案是：我们需要一种能够描述任意维度空间弯曲的数学对象。这个对象必须满足：
在二维情况下，它应该退化到高斯曲率 它应该包含足够的信息来描述任意方向、任意平面上的弯曲 它应该是内蕴的（即只依赖于度量） 黎曼曲率张量正是满足这些要求的数学对象。
第二章：黎曼的远见——1854年的演讲 伯恩哈德·黎曼（1826-1866） 伯恩哈德·黎曼是高斯的学生，也是数学史上最具原创性的思想家之一。他的工作跨越数论、复分析、微分几何等多个领域。
1854年6月10日，黎曼在哥廷根大学做了题为**《论几何基础的假设》**（Über die Hypothesen, welche der Geometrie zu Grunde liegen）的演讲。这篇演讲被认为是微分几何史上最重要的文献之一，也是黎曼几何的奠基之作。
黎曼几何的基本思想 在这次演讲中，黎曼提出了一个革命性的想法：几何不一定是三维欧几里得空间的子集，它可以是任意维度的"流形"（manifold）。
黎曼定义：
流形（Manifold）：局部看起来像欧几里得空间的几何对象 度量（Metric）：定义流形上两点之间的距离和角度 曲率（Curvature）：描述流形的弯曲程度 黎曼意识到：如果我们有一个度量 $g_{ij}$，我们可以计算各种几何量，包括曲率。但这个曲率在高维情况下应该是什么样的？
黎曼的原始定义 黎曼在演讲中给出了曲率的原始定义（与现代形式略有不同）：
考虑流形上一点 $P$，取两个切向量 $X, Y$。沿着由 $X$ 和 $Y$ 张成的二维平面，我们可以构建一个"测地三角形"。这个三角形在流形上沿着测地线（最短路径）连接三点。
...</p></div><footer class=entry-footer><span title='2026-01-14 21:28:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>858 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 黎曼曲率张量：弯曲时空的数学语言" href=https://s-ai-unix.github.io/posts/2026-01-14-riemann-curvature-tensor/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1635070041078-e363dbe005cb.jpg alt=抽象几何图形></figure><header class=entry-header><h2 class=entry-hint-parent>高斯曲率：弯曲世界的数学语言</h2></header><div class=entry-content><p>引言：弯曲的世界 想象一下，你是一只蚂蚁，生活在一个巨大的球面上。对于这只蚂蚁来说，这个世界看起来是什么样子的？如果你问它：“这个世界是平的还是弯曲的？“它会怎么回答？
这个问题看似简单，却蕴含着深刻的数学思想。古希腊的欧几里得用五条公理构建了完美的平面几何学，但现实世界中的曲面——球面、马鞍面、波浪形的海浪——让数学家们不得不思考：如何描述这些弯曲的几何形状？
答案就是曲率，特别是高斯曲率（Gaussian Curvature）。这个概念不仅改变了我们对几何的理解，更成为了现代物理的基石。
第一章：曲率的直观理解 在深入数学之前，让我们先从直觉出发，理解什么是"弯曲”。
直线的曲率 一条直线没有弯曲，我们说它的曲率为零。这一点很直观——直线上任意一点都朝同一个方向延伸，没有"拐弯”。
圆的曲率呢？如果一个圆的半径是 $R$，那么它的曲率定义为：
$$ \kappa = \frac{1}{R} $$
这个定义很合理：圆越小（半径越小），弯曲得越厉害，曲率越大；圆越大（半径越大），弯曲越不明显，曲率越小；当半径趋于无穷大时，圆就变成了直线，曲率趋于零。
平面曲线的曲率 对于任意一条平面曲线，我们可以这样定义曲率：在某一点处，找一个最接近该曲线的圆（称为"密切圆"），这个圆的曲率就是曲线在该点的曲率。
数学上，如果曲线由参数方程 $(x(t), y(t))$ 给出，曲率的公式是：
$$ \kappa = \frac{|x’(t)y’’(t) - y’(t)x’’(t)|}{(x’(t)^2 + y’(t)^2)^{3/2}} $$
这个公式看起来有点复杂，但本质上就是用曲线的二阶导数（加速度）来描述弯曲程度。
从曲线到曲面 现在我们要迈出关键的一步：从曲线到曲面。球面是弯曲的，马鞍面也是弯曲的，但它们"弯曲"的方式不同。这种差异，正是高斯曲率要捕捉的。
第二章：从平面到曲面——数学家的探索 古希腊的遗产 古希腊几何学以欧几里得的《几何原本》为代表，建立在五条公理之上。其中最著名的是第五公理（平行公理）：“过直线外一点，有且只有一条直线与该直线平行。”
这条公理在平面上成立，但在曲面上却不一定成立。这暗示着，曲面的几何可能与平面有本质区别。
黎曼前的探索 在19世纪初，数学家们开始思考更一般的几何学。Gauss（高斯）之前的一些数学家，如Monge和Euler，已经研究过曲面的某些性质。
莱昂哈德·欧拉（Leonhard Euler）在1760年给出了一个重要发现：对于曲面上的任意一点，存在两个特殊的方向，沿着这两个方向的法曲率分别取得最大值和最小值。这两个值被称为主曲率，记为 $\kappa_1$ 和 $\kappa_2$。
欧拉还发现了一个重要公式：如果两个主方向之间的夹角是 $\theta$，那么沿着与第一个主方向夹角为 $\phi$ 的方向的法曲率是：
$$ \kappa_n(\phi) = \kappa_1 \cos^2 \phi + \kappa_2 \sin^2 \phi $$
这个公式被称为欧拉曲率公式，它告诉我们，如果知道了两个主曲率，就知道了一切方向的法曲率。
但欧拉的研究有一个局限：他只考虑了法曲率，即沿着某个方向在法平面内的曲率。这种曲率依赖于曲面在空间中的"嵌入方式"，被称为"外蕴曲率"（extrinsic curvature）。
卡尔·弗里德里希·高斯的登场 卡尔·弗里德里希·高斯（Carl Friedrich Gauss, 1777-1855）是数学史上最伟大的数学家之一。他在1827年发表了一篇里程碑式的论文：《关于曲面的一般研究》（Disquisitiones Generales Circa Superficies Curvas）。
...</p></div><footer class=entry-footer><span title='2026-01-14 21:16:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1121 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 高斯曲率：弯曲世界的数学语言" href=https://s-ai-unix.github.io/posts/2026-01-14-gaussian-curvature/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/geometry-curves.jpg alt=几何曲线的抽象艺术图></figure><header class=entry-header><h2 class=entry-hint-parent>Frenet标架：微分几何的优雅语言与工程实践</h2></header><div class=entry-content><p>引言：从高速公路的弯道说起 想象一下，你正驾驶着汽车行驶在高速公路上，前方出现一个弯道。作为驾驶员，你会下意识地做几件事：判断弯道的急缓程度（曲率）、调整方向盘的角度（切向量）、控制车速，甚至在复杂的弯道上，你会感受到车身有轻微的侧倾或仰俯（挠率）。
这些看似简单的驾驶行为背后，隐藏着深刻的数学原理：如何在任意一点附近，用最简洁的方式描述一条空间曲线的几何性质？
这就是19世纪数学家们面临的核心问题。而他们的答案——Frenet标架（Frenet Frame），不仅成为了微分几何的基石，更在今天的自动驾驶和机器人工程中扮演着不可或缺的角色。
让我们从这段跨越170年的数学之旅开始，逐步揭开Frenet标架的神秘面纱。
第一章：19世纪的几何革命 在19世纪中叶，微分几何正处于一个激动人心的时期。传统的欧几里得几何关注的是静态的图形性质——三角形的内角和、圆的面积等等。但数学家们开始思考一个更动态的问题：如何研究"弯曲"的对象？
这个问题的种子早在17世纪就由牛顿和莱布尼茨播下——微积分的发明让人们能够描述变化的速率。到了19世纪，数学家们意识到，微积分可以用来研究曲线和曲面的局部性质，而不只是全局性质。
Frenet的突破 1847年，法国数学家Jean Frédéric Frenet在他的博士论文中提出了一个革命性的想法：在空间曲线上的每一点，我们可以建立一个自然的局部坐标系。这个坐标系不是任意选择的，而是由曲线本身的几何性质唯一确定的。
Serret的独立发现 几乎在同一时间，另一位法国数学家Joseph Alfred Serret也独立地发现了同样的结果。这就是为什么这个框架被称为"Frenet-Serret公式"。今天，我们更常称之为"Frenet标架"，以纪念Frenet率先发表的贡献。
这个发现的巧妙之处在于：它用三个相互正交的向量，完整地刻画了曲线在任意点的局部几何。这三个向量——切向量、法向量和副法向量——构成了一个"移动标架"，随着我们在曲线上移动而不断变化。
第二章：构建Frenet标架——从直觉到严谨 让我们从直观到严谨，一步步构建Frenet标架。
第一步：切向量（Tangent Vector） 想象一辆小车沿着一条空间曲线行驶。在任意时刻，小车都有一个瞬时速度向量，指向它运动的方向。这个方向就是曲线在该点的切线方向。
假设曲线由参数方程 $\mathbf{r}(t) = (x(t), y(t), z(t))$ 描述，其中 $t$ 是参数（可以想象成时间）。那么切向量就是速度向量：
$$ \mathbf{v}(t) = \frac{d\mathbf{r}}{dt} = \left(\frac{dx}{dt}, \frac{dy}{dt}, \frac{dz}{dt}\right) $$
这个向量的大小代表了运动的快慢，但作为几何性质，我们更关注方向。因此，我们将切向量标准化为单位向量：
$$ \mathbf{T}(t) = \frac{\mathbf{v}(t)}{|\mathbf{v}(t)|} = \frac{\frac{d\mathbf{r}}{dt}}{\left|\frac{d\mathbf{r}}{dt}\right|} $$
直觉理解：$\mathbf{T}$ 指向曲线"前方"，代表运动的方向。
第二步：主法向量（Principal Normal Vector） 接下来，我们考虑切向量的变化率。$\mathbf{T}$ 的方向会随着曲线弯曲而改变，这种改变的方向如何描述？
对 $\mathbf{T}$ 求导：
$$ \frac{d\mathbf{T}}{ds} $$
这里我们用弧长 $s$ 作为参数（稍后解释为什么）。由于 $\mathbf{T}$ 是单位向量，$\mathbf{T} \cdot \mathbf{T} = 1$，对其求导得到：
...</p></div><footer class=entry-footer><span title='2026-01-14 20:35:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1243 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to Frenet标架：微分几何的优雅语言与工程实践" href=https://s-ai-unix.github.io/posts/2026-01-14-frenet-frame-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/darboux-theory-of-surfaces.jpg alt=经典数学著作></figure><header class=entry-header><h2 class=entry-hint-parent>达布《曲面通论教程》：微分几何的里程碑式巨著</h2></header><div class=entry-content><p>系统介绍法国数学家加斯东·达布（Gaston Darboux）的四卷本《曲面通论教程》，阐述各卷内容与主要贡献</p></div><footer class=entry-footer><span title='2026-01-14 16:00:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>378 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 达布《曲面通论教程》：微分几何的里程碑式巨著" href=https://s-ai-unix.github.io/posts/2026-01-14-darboux-theory-of-surfaces/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1620712943543-bcc4688e7485.jpg alt=神经网络连接></figure><header class=entry-header><h2 class=entry-hint-parent>基于神经网络的深度学习算法：从感知机到Transformer的完整指南</h2></header><div class=entry-content><p>引言：从生物启发到智能革命 1943年，Warren McCulloch和Walter Pitts提出了第一个神经元数学模型。他们用一个简单的数学公式模拟了生物神经元的工作方式：接收输入、加权求和、激活输出。这个看似简单的想法，却孕育了后来改变世界的人工智能技术。
1958年，Frank Rosenblatt发明了感知机（Perceptron），这是第一个可以学习的神经网络。但1969年，Minsky和Papert在《Perceptrons》一书中证明了单层感知机无法解决异或（XOR）问题，这个致命缺陷导致了神经网络研究的第一次寒冬。
1986年，David Rumelhart、Geoffrey Hinton和Ronald Williams重新发现了反向传播算法，解决了多层网络的训练问题。神经网络迎来了短暂的春天。
但在90年代到2000年代初，支持向量机（SVM）等传统机器学习算法统治了学术界。神经网络因为数据量不足、计算能力有限、缺乏有效的训练技巧，再次陷入沉寂。
2012年，ImageNet竞赛上，Hinton的学生Alex Krizhevsky使用深度卷积神经网络AlexNet，以压倒性优势击败了传统方法，分类错误率从26%降低到15.3%。这一年，深度学习时代正式开启。
从此，深度学习以惊人的速度发展：2014年的VGG、GoogLeNet，2015年的ResNet解决深度退化问题，2017年的Transformer彻底改变自然语言处理，2022年的ChatGPT让全世界见识到大模型的力量。
本文将从数学原理出发，系统讲解深度学习的核心算法：从基础神经网络到卷积神经网络（CNN），从循环神经网络（RNN）到Transformer，最后探讨未来发展趋势。
第一章：神经网络的数学基础 1.1 单神经元：感知机的数学模型 1.1.1 前向传播 感知机是最基础的神经网络单元，模拟生物神经元的工作原理。给定输入向量 $x \in \mathbb{R}^d$，权重向量 $w \in \mathbb{R}^d$，偏置 $b \in \mathbb{R}$：
$$z = w^Tx + b = \sum_{i=1}^d w_i x_i + b$$
激活函数 $\sigma(z)$ 决定神经元的输出：
$$a = \sigma(z)$$
1.1.2 常用激活函数 Sigmoid函数： $$\sigma(z) = \frac{1}{1 + e^{-z}}$$
导数： $$\sigma’(z) = \sigma(z)(1 - \sigma(z))$$
性质：
输出范围：$(0, 1)$ S型曲线，可微 缺点：梯度消失（$| \sigma’(z) | \leq 0.25$），输出不以零为中心 Tanh函数： $$\tanh(z) = \frac{e^z - e^{-z}}{e^z + e^{-z}}$$
...</p></div><footer class=entry-footer><span title='2026-01-14 08:30:00 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>2188 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 基于神经网络的深度学习算法：从感知机到Transformer的完整指南" href=https://s-ai-unix.github.io/posts/2026-01-14-deep-learning-algorithms-comprehensive-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://s-ai-unix.github.io/images/covers/photo-1509228468518-180dd4864904.jpg alt=抽象几何图形></figure><header class=entry-header><h2 class=entry-hint-parent>传统机器学习与统计学习算法：从理论到实践的完整指南</h2></header><div class=entry-content><p>引言：从统计学到机器学习 1956年，达特茅斯会议上正式提出了"人工智能"这个词。但在那之前的一百年里，统计学家们已经在用数学工具从数据中提取规律。高斯在1809年就用最小二乘法解决了天文学中的观测数据拟合问题，这可以看作是最早的机器学习算法。
机器学习和统计学习，本质上是一回事：从数据中学习规律，并用这些规律做出预测。只是出发点略有不同——统计学家关注估计的可靠性和显著性检验，而计算机科学家更关心算法的计算效率和泛化能力。
当我们说"传统机器学习"时，指的是深度学习时代之前的那些经典算法。这些算法虽然不像神经网络那样"万能"，但在数据量有限、需要可解释性的场景下，依然发挥着不可替代的作用。
第一章：统计学习的理论基础 1.1 学习问题的数学框架 假设我们有一个数据集 $D = {(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)}$，其中 $x_i \in \mathcal{X}$ 是输入（特征），$y_i \in \mathcal{Y}$ 是输出（标签）。我们的目标是找到一个函数 $f: \mathcal{X} \to \mathcal{Y}$，使得对于新的输入 $x$，$f(x)$ 能准确预测对应的 $y$。
但在统计学习的框架下，我们还需要引入概率论的概念。假设数据是按照某个未知的联合分布 $P(X,Y)$ 生成的，我们的目标是学习一个决策函数 $f$，使得期望风险最小化：
$$R(f) = \mathbb{E}_{(X,Y) \sim P}[L(Y, f(X))]$$
其中 $L$ 是损失函数。对于回归问题，常用平方损失；对于分类问题，常用0-1损失或交叉熵损失。
问题在于：我们不知道 $P(X,Y)$，无法直接计算 $R(f)$。我们只能用经验风险（Empirical Risk）来近似：
$$\hat{R}(f) = \frac{1}{n}\sum_{i=1}^n L(y_i, f(x_i))$$
这就是经验风险最小化（ERM）的基本思想。但直接最小化经验风险会导致过拟合（overfitting）。
1.2 偏差-方差权衡 这是统计学习中最重要的概念之一。模型的预测误差可以分解为三个部分：
$$\mathbb{E}[(y - \hat{f}(x))^2] = \text{Bias}[\hat{f}(x)]^2 + \text{Var}[\hat{f}(x)] + \sigma^2$$
其中：
$\text{Bias}[\hat{f}(x)] = \mathbb{E}[\hat{f}(x)] - f^*(x)$：模型预测的期望与真实值的差距 $\text{Var}[\hat{f}(x)] = \mathbb{E}[(\hat{f}(x) - \mathbb{E}[\hat{f}(x)])^2]$：模型预测的方差 $\sigma^2$：不可约误差（数据本身的噪声） 偏差反映了模型的"假设强度"。如果模型过于简单（比如用线性模型拟合高度非线性的数据），会产生高偏差，导致欠拟合。
...</p></div><footer class=entry-footer><span title='2026-01-14 08:18:25 +0800 CST'>January 14, 2026</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>2161 words</span>&nbsp;·&nbsp;<span>s-ai-unix</span></footer><a class=entry-link aria-label="post link to 传统机器学习与统计学习算法：从理论到实践的完整指南" href=https://s-ai-unix.github.io/posts/2026-01-14-traditional-ml-algorithms-comprehensive-guide/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://s-ai-unix.github.io/tags/%E6%95%B0%E5%AD%A6%E5%8F%B2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://s-ai-unix.github.io/tags/%E6%95%B0%E5%AD%A6%E5%8F%B2/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://s-ai-unix.github.io/>s-ai-unix's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var n,t=e.innerHTML,s=!1;for(t.indexOf("<em>")!==-1&&(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("</em>")!==-1&&(n=t.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),n=n.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("<em>$")!==-1&&(n=t.replace(/<em>\$/g,"$"),n!==t&&(t=n,s=!0)),t.indexOf("</em>$")!==-1&&(n=t.replace(/<\/em>\$/g,"$"),n!==t&&(t=n,s=!0));t.indexOf("<em>")!==-1&&t.indexOf("</em>")!==-1;){if(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n===t)break;t=n,s=!0}t.indexOf("_{")!==-1&&(n=t.replace(/_{/g,"_{"),n!==t&&(t=n,s=!0)),t.indexOf("}_")!==-1&&(n=t.replace(/}_/g,"}"),n!==t&&(t=n,s=!0)),t.indexOf("\\\\")!==-1&&(n=t.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),n!==t&&(t=n,s=!0)),s&&(e.innerHTML=t)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>(function(){"use strict";function e(){var e=document.querySelectorAll("p, li, td, div, span, h1, h2, h3, h4, h5, h6, ol, ul");e.forEach(function(e){if(e.classList.contains("classical-quote-container")||e.classList.contains("quote-text")||e.closest(".classical-quote-container"))return;var n,t=e.innerHTML,s=!1;for(t.indexOf("<em>")!==-1&&(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("</em>")!==-1&&(n=t.replace(/\$([^$]*?)<\/em>([^$]*?)\$/g,function(e,t,n){return"$"+t+"_{"+n+"$"}),n=n.replace(/\$\$([^$]*?)<\/em>([^$]*?)\$\$/g,function(e,t,n){return"$$"+t+"_{"+n+"$$"}),n!==t&&(t=n,s=!0)),t.indexOf("<em>$")!==-1&&(n=t.replace(/<em>\$/g,"$"),n!==t&&(t=n,s=!0)),t.indexOf("</em>$")!==-1&&(n=t.replace(/<\/em>\$/g,"$"),n!==t&&(t=n,s=!0));t.indexOf("<em>")!==-1&&t.indexOf("</em>")!==-1;){if(n=t.replace(/\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$/g,function(e,t,n,s){return/^[\d.,]+$/.test((t+n+s).replace(/[.,]/g,""))?e:"$"+t+"_"+n+s+"$"}),n=n.replace(/\$\$([^$]*?)<em>([^<]+?)<\/em>([^$]*?)\$\$/g,function(e,t,n,s){return"$$"+t+"_"+n+s+"$$"}),n===t)break;t=n,s=!0}t.indexOf("_{")!==-1&&(n=t.replace(/_{/g,"_{"),n!==t&&(t=n,s=!0)),t.indexOf("}_")!==-1&&(n=t.replace(/}_/g,"}"),n!==t&&(t=n,s=!0)),t.indexOf("\\\\")!==-1&&(n=t.replace(/(\$\{1,2\})([^$]*?)(\$\{1,2\})/g,function(e,t,n,s){for(;n.indexOf("\\\\")!==-1;)n=n.replace(/\\\\/g,"\\");return t+n+s}),n!==t&&(t=n,s=!0)),s&&(e.innerHTML=t)})}window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,tags:"ams",macros:{oiint:"\\mathop{∯}",oiiint:"\\mathop{∰}"}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]},startup:{pageReady:function(){return e(),MathJax.startup.defaultPageReady().then(function(){console.log("MathJax formulas rendered successfully")})}}}})()</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=/css/mermaid-custom.css><script src=/js/mermaid-converter.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

  
  setTimeout(() => {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#1565c0',
        primaryBorderColor: '#2196f3',
        lineColor: '#42a5f5',
        secondaryColor: '#f3e5f5',
        tertiaryColor: '#fff9c4',
        background: '#ffffff',
        mainBkg: '#ffffff',
        nodeBorder: '#2196f3',
        clusterBkg: '#ffffff',
        clusterBorder: '#e0e0e0',
        titleColor: '#1565c0',
        edgeLabelBackground: '#fafafa',
      },
      securityLevel: 'loose',
    });
  }, 100);
</script><script src=/js/toc.js></script></body></html>